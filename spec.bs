<pre class="metadata">
Title: Protected Audience (formerly FLEDGE)
Shortname: protected-audience
Repository: WICG/turtledove
Inline Github Issues: true
Group: WICG
Status: CG-DRAFT
Level: 1
URL: https://wicg.github.io/turtledove/
Boilerplate: omit conformance, omit feedback-header
Editor: Paul Jensen, Google https://www.google.com/, pauljensen@google.com
Abstract: Provides a privacy advancing API to facilitate interest group based advertising.
!Participate: <a href="https://github.com/WICG/turtledove">GitHub WICG/turtledove</a> (<a href="https://github.com/WICG/turtledove/issues/new">new issue</a>, <a href="https://github.com/WICG/turtledove/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/turtledove/commits/main/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
Assume Explicit For: yes
</pre>

<pre class="anchors">
urlPrefix: https://fetch.spec.whatwg.org/; spec: Fetch
  type: dfn
    text: HTTP-network-or-cache fetch; url: #concept-http-network-or-cache-fetch
    text: task destination; for: fetch params; url: fetch-params-task-destination
urlPrefix: https://www.ietf.org/rfc/rfc4122.txt
  type: dfn; text: urn uuid
  type: dfn; text: string representation
  type: dfn; text: version 4 UUID
urlPrefix: https://tc39.github.io/ecma262/#; spec: ECMASCRIPT
  type: abstract-op
    text: ToString; url: sec-tostring
urlPrefix: https://github.com/WICG/turtledove/blob/main/FLEDGE_k_anonymity_server.md
  type: dfn; text: k-anonymity; url: what-is-k-anonymity
urlPrefix: https://developer.chrome.com/en/docs/privacy-sandbox/glossary/
  type: dfn; text: ad creative; url: ad-creative
spec: RFC4648; urlPrefix: https://datatracker.ietf.org/doc/html/rfc4648
  type: dfn; text: base64url; url: section-5
spec: RFC6234; urlPrefix: https://www.ietf.org/rfc/rfc6234.txt
  type: dfn; text: SHA-256
urlPrefix: https://datatracker.ietf.org/doc/html/rfc8032
  type: dfn
    text: verify; url: section-5.1.7
urlPrefix: https://datatracker.ietf.org/doc/html/rfc3986
  type:dfn
    text: unreserved percent encoding character; url: section-2.3
spec: html; urlPrefix: https://html.spec.whatwg.org/C
  type: dfn
    text: create an agent; url: create-an-agent
    text: immediately; url: immediately
    text: valid floating-point number; url: valid-floating-point-number
    text: serialization; for: origin; url: browsers.html#ascii-serialisation-of-an-origin
    text: structured clone algorithm; url: dom-structuredclone
spec: infra; urlPrefix: https://infra.spec.whatwg.org/
  type: dfn
    text: convert an Infra value to a JSON-compatible JavaScript value; url: #convert-an-infra-value-to-a-json-compatible-javascript-value
spec: RFC8941; urlPrefix: https://httpwg.org/specs/rfc8941.html
  type: dfn
    text: structured header; url: top
    for: structured header
      text: boolean; url: boolean
      text: integer; url: integer
      text: list; url: list
      text: string; url: string
spec: WebAssembly; urlPrefix: https://webassembly.github.io/spec/core/
  type: dfn
    urlPrefix: appendix/embedding.html
      text: error; url: embed-error
spec: WebAssembly-js-api; urlPrefix: https://webassembly.github.io/spec/js-api/
  type: dfn
    text: compiling a WebAssembly module; url: #compile-a-webassembly-module
spec: WebAssembly-web-api; urlPrefix: https://webassembly.github.io/spec/web-api/
  type: dfn
    text: compiling a potential WebAssembly response; url: #compile-a-potential-webassembly-response
spec: WebIDL; urlPrefix: https://webidl.spec.whatwg.org/
  type: dfn
    text: convert a Web IDL arguments list to an ECMAScript arguments list; url: #web-idl-arguments-list-converting
    text:an exception was thrown
spec: Fenced Frame; urlPrefix: https://wicg.github.io/fenced-frame/
  type: dfn
    for: browsing context
      text: fenced frame config instance; url: #browsing-context-fenced-frame-config-instance
spec: private-aggregation-api; urlPrefix: https://patcg-individual-drafts.github.io/private-aggregation-api
  type: dfn
    text: private-aggregation; url: #private-aggregation
    text: debug details; url: #debug-details
    text: debug-details-enabled; url: #debug-details-enabled
    text: debug-details-key; url: #debug-details-key
    text: aggregation coordinator; url: #aggregation-coordinator
    text: default aggregation coordinator; url: #default-aggregation-coordinator
    text: privateaggregation; url: #privateaggregation
    text: batching scope; url: #batching-scope
    text: debug scope; url: #debug-scope
    text: scoping details; url: #scoping-details
    text: contribution cache entry; url: #contribution-cache-entry
    text: contribution cache; url: #contribution-cache
    text: default filtering id max bytes; url: #default-filtering-id-max-bytes
spec: Shared Storage API; urlPrefix: https://wicg.github.io/shared-storage
  type: dfn
    text: shared-storage; url: #permissionspolicy-shared-storage
    text: shared-storage-select-url; url: #permissionspolicy-shared-storage-select-url
spec: CSP; urlPrefix: https://w3c.github.io/webappsec-csp/
  type: dfn
    text: directive name; url: directive-name
    text: directive value; url: directive-value
spec: CSPEE; urlPrefix: https://w3c.github.io/webappsec-cspee/
  type: dfn
    text: required csp; url: browsing-context-required-csp
</pre>

<pre class=link-defaults>
spec:encoding; type:dfn; text:utf-8
spec:infra; type:dfn; text:user agent
</pre>

<style>
/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
  padding: .5em;
  border: thin solid #ddd; border-radius: .5em;
  margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
  margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
  margin-bottom: 0;
}
[data-algorithm] [data-algorithm] {
  margin: 1em 0;
}

dl { padding-left: 1em; }

/* domintro from https://resources.whatwg.org/standard.css */
.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

.domintro dt, .domintro dt * {
  color: black;
  font-size: inherit;
}
.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
.domintro dd p {
  margin: 0.5em 0;
}
.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}
</style>

# Introduction # {#intro}

*This section is non-normative.*

The Protected Audience API facilitates selecting an advertisement to display to a user based on a
previous interaction with the advertiser or advertising network.

When a user's interactions with an advertiser indicate an interest in something, the advertiser can
ask the browser to record this interest on-device by calling
{{Window/navigator}}.{{Navigator/joinAdInterestGroup()}}. Later, when a website wants to select an
advertisement to show to the user, the website can call
{{Window/navigator}}.{{Navigator/runAdAuction()}} to ask the browser to conduct an
<dfn>auction</dfn> where each of these on-device recorded interests are given the chance to
calculate a bid to display their advertisement.


<h2 id="joining-interest-groups">Joining Interest Groups</h2>

*This first introductory paragraph is non-normative.*

When a user's interactions with a website indicate that the user may have a particular interest, an
advertiser or someone working on behalf of the advertiser (e.g. a demand side platform, DSP) can ask
the user's browser to record this interest on-device by calling
{{Window/navigator}}.{{Navigator/joinAdInterestGroup()}}. This indicates an intent to display an
advertisement relevant to this interest to this user in the future. The [=user agent=] has an
<dfn>interest group set</dfn>, a [=list=] of [=interest groups=] in which
[=interest group/owner=] / [=interest group/name=] pairs are unique.

<h3 id="join-ad-interest-groups">joinAdInterestGroup()</h3>

Issue: TODO: Currently, several of the IDL fields in {{AuctionAdInterestGroup}} are specified to use
USVString rather than DOMString, only because the initial implementation currently does. This may
contradict <a href="https://webidl.spec.whatwg.org/#idl-USVString">the recommended use of
DOMString</a>.
(<a href="https://github.com/WICG/turtledove/issues/1250">WICG/turtledove#1250</a>)

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<undefined> joinAdInterestGroup(AuctionAdInterestGroup group);
};

dictionary AuctionAd {
  required USVString renderURL;
  USVString sizeGroup;
  any metadata;

  USVString buyerReportingId;
  USVString buyerAndSellerReportingId;
  sequence<USVString> selectableBuyerAndSellerReportingIds;
  sequence<USVString> allowedReportingOrigins;
  DOMString adRenderId;
  USVString creativeScanningMetadata;
};

dictionary AuctionAdInterestGroupSize {
  required USVString width;
  required USVString height;
};

dictionary GenerateBidInterestGroup {
  required USVString owner;
  required USVString name;

  boolean enableBiddingSignalsPrioritization = false;
  record<DOMString, double> priorityVector;

  record<USVString, sequence<DOMString>> sellerCapabilities;
  DOMString executionMode = "compatibility";
  USVString biddingLogicURL;
  USVString biddingWasmHelperURL;
  USVString updateURL;
  USVString trustedBiddingSignalsURL;
  sequence<USVString> trustedBiddingSignalsKeys;
  DOMString trustedBiddingSignalsSlotSizeMode = "none";
  long maxTrustedBiddingSignalsURLLength;
  USVString trustedBiddingSignalsCoordinator;
  any userBiddingSignals;
  sequence<AuctionAd> ads;
  sequence<AuctionAd> adComponents;
  record<DOMString, AuctionAdInterestGroupSize> adSizes;
  record<DOMString, sequence<DOMString>> sizeGroups;
};

dictionary ProtectedAudiencePrivateAggregationConfig {
  USVString aggregationCoordinatorOrigin;
};

dictionary AuctionAdInterestGroup : GenerateBidInterestGroup {
  double priority = 0.0;
  record<DOMString, double> prioritySignalsOverrides;
  required double lifetimeMs;
  DOMString additionalBidKey;
  ProtectedAudiencePrivateAggregationConfig privateAggregationConfig;
};
</xmp>

{{AuctionAdInterestGroup}} is used by {{Window/navigator}}.{{Navigator/joinAdInterestGroup()}}, and
when an interest group is stored to [=interest group set=].
`priority` and `prioritySignalsOverrides` are not passed to `generateBid()` because they can be
modified by `generatedBid()` calls, so could theoretically be used to create a cross-site profile of
a user accessible to `generateBid()` methods, otherwise. `lifetimeMs` is not passed to `generateBid()`
because it's ambiguous what should be passed: the lifetime when the group was joined, or the
remaining lifetime. Providing the remaining lifetime would also potentially give access to more
granular timing information than the API would otherwise allow, when state is shared across interest
groups.

<div algorithm="joinAdInterestGroup()">

The <dfn for=Navigator method>joinAdInterestGroup(|group|)</dfn> method steps are:
<div class="note">

Temporarily, Chromium does not include the <a for="dictionary member"><span class="allow-2119">required</span></a> keyword
for {{AuctionAdInterestGroup/lifetimeMs}}, and instead starts this algorithm with the step

1. If |group|["{{AuctionAdInterestGroup/lifetimeMs}}"] does not [=map/exist=], throw a {{TypeError}}.

This is detectable because it can change the set of fields that are read from the argument when a
{{TypeError}} is eventually thrown, but it will never change whether the call succeeds or fails.

</div>
1. Let |global| be [=this=]'s [=relevant global object=].
1. If |global|'s [=associated Document=] is not [=allowed to use=] the "[=join-ad-interest-group=]"
  [=policy-controlled feature=], then [=exception/throw=] a "{{NotAllowedError}}" {{DOMException}}.
1. Let |settings| be [=this=]'s [=relevant settings object=].
1. [=Assert=] that |settings|'s [=environment settings object/origin=] is not an [=opaque origin=]
  and its [=origin/scheme=] is "`https`".
1. Let |interestGroup| be a new [=interest group=].
1. Validate the given |group| and set |interestGroup|'s fields accordingly.
  1. Set |interestGroup|'s [=interest group/expiry=] to the [=current coarsened wall time=] plus
    |group|["{{AuctionAdInterestGroup/lifetimeMs}}"] milliseconds.
  1. Set |interestGroup|'s [=interest group/next update after=] to the [=current coarsened wall
    time=] plus 24 hours.
  1. Set |interestGroup|'s [=interest group/last updated=] to the [=current coarsened wall time=].
  1. Set |interestGroup|'s [=interest group/owner=] to the result of [=parsing an https origin=] on
    |group|["{{GenerateBidInterestGroup/owner}}"].
  1. If |interestGroup|'s [=interest group/owner=] is failure, then [=exception/throw=] a {{TypeError}}.
  1. Optionally, [=exception/throw=] a "{{NotAllowedError}}" {{DOMException}}.

    Note: This [=implementation-defined=] condition is intended to allow [=user agents=] to decline
        for a number of reasons, for example the [=interest group/owner=]'s [=site=] not being
        <a href="https://github.com/privacysandbox/attestation">enrolled</a>.
  1. Set |interestGroup|'s [=interest group/name=] to |group|["{{GenerateBidInterestGroup/name}}"].
  1. Set |interestGroup|'s [=interest group/priority=] to
    |group|["{{AuctionAdInterestGroup/priority}}"].
  1. Set |interestGroup|'s [=interest group/enable bidding signals prioritization=] to
    |group|["{{GenerateBidInterestGroup/enableBiddingSignalsPrioritization}}"].
  1. If |group|["{{GenerateBidInterestGroup/priorityVector}}"] [=map/exists=], then set
    |interestGroup|'s [=interest group/priority vector=] to
    |group|["{{GenerateBidInterestGroup/priorityVector}}"].
  1. If |group|["{{AuctionAdInterestGroup/prioritySignalsOverrides}}"] [=map/exists=], then set
    |interestGroup|'s [=interest group/priority signals overrides=] to
    |group|["{{AuctionAdInterestGroup/prioritySignalsOverrides}}"].
  1. If |group|["{{AuctionAdInterestGroup/privateAggregationConfig}}"] [=map/exists=]:
    1. Let |aggregationCoordinator| be the result of [=obtaining the coordinator from a Private
      Aggregation config=] given |group|["{{AuctionAdInterestGroup/privateAggregationConfig}}"].
    1. If |aggregationCoordinator| is a {{DOMException}}, then [=exception/throw=]
      |aggregationCoordinator|.
    1. Set |interestGroup|'s [=interest group/Private Aggregation coordinator=] to
      |aggregationCoordinator|.
  1. If |group|["{{GenerateBidInterestGroup/sellerCapabilities}}"] [=map/exists=], [=map/for each=]
    |sellerString| → |capabilities| of |group|["{{GenerateBidInterestGroup/sellerCapabilities}}"]:
    1. Let |sellerCapabilities| be a new [=set=] of [=seller capabilities=].
    1. [=list/For each=] |capabilityString| of |capabilities|:
      1. If |capabilityString| is "`interest-group-counts`" or "`latency-stats`", then
        [=set/append=] |capabilityString| to |sellerCapabilities|.

        Note: For forward compatibility with new values, don't [=exception/throw=].
    1. If |sellerString| is "`*`", then set |interestGroup|'s
      [=interest group/all sellers capabilities=] to |sellerCapabilities|.
    1. Otherwise:
      1. If |interestGroup|'s [=interest group/seller capabilities=] is null, then set
        |interestGroup|'s [=interest group/seller capabilities=] to a new [=ordered map=] whose
        [=map/keys=] are [=origins=] and whose [=map/values=] are [=sets=] of [=seller capabilities=].
      1. Let |sellerUrl| be the result of running the [=URL parser=] on |sellerString|.
      1. If |sellerUrl| is not failure:
        1. Let |seller| be |sellerUrl|'s [=url/origin=].
        1. If |interestGroup|'s [=interest group/seller capabilities=] does not [=map/contain=]
          |seller|, then [=map/set=] |interestGroup|'s
          [=interest group/seller capabilities=][|seller|] to |sellerCapabilities|.
  1. If |group|["{{GenerateBidInterestGroup/executionMode}}"] is "`compatibility`",
    "`frozen-context`", or "`group-by-origin`", then set |interestGroup|'s
    [=interest group/execution mode=] to it.
  1. For each |groupMember| and |interestGroupField| in the following table
    <table class="data">
      <thead><tr><th>Group member</th><th>Interest group field</th></tr></thead>
      <tr>
        <td>"{{GenerateBidInterestGroup/biddingLogicURL}}"</td>
        <td>[=interest group/bidding url=]</td>
      </tr>
      <tr>
        <td>"{{GenerateBidInterestGroup/biddingWasmHelperURL}}"</td>
        <td>[=interest group/bidding wasm helper url=]</td>
      </tr>
      <tr>
        <td>"{{GenerateBidInterestGroup/updateURL}}"</td>
        <td>[=interest group/update url=]</td>
      </tr>
    </table>
    1. If |group| [=map/contains=] |groupMember|:
      1. Let |parsedUrl| be the result of running [=parse and verify a bidding code or update URL=]
        on |group|[|groupMember|] and |interestGroup|'s [=interest group/owner=].
      1. If |parsedUrl| is failure, then [=exception/throw=] a {{TypeError}}.
      1. Set |interestGroup|'s |interestGroupField| to |parsedUrl|.
  1. If |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsURL}}"] [=map/exists=]:
    1. Let |parsedUrl| be the result of running [=parse and verify a trusted signals URL=] on
      |group|[{{GenerateBidInterestGroup/trustedBiddingSignalsURL}}].
    1. If |parsedUrl| is failure, then [=exception/throw=] a {{TypeError}}.
    1. Set |interestGroup|'s [=interest group/trusted bidding signals url=] to |parsedUrl|.
  1. If |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsKeys}}"] [=map/exists=], then set
    |interestGroup|'s [=interest group/trusted bidding signals keys=] to
    |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsKeys}}"].
  1. If |group|["{{GenerateBidInterestGroup/maxTrustedBiddingSignalsURLLength}}"] [=map/exists=]:
    1. If |group|["{{GenerateBidInterestGroup/maxTrustedBiddingSignalsURLLength}}"] &ge; 0, set
      |interestGroup|'s [=interest group/max trusted bidding signals url length=] to
      |group|["{{GenerateBidInterestGroup/maxTrustedBiddingSignalsURLLength}}"], otherwise
      [=exception/throw=] a {{TypeError}}.
  1. If |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsCoordinator}}"] [=map/exists=]:
    1. Let |parsedCoordinator| be the result of [=parsing an https origin=] on
      |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsCoordinator}}"].
    1. If |parsedCoordinator| is failure, then [=exception/throw=] a {{TypeError}}.
    1. Set |interestGroup|'s [=interest group/trusted bidding signals coordinator=] to
      |parsedCoordinator|.
  1. If |group|["{{GenerateBidInterestGroup/userBiddingSignals}}"] [=map/exists=]:
    1. Set |interestGroup|'s [=interest group/user bidding signals=] to the result of
      [=serializing a JavaScript value to a JSON string=], given
      |group|["{{GenerateBidInterestGroup/userBiddingSignals}}"]. This can [=exception/throw=] a
      {{TypeError}}.
  1. If |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsSlotSizeMode}}"] is one of "none",
    "slot-size", or "all-slots-requested-sizes", set |interestGroup|'s
    [=interest group/trusted bidding signals slot size mode=] to
    |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsSlotSizeMode}}"].
  1. Let |adSizes| be a new [=map=] whose [=map/keys=] are [=strings=] and [=map/values=] are
     [=ad sizes=].
  1. If |group|["{{GenerateBidInterestGroup/adSizes}}"] [=map/exists=]:
    1. [=map/For each=] |sizeName| → |size| of |group|["{{GenerateBidInterestGroup/adSizes}}"]:
      1. If |sizeName| is "", [=exception/throw=] a {{TypeError}}.
      1. Let |parsedSize| be the result from running [=parse an AdRender ad size=] with |size|.
      1. If |parsedSize| is null, [=exception/throw=] a {{TypeError}}.
      1. [=map/Set=] |adSizes|[|sizeName|] to |parsedSize|.
    1. Set |interestGroup|'s [=interest group/ad sizes=] to |adSizes|.
  1. Let |sizeGroups| be a new [=map=] whose [=map/keys=] are [=strings=] and [=map/values=]
     are [=lists=] of [=strings=]
  1. If |group|["{{GenerateBidInterestGroup/sizeGroups}}"] [=map/exists=]:
    1. [=map/For each=] |sizeGroupName| → |sizeList| of
       |group|["{{GenerateBidInterestGroup/sizeGroups}}"]:
      1. If |sizeGroupName| is "", [=exception/throw=] a {{TypeError}}.
      1. [=list/For each=] |sizeName| of |sizeList|:
        1. If |sizeName| is "" or |adSizes|[|sizeName|] does not [=map/exist=],
           [=exception/throw=] a {{TypeError}}.
      1. [=map/Set=] |sizeGroups|[|sizeGroupName|] to |sizeList|.
    1. Set |interestGroup|'s [=interest group/size groups=] to |sizeGroups|.
  1. For each |groupMember| and |interestGroupField| in the following table
    <table class="data">
      <thead><tr><th>Group member</th><th>Interest group field</th></tr></thead>
      <tr>
        <td>"{{GenerateBidInterestGroup/ads}}"</td>
        <td>[=interest group/ads=]</td>
      </tr>
      <tr>
        <td>"{{GenerateBidInterestGroup/adComponents}}"</td>
        <td>[=interest group/ad components=]</td>
      </tr>
    </table>
    1. If |group| [=map/contains=] |groupMember|, [=list/for each=] |ad| of |group|[|groupMember|]:
      1. Let |igAd| be a new [=interest group ad=].
      1. Let |renderURL| be the result of running the [=URL parser=] on
        |ad|["{{AuctionAd/renderURL}}"].
      1. [=exception/Throw=] a {{TypeError}} if any of the following conditions hold:
        * |renderURL| is failure;
        * |renderURL| [=url/scheme=] is not "`https`";
        * |renderURL| [=includes credentials=].
      1. Set |igAd|'s [=interest group ad/render url=] to |renderURL|.
      1. If |ad|["{{AuctionAd/sizeGroup}}"] [=map/exists=]:
        1. Let |sizeGroup| be |ad|["{{AuctionAd/sizeGroup}}}].
        1. [=exception/Throw=] a {{TypeError}} if none of the following conditions hold:
           * |adSizes|[|sizeGroup|] [=map/exists=].
           * |sizeGroups|[|sizeGroup|] [=map/exists=].
        1. Set |igAd|'s [=interest group ad/size group=] to |sizeGroup|.
      1. If |ad|["{{AuctionAd/metadata}}"] [=map/exists=], then let
        |igAd|'s [=interest group ad/metadata=] be the result of
        [=serializing a JavaScript value to a JSON string=], given |ad|["{{AuctionAd/metadata}}"].
        This can [=exception/throw=] a {{TypeError}}.
      1. If |ad|["{{AuctionAd/adRenderId}}"] [=map/exists=]:
        1. If |ad|["{{AuctionAd/adRenderId}}"]'s [=string/length=] &gt; 12, [=exception/throw=] a {{TypeError}}.
        1. If any [=code point=] in |ad|["{{AuctionAd/adRenderId}}"] is not an [=ASCII code point=], [=exception/throw=] a {{TypeError}}.
        1. Set |igAd|'s [=interest group ad/ad render id=] to |ad|["{{AuctionAd/adRenderId}}"].
      1. If |ad|["{{AuctionAd/creativeScanningMetadata}}"] [=map/exists=], then set
        |igAd|'s [=interest group ad/creative scanning metadata=] to it.
      1. If |groupMember| is "{{GenerateBidInterestGroup/ads}}":
        1. If |ad|["{{AuctionAd/buyerReportingId}}"] [=map/exists=], then set
          |igAd|'s [=interest group ad/buyer reporting ID=] to it.
        1. If |ad|["{{AuctionAd/buyerAndSellerReportingId}}"] [=map/exists=],
          then set |igAd|'s [=interest group ad/buyer and seller reporting ID=] to it.
        1. If |ad|["{{AuctionAd/selectableBuyerAndSellerReportingIds}}"] [=map/exists=],
          then set |igAd|'s [=interest group ad/selectable buyer and seller reporting IDs=] to it.
        1. If |ad|["{{AuctionAd/allowedReportingOrigins}}"] [=map/exists=]:
          1. Let |allowedReportingOrigins| be a new [=list=] of [=origins=].
          1. [=list/For each=] |originStr| in |ad|["{{AuctionAd/allowedReportingOrigins}}"]:
            1. Let |origin| be the result of [=parsing an https origin=] on |originStr|.
            1. If |origin| is failure, then [=exception/throw=] a {{TypeError}}.
            1. [=list/Append=] |origin| to |allowedReportingOrigins|.
            1. If |allowedReportingOrigins|'s [=list/size=] &gt; 10, [=exception/throw=]
              a {{TypeError}}.
          1. Set |igAd|'s [=interest group ad/allowed reporting origins=] to |allowedReportingOrigins|.
      1. [=list/Append=] |igAd| to |interestGroup|'s |interestGroupField|.
  1. If |group|["{{AuctionAdInterestGroup/additionalBidKey}}"] [=map/exists=]:
    1. Let |decodedKey| be the result of running [=forgiving-base64 decode=] with
      |group|["{{AuctionAdInterestGroup/additionalBidKey}}"].
    1. [=exception/Throw=] a {{TypeError}} if any of the following conditions hold:
      * |decodedKey| is a failure;
      * |decodedKey|'s [=byte sequence/length=] is not 32;
      * |group|["{{GenerateBidInterestGroup/ads}}"] [=map/exists=];

      * |group|["{{GenerateBidInterestGroup/updateURL}}"] [=map/exists=].
    1. Set |interestGroup|'s [=interest group/additional bid key=] to |decodedKey|.
1. If |interestGroup|'s [=interest group/estimated size=] &gt; 1048576 bytes, then [=exception/throw=] a
  {{TypeError}}.
1. Let |p| be [=a new promise=].
1. Let |queue| be the result of [=starting a new parallel queue=].
1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |queue|:
  1. Let |permission| be the result of [=checking interest group permissions=] with
    |interestGroup|'s [=interest group/owner=], |settings|, and "`join`".
  1. If |permission| is false, then [=queue a global task=] on [=DOM manipulation task source=],
    given |global|, to [=reject=] |p| with a "{{NotAllowedError}}" {{DOMException}} and abort these
    steps.
  1. [=Queue a global task=] on [=DOM manipulation task source=], given |global|, to [=resolve=] |p|
    with `undefined`.
  1. If the browser is currently storing an interest group with `owner` and `name` that matches
    |interestGroup|, then set the [=interest group/bid counts=],
    [=interest group/join counts=], and [=interest group/previous wins=] of
    |interestGroup| to the values of the currently stored one and remove
    the currently stored one from the browser.
  1. Set |interestGroup|'s [=interest group/joining origin=] to [=this=]'s
    [=relevant settings object=]'s [=environment/top-level origin=].
  1. Set |interestGroup|'s [=interest group/join time=] to the [=current coarsened wall time=].
  1. If the most recent entry in |interestGroup|'s [=interest group/join counts=] corresponds to
    the current day in UTC, increment its count. If not, [=list/insert=] a new [=tuple=]
    the time set to the current UTC day and a count of 1.
  1. Store |interestGroup| in the [=user agent=]'s [=interest group set=].
  1. Run [=update k-anonymity cache for interest group=] for |interestGroup|.
1. Return |p|.

</div>

<h3 id="interest-group-storage-maintenance">Interest Group Storage Maintenance</h3>

There is a job that periodically [=performs storage maintenance=] on the [=user agent=]'s
[=interest group set=]. It performs operations such as [=list/removing=] expired or excess
[=interest groups=]. An [=interest group set=] must respect the following limits. Implementations
may define their own values for the below constants, however we supply the below values as a
starting point, inspired by what the initial implementation of this specification uses:
  * <dfn>Interest group set max owners</dfn> is 1000, which defines the max number of
    [=interest group/owners=] in the [=user agent=]'s [=interest group set=].
  * <dfn>Max regular interest groups per owner</dfn> is 2000, which defines the max number of
    [=regular interest groups=] in the [=user agent=]'s [=interest group set=] for an
    [=interest group/owner=].
  * <dfn>Max negative interest groups per owner</dfn> is 20000, which defines the max number of
    [=negative interest groups=] in the [=user agent=]'s [=interest group set=] for an
    [=interest group/owner=].
  * <dfn>Max interest groups total size per owner</dfn> is <code>10\*1024\*1024</code>, which
    defines the max total [=interest group/estimated size|sizes=] of [=interest groups=] in the
    [=user agent=]'s [=interest group set=] for an [=interest group/owner=]. It includes both
    [=regular interest groups=] and [=negative interest groups=].

<div algorithm>
To <dfn>perform storage maintenance</dfn>:

1. Let |ownersAndExpiry| be a new [=ordered map=] whose [=map/keys=] are [=origins=] and
  [=map/values=] are [=moments=].

  Note: The [=map/key=] is from [=interest group/owner=], and [=map/value=] is from
    [=interest group/expiry=]. It's used to determine a set of [=interest group/owners=] whose
    [=interest groups=] will be removed from the [=user agent=]'s [=interest group set=] because the
    number of distinct [=interest group/owners=] exceeds the [=Interest group set max owners=] limit.
    It's sorted based on their [=map/values=] ([=interest group/expiry=]) in descending order, in
    order to remove [=interest groups=] of [=interest group/owners=] expiring soonest first.

1. Let |now| be the [=current coarsened wall time=].
1. [=list/For each=] |ig| of the [=user agent=]'s [=interest group set=]:
  1. Let |owner| be |ig|'s [=interest group/owner=].
  1. If |ig|'s [=interest group/expiry=] is before |now|, then [=list/remove=] |ig| from the
    [=user agent=]'s [=interest group set=] and [=iteration/continue=].
  1. If |ownersAndExpiry|[|owner|] [=map/exists=], then [=map/set=] |ownersAndExpiry|[|owner|] to
    |ig|'s [=interest group/expiry=] if it comes after |ownersAndExpiry|[|owner|].
  1. Otherwise, [=map/set=] |ownersAndExpiry|[|owner|] to |ig|'s [=interest group/expiry=].
1. If |ownersAndExpiry|'s [=map/size=] &gt; [=interest group set max owners=], then [=map/set=]
  |ownersAndExpiry| to |ownersAndExpiry| [=map/sorted in descending order=] with |a| being less than
  |b| if |a|'s [=map/value=] comes before |b|'s [=map/value=], where [=map/values=] are
  [=interest group/expiry=].
1. Let |owners| be the [=map/get the keys|keys=] of |ownersAndExpiry|.
1. [=list/For each=] |i| in [=the range=] from 0 to |owners|'s [=set/size=], exclusive:
  1. If |i| &ge; [=interest group set max owners=], then [=list/remove=] [=interest groups=] from
    the [=user agent=]'s [=interest group set=] whose [=interest group/owner=] is |owners|[|i|], and
    [=iteration/continue=].
  1. Let |regularIgs| be a [=list=] of [=regular interest groups=] in the [=user agent=]'s
    [=interest group set=] whose [=interest group/owner=] is |owners|[|i|].
  1. If |regularIgs|'s [=list/size=] &gt; [=max regular interest groups per owner=], then
    [=clear excess interest groups=] with |regularIgs| and [=max regular interest groups per owner=].
  1. Let |negativeIgs| be a [=list=] of [=negative interest groups=] in the [=user agent=]'s
    [=interest group set=] whose [=interest group/owner=] is |owners|[|i|].
  1. If |negativeIgs|'s [=list/size=] &gt; [=max negative interest groups per owner=], then
    [=clear excess interest groups=] with |negativeIgs| and [=max negative interest groups per owner=].
1. [=list/For each=] |owner| of |owners|:
  1. Let |igs| be a [=list=] of [=interest groups=] in the [=user agent=]'s [=interest group set=]
    whose [=interest group/owner=] is |owner|, [=list/sorted in descending order=] with |a| being
    less than |b| if |a|'s [=interest group/expiry=] comes before |b|'s [=interest group/expiry=].
  1. Let |cumulativeSize| be 0.
  1. [=list/For each=] |ig| of |igs|:
    1. If the sum of |cumulativeSize| and |ig|'s [=interest group/estimated size=]
      &gt; [=max interest groups total size per owner=], then [=list/remove=] |ig| from the
      [=user agent=]'s [=interest group set=].
    1. Otherwise, increment |cumulativeSize| by |ig|'s [=interest group/estimated size=].

</div>

<div algorithm>
To <dfn>clear excess interest groups</dfn> with a [=list=] of [=interest groups=] |igs|, and an
integer |maxIgs|:

1. Let |sortedIgs| be |igs| [=list/sorted in descending order=] with |a| being less
  than |b| if |a|'s [=interest group/expiry=] comes before |b|'s [=interest group/expiry=].

  Note: In order to remove interest groups expiring soonest first, sort interest groups based on
    their expiry in descending order.

1. [=list/For each=] |i| in [=the range=] from |maxIgs| to |igs|'s [=list/size=], exclusive:
  1. [=list/Remove=] |sortedIgs|[|i|] from the [=user agent=]'s [=interest group set=].

</div>

<h2 id="leaving-interest-groups">Leaving Interest Groups</h2>

<h3 id="leaveadinterestgroup">leaveAdInterestGroup()</h3>

*This first introductory paragraph is non-normative.*

{{Window/navigator}}.{{Navigator/leaveAdInterestGroup()}} removes a user from a particular interest
group.


<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<undefined> leaveAdInterestGroup(optional AuctionAdInterestGroupKey group = {});
};

dictionary AuctionAdInterestGroupKey {
  required USVString owner;
  required USVString name;
};
</xmp>

<div algorithm>

The <dfn for=Navigator method>leaveAdInterestGroup(group)</dfn> method steps are:

1. Let |global| be [=this=]'s [=relevant global object=].
1. Let |settings| be [=this=]'s [=relevant settings object=].
1. Let |frameOrigin| be |settings|'s [=environment settings object/origin=].
1. [=Assert=] that |frameOrigin| is not an [=opaque origin=] and its [=origin/scheme=] is "`https`".
1. Let |p| be [=a new promise=].
1. If |group| [=map/is empty=]:
  1. Let |instance| be |global|'s [=Window/browsing context=]'s
    [=browsing context/fenced frame config instance=].
  1. If |instance| is null, then return.
  1. Let |interestGroup| be |instance|'s [=fenced frame config instance/interest group descriptor=].
  1. Run these steps [=in parallel=]:
    1. [=Queue a global task=] on [=DOM manipulation task source=], given |global|, to [=resolve=]
      |p| with `undefined`.
    1. If |interestGroup| is not null:
      1. Let |owner| be |interestGroup|'s [=interest group descriptor/owner=].
      1. If |owner| is [=same origin=] with |frameOrigin|, then [=list/remove=] [=interest groups=]
        from the [=user agent=]'s [=interest group set=] whose [=interest group/owner=] is |owner| and
        [=interest group/name=] is |interestGroup|'s [=interest group descriptor/name=].
1. Otherwise:
  1. If |global|'s [=associated Document=] is not [=allowed to use=] the
    "[=join-ad-interest-group=]" [=policy-controlled feature=], then [=exception/throw=] a
    "{{NotAllowedError}}" {{DOMException}}.

    Note: Both joining and leaving interest groups use the "join-ad-interest-group" feature.
  1. Let |owner| be the result of [=parsing an https origin=] with
    |group|["{{AuctionAdInterestGroupKey/owner}}"].
  1. If |owner| is failure, [=exception/throw=] a {{TypeError}}.
  1. Run these steps [=in parallel=]:
    1. Let |permission| be the result of [=checking interest group permissions=] with |owner|,
      |settings|, and "`leave`".
    1. If |permission| is false, then [=queue a global task=] on [=DOM manipulation task source=],
      given |global|, to [=reject=] |p| with a "{{NotAllowedError}}" {{DOMException}} and abort
      these steps.
    1. [=Queue a global task=] on [=DOM manipulation task source=], given |global|, to [=resolve=]
      |p| with `undefined`.
    1. [=list/Remove=] [=interest groups=] from the [=user agent=]'s [=interest group set=] whose
      [=interest group/owner=] is |owner| and [=interest group/name=] is
      |group|["{{AuctionAdInterestGroupKey/name}}"].
1. Return |p|.

</div>

<h3 id="clearoriginjoinedAdInterestGroups">clearOriginJoinedAdInterestGroups()</h3>

*This first introductory paragraph is non-normative.*

{{Window/navigator}}.{{Navigator/clearOriginJoinedAdInterestGroups()}} removes a user from
[=interest groups=] whose [=interest group/joining origin=] is the associated
{{Navigator}}'s [=relevant settings object=]'s [=environment/top-level origin=].


<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<undefined> clearOriginJoinedAdInterestGroups(
      USVString owner, optional sequence<USVString> interestGroupsToKeep = []);
};
</xmp>

<div algorithm>

The <dfn for=Navigator method>clearOriginJoinedAdInterestGroups(|owner|, |interestGroupsToKeep|)</dfn>
method steps are:

1. Let |settings| be [=this=]'s [=relevant settings object=].
1. Let |frameOrigin| be |settings|'s [=environment settings object/origin=].
1. [=Assert=] that |frameOrigin| is not an [=opaque origin=] and its [=origin/scheme=] is "`https`".
1. Let |p| be [=a new promise=].
1. Let |global| be [=this=]'s [=relevant global object=].
1. If |global|'s [=associated Document=] is not [=allowed to use=] the
  "[=join-ad-interest-group=]" [=policy-controlled feature=], then [=exception/throw=] a
  "{{NotAllowedError}}" {{DOMException}}.

  Note: Both joining and leaving interest groups use the "join-ad-interest-group" feature.
1. Let |ownerOrigin| be the result of [=parsing an https origin=] with |owner|.
1. If |ownerOrigin| is failure, [=exception/throw=] a {{TypeError}}.
1. Run these steps [=in parallel=]:
  1. Let |permission| be the result of [=checking interest group permissions=] with
    |ownerOrigin|, |settings|, and "`leave`".
  1. If |permission| is false, then [=queue a global task=] on the [=DOM manipulation task source=]
    given |global|, [=reject=] |p| with a "{{NotAllowedError}}" {{DOMException}} and abort these steps.
  1. [=Queue a global task=] on the [=DOM manipulation task source=] given |global|, to [=resolve=] |p|
    with {{undefined}}.
  1. [=list/Remove=] [=interest groups=] from the [=user agent=]'s [=interest group set=]
    whose [=interest group/owner=] is |ownerOrigin|, whose [=interest group/joining origin=] is
    |frameOrigin|, and whose [=interest group/name=] is not in |interestGroupsToKeep|.
1. Return |p|.

</div>

<h2 id="running-ad-auctions">Running Ad Auctions</h2>

*This first introductory paragraph is non-normative.*

When a website or someone working on behalf of the website (e.g. a supply side platform, SSP) wants
to conduct an auction to select an advertisement to display to the user, they can call the
{{Window/navigator}}.{{Navigator/runAdAuction()}} function, providing an auction configuration that
tells the browser how to conduct the auction and which on-device recorded interests are allowed to
bid in the auction for the chance to display their advertisement.

<h3 id="runadauction">runAdAuction()</h3>

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<(USVString or FencedFrameConfig)?> runAdAuction(AuctionAdConfig config);
  readonly attribute boolean deprecatedRunAdAuctionEnforcesKAnonymity;
};

dictionary AuctionReportBuyersConfig {
  required bigint bucket;
  required double scale;
};

dictionary AuctionReportBuyerDebugModeConfig {
  boolean enabled = false;

  // Must only be provided if `enabled` is true.
  bigint? debugKey;
};

dictionary AuctionRealTimeReportingConfig {
  required DOMString type;
};

dictionary AuctionAdConfig {
  required USVString seller;
  required USVString decisionLogicURL;

  USVString trustedScoringSignalsURL;
  long maxTrustedScoringSignalsURLLength;
  USVString trustedScoringSignalsCoordinator;
  boolean sendCreativeScanningMetadata;
  sequence<USVString> interestGroupBuyers;
  Promise<any> auctionSignals;
  Promise<any> sellerSignals;
  Promise<DOMString?> directFromSellerSignalsHeaderAdSlot;
  Promise<record<USVString, USVString>?> deprecatedRenderURLReplacements;
  unsigned long long sellerTimeout;
  unsigned short sellerExperimentGroupId;
  Promise<record<USVString, any>?> perBuyerSignals;
  Promise<record<USVString, unsigned long long>?> perBuyerTimeouts;
  Promise<record<USVString, unsigned long long>?> perBuyerCumulativeTimeouts;
  unsigned long long reportingTimeout;
  USVString sellerCurrency;
  Promise<record<USVString, USVString>?> perBuyerCurrencies;
  record<USVString, unsigned short> perBuyerMultiBidLimits;
  record<USVString, unsigned short> perBuyerGroupLimits;
  record<USVString, unsigned short> perBuyerExperimentGroupIds;
  record<USVString, record<USVString, double>> perBuyerPrioritySignals;

  sequence<bigint> auctionReportBuyerKeys;
  record<DOMString, AuctionReportBuyersConfig> auctionReportBuyers;
  AuctionReportBuyerDebugModeConfig auctionReportBuyerDebugModeConfig;
  sequence<DOMString> requiredSellerCapabilities;
  ProtectedAudiencePrivateAggregationConfig privateAggregationConfig;

  record<DOMString, DOMString> requestedSize;
  sequence<record<DOMString, DOMString>> allSlotsRequestedSizes;
  Promise<undefined> additionalBids;
  DOMString auctionNonce;
  AuctionRealTimeReportingConfig sellerRealTimeReportingConfig;
  record<USVString, AuctionRealTimeReportingConfig> perBuyerRealTimeReportingConfig;
  sequence<AuctionAdConfig> componentAuctions = [];
  AbortSignal? signal;
  Promise<boolean> resolveToConfig;

  Promise<Uint8Array> serverResponse;
  USVString requestId;
};
</xmp>

Note: To help with ease of adoption, the browser will support the attribute
{{Window/navigator}}.{{Navigator/deprecatedRunAdAuctionEnforcesKAnonymity}}
while k-anonymity enforcement is being rolled out. This attribute is true
when {{Window/navigator}}.{{Navigator/runAdAuction()}} enforces
[[#k-anonymity]] when running an auction and false otherwise. The attribute
is not useful once k-anonymity enforcement is fully rolled out, and hence
this attribute will be deprecated and removed some time after this point.
See <a href="https://developers.google.com/privacy-sandbox/relevance/protected-audience-api/k-anonymity">
https://developers.google.com/privacy-sandbox/relevance/protected-audience-api/k-anonymity</a> for
more up to date information.

<div algorithm="runAdAuction()">

The <dfn for=Navigator method>runAdAuction(|config|)</dfn> method steps are:

1. Let |global| be [=this=]'s [=relevant global object=].
1. Let |settings| be [=this=]'s [=relevant settings object=].
1. If |global|'s [=associated Document=] is not [=allowed to use=] the "[=run-ad-auction=]"
  [=policy-controlled feature=], then [=exception/throw=] a "{{NotAllowedError}}" {{DOMException}}.
1. Let |privateAggregationAllowed| be the result of determining whether |global|'s [=associated
  Document=] is [=allowed to use=] the "<code>[=private-aggregation=]</code>" [=policy-controlled
  feature=].
1. Let |auctionConfig| be the result of running [=validate and convert auction ad config=] with
  |config| and true.
1. If |auctionConfig| is failure, then [=exception/throw=] a {{TypeError}}.
1. Optionally, [=exception/throw=] a "{{NotAllowedError}}" {{DOMException}}.

    Note: This [=implementation-defined=] condition is intended to allow [=user agents=] to decline
        for a number of reasons, for example the [=auction config/seller=]'s [=site=] not being
        <a href="https://github.com/privacysandbox/attestation">enrolled</a>.
1. Let |p| be [=a new promise=].
1. Let |configMapping| be |global|'s [=associated Document=]'s [=node navigable=]'s
  [=navigable/traversable navigable=]'s [=traversable navigable/fenced frame config mapping=].
1. Let |pendingConfig| be the result of [=constructing a pending fenced frame config=] with
  |auctionConfig|.
1. Let |urn| be the result of running [=fenced frame config mapping/store a pending config=] on
  |configMapping| with |pendingConfig|.
1. If |urn| is failure, then resolve |p| with null and return |p|.
1. Let |bidIgs| be a new [=list=] of [=interest groups=].
1. If |config|["{{AuctionAdConfig/signal}}"] [=map/exists=], then:
  1. Let |signal| be |config|["{{AuctionAdConfig/signal}}"].
  1. If |signal| is [=AbortSignal/aborted=], then [=reject=] |p| with |signal|'s
    [=AbortSignal/abort reason=] and return |p|.
  1. Otherwise [=AbortSignal/Add|add the following abort steps=] to |signal|:
    1. Set |auctionConfig|'s [=auction config/aborted=] to true.
    1. Set |auctionConfig|'s [=auction config/abort reason=] to |signal|'s [=AbortSignal/abort reason=].
    1. [=list/For each=] |auction| in |auctionConfig|'s [=auction config/component auctions=]:
      1. Set |auction|'s [=auction config/aborted=] to true.
1. [=Assert=] that |settings|'s [=environment settings object/origin=] is not an [=opaque origin=]
  and its [=origin/scheme=] is "`https`".
1. Let |queue| be the result of [=starting a new parallel queue=].
1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |queue|:
  1. Let |reportingContextMap| be the result of [=creating a reporting context map=] given
    |auctionConfig| and |privateAggregationAllowed|.
  1. If |auctionConfig|'s [=auction config/server response=] is not null:
    1. Let |winnerInfo| be the result of running [=parse and validate server response=] with
      |auctionConfig|, null, |global|, |bidIgs|, and |reportingContextMap|.
  1. Otherwise:
    1. Let |realTimeContributionsMap| be a new [=real time reporting contributions map=].
    1. Let |winnerInfo| be the result of running [=generate and score bids=] with |auctionConfig|,
      null, |global|, |bidIgs|, |reportingContextMap|, and |realTimeContributionsMap|.
  1. Let |auctionReportInfo| be a new [=auction report info=].
  1. If |winnerInfo| is not failure, then:
    1. Set |auctionReportInfo| to the result of running [=collect forDebuggingOnly reports=] with
      |reportingContextMap|, |auctionConfig|'s [=auction config/seller=], and |winnerInfo|.
    1. Set |auctionReportInfo|'s [=auction report info/real time reporting contributions map=] to
      |realTimeContributionsMap|.
  1. If |auctionConfig|'s [=auction config/aborted=] is true:
    1. [=Queue a global task=] on the [=DOM manipulation task source=], given |global|, to
       [=reject=] |p| with |auctionConfig|'s [=auction config/abort reason=].
  1. Otherwise if |winnerInfo| is failure, then [=queue a global task=] on [=DOM manipulation task source=],
    given |global|, to [=reject=] |p| with a "{{TypeError}}".
  1. Otherwise if |winnerInfo| is null or |winnerInfo|'s [=leading bid info/leading bid=] is null:
    1. [=Queue a global task=] on [=DOM manipulation task source=], given |global|, to [=resolve=]
      |p| with null.
    1. [=list/For each=] |reportUrl| of |auctionReportInfo|'s
      [=auction report info/debug loss report urls=]:
      1. [=Send report=] with |reportUrl| and |settings|.
    1. [=Send real time reports=] with |auctionReportInfo|'s
      [=auction report info/real time reporting contributions map=] and |settings|.
    1. [=Process the Private Aggregation contributions=] given |auctionConfig|,
      |reportingContextMap|.
  1. Otherwise:
    1. Let |winner| be |winnerInfo|'s [=leading bid info/leading bid=].
    1. Let |fencedFrameConfig| be the result of [=filling in a pending fenced frame config=] with
       |pendingConfig|, |auctionConfig|, |reportingContextMap|, |winnerInfo|, |auctionReportInfo|,
       and |settings|.
    1. [=fenced frame config mapping/Finalize a pending config=] on |configMapping| with |urn| and
       |fencedFrameConfig|.
    1. Wait until |auctionConfig|'s [=auction config/resolve to config=] is a boolean.
    1. Let |result| be |fencedFrameConfig|.
    1. If |auctionConfig|'s [=auction config/resolve to config=] is false, then set |result| to |urn|.
    1. [=Queue a global task=] on the [=DOM manipulation task source=], given |global|, to
       resolve |p| with |result|.
    1. Run [=update previous wins=] with |winner|.
  1. Run [=interest group update=] with |auctionConfig|'s [=auction config/interest group buyers=]
    and |settings|'s [=environment settings object/policy container=].
  1. Run [=update bid counts=] with |bidIgs|.
1. Return |p|.

</div>

<div algorithm>

To <dfn>construct a pending fenced frame config</dfn> given an [=auction config=]
|config|:
1. Return a [=fenced frame config=] with the following [=struct/items=]:
  : [=fenced frame config/mapped url=]
  :: a [=struct=] with the following [=struct/items=]:
    : [=mapped url/value=]
    :: `"about:blank"`

    : [=mapped url/visibility=]
    :: "<a for=visibility>`opaque`</a>"

  : [=fenced frame config/container size=]
  :: the result of

   Issue: converting |config|'s [=auction config/requested size=] to pixel values
   (<a href="https://github.com/WICG/turtledove/issues/986">WICG/turtledove#986</a>)

  : [=fenced frame config/content size=]
  :: null

  : [=fenced frame config/interest group descriptor=]
  :: a [=struct=] with the following [=struct/items=]:
    : [=interest group descriptor/value=]
    :: a [=struct=] with the following [=struct/items=]:
      : [=interest group descriptor/owner=]
      :: ""

      : [=interest group descriptor/name=]
      :: ""

    : [=interest group descriptor/visibility=]
    :: "<a for=visibility>`opaque`</a>"

  : [=fenced frame config/on navigate callback=]
  :: null

  : [=fenced frame config/effective sandboxing flags=]
  :: a [=struct=] with the following [=struct/items=]:
    : [=effective sandboxing flags/value=]
    :: TODO: fill this in once fenced frame sandbox flags are more fully specified

    : [=effective sandboxing flags/visibility=]
    :: "<a for=visibility>`opaque`</a>"

  : [=fenced frame config/effective enabled permissions=]
  :: a [=struct=] with the following [=struct/items=]:
    : [=effective enabled permissions/value=]
    :: «"<code>{{PermissionPolicy/attribution-reporting}}</code>",
        "<code>[=private-aggregation=]</code>", "<code>[=shared-storage=]</code>",
        "<code>[=shared-storage-select-url=]</code>"»

    : [=effective enabled permissions/visibility=]
    :: "<a for=visibility>`opaque`</a>"

  : [=fenced frame config/fenced frame reporting metadata=]
  :: null

  : [=fenced frame config/exfiltration budget metadata=]
  :: null

  : [=fenced frame config/nested configs=]
  :: a [=struct=] with the following [=struct/items=]:
    : [=nested configs/value=]
    :: an empty [=list=] «»

    : [=nested configs/visibility=]
    :: "<a for=visibility>`opaque`</a>"

  : [=fenced frame config/embedder shared storage context=]
  :: null

</div>

<div algorithm>

To <dfn>fill in a pending fenced frame config</dfn> given a [=fenced frame config=]
|pendingConfig|, [=auction config=] |auctionConfig|, [=reporting context map=]
|reportingContextMap|, [=leading bid info=] |winningBidInfo|, [=auction report info=]
|auctionReportInfo|, and an [=environment settings object=] |settings|:
1. Let |winningBid| be |winningBidInfo|'s [=leading bid info/leading bid=].
1. Let |replacements| be an [=ordered map=] whose [=map/keys=] are [=strings=] and whose
  [=map/values=] are [=strings=].
1. [=list/For each=] |replacement| in |auctionConfig|'s
  [=auction config/deprecated render url replacements=]:
  1. Let |k| be |replacement|'s [=ad keyword replacement/match=].
  1. Let |v| be |replacement|'s [=ad keyword replacement/replacement=].
  1. [=map/Set=] |replacements|[|k|] to |v|.
1. Let |replacedAdURL| be the result of
  running [=fencedframeutil/substitute macros=] with |replacements| and |winningBid|'s
  [=generated bid/ad descriptor=]'s [=ad descriptor/url=].
1. Set |pendingConfig|'s [=fenced frame config/mapped url=]'s [=mapped url/value=] to
   |replacedAdURL|.
1. Let |adSize| be |winningBid|'s [=generated bid/ad descriptor=]'s [=ad descriptor/size=].
1. Let |concreteAdSize| be the result of

   Issue: resolving screen-relative sizes to pixel values for |adSize|.
   (<a href="https://github.com/WICG/turtledove/issues/986">WICG/turtledove#986</a>)
1. Let |adWidthString| and |adHeightString| be the result of

   Issue: converting |concreteAdSize| to strings.
   (<a href="https://github.com/WICG/turtledove/issues/986">WICG/turtledove#986</a>)
1. Let |sizeMacroMap| be the [=ordered map=] «[ "{%AD_WIDTH%}" → |adWidthString|,
   "{%AD_HEIGHT%}" → |adHeightString|, "${AD_WIDTH}" → |adWidthString|,
   "${AD_HEIGHT}" → |adHeightString|]»
1. Set |pendingConfig|'s [=fenced frame config/mapped url=]'s [=mapped url/value=] to
   the result of [=fencedframeutil/substituting macros=] with |sizeMacroMap| into |winningBid|'s
   [=generated bid/ad descriptor=]'s [=ad descriptor/url=].
1. If |adSize| is not null:
   1. Set |pendingConfig|'s [=fenced frame config/content size=] to a [=struct=] with the following
      [=struct/items=]:
     : [=content size/value=]
     :: |concreteAdSize|.

        Issue: Cast |concreteAdSize| into the format that is eventually chosen for
        [=content size/value=].
        (<a href="https://github.com/WICG/turtledove/issues/986">WICG/turtledove#986</a>)
     : [=content size/visibility=]
     :: "<a for=visibility>`opaque`</a>"
1. Set |pendingConfig|'s [=fenced frame config/interest group descriptor=]'s
   [=interest group descriptor/value=] to a [=struct=] with the following [=struct/items=]:
     : owner
     :: |winningBid|'s [=generated bid/interest group=]'s [=interest group/owner=]

     : name
     :: |winningBid|'s [=generated bid/interest group=]'s [=interest group/name=]
1. Let |fencedFrameReportingMap| be the [=map=] «[ "`buyer`" → «», "`seller`" → «» ]».
1. If |auctionConfig|'s [=auction config/component auctions=] is [=list/empty=], then [=map/set=]
  |fencedFrameReportingMap|["`component-seller`"] to an empty [=list=] «».
1. Set |pendingConfig|'s [=fenced frame config/fenced frame reporting metadata=] to a [=struct=]
   with the following [=struct/items=]:
    : [=fenced frame reporting metadata/value=]
    :: A [=struct=]  with the following [=struct/items=]:
       : [=fenced frame reporting metadata/fenced frame reporting map=]
       :: |fencedFrameReportingMap|

       : [=fenced frame reporting metadata/direct seller is seller=]
       :: true if |auctionConfig|'s [=auction config/component auctions=] is [=list/empty=], false
          otherwise

       : [=fenced frame reporting metadata/allowed reporting origins=]
       :: |winningBid|'s [=generated bid/bid ad=]'s [=interest group ad/allowed reporting origins=]

    : [=fenced frame reporting metadata/visibility=]
    :: "<a for=visibility>`opaque`</a>"
1. Set |pendingConfig|'s [=fenced frame config/on navigate callback=] to an algorithm with these
   steps:
   1. [=Asynchronously finish reporting=] with |pendingConfig|'s
      [=fenced frame config/fenced frame reporting metadata=]'s
      [=fenced frame reporting metadata/value=]'s
      [=fenced frame reporting metadata/fenced frame reporting map=], |auctionConfig|,
      |reportingContextMap|, |winningBidInfo|, |auctionReportInfo| and |settings|.
1. Let |adComponentDescriptorsWithReplacements| be a new [=list=] of [=ad descriptors=].
1. If |winningBid|'s [=generated bid/ad component descriptors=] is not null:
  1. [=list/For each=] |adComponentDescriptor| of |winningBid|'s
    [=generated bid/ad component descriptors=]:
    1. Let |descriptorWithReplacement| be a new [=ad descriptor=].
    1. Set |descriptorWithReplacement|'s [=ad descriptor/size=] to
      |adComponentDescriptor|'s [=ad descriptor/size=].
    1. Set |descriptorWithReplacement|'s [=ad descriptor/url=] to the result of running
      [=fencedframeutil/substitute macros=] with |replacements| and |adComponentDescriptor|'s
      [=ad descriptor/url=].
    1. [=list/Append=] |descriptorWithReplacement| to |adComponentDescriptorsWithReplacements|.
1. Set |pendingConfig|'s [=fenced frame config/nested configs=]'s [=nested configs/value=] to
   the result of running [=create nested configs=] with |adComponentDescriptorsWithReplacements|.
1. Return |pendingConfig|.

</div>

<div algorithm>

To <dfn>asynchronously finish reporting</dfn> given a
[=fencedframetype/fenced frame reporting map=] |reportingMap|, [=auction config=] |auctionConfig|,
[=reporting context map=] |reportingContextMap|, [=leading bid info=] |leadingBidInfo|,
[=auction report info=] |auctionReportInfo|, and an [=environment settings object=] |settings|:
1. [=Increment a winning bid's k-anonymity count=] given |leadingBidInfo|'s [=leading bid info/leading bid=].
1. If |leadingBidInfo|'s [=leading bid info/leading non-k-anon-enforced bid=] is
   not null, and |leadingBidInfo|'s [=leading bid info/leading non-k-anon-enforced bid=]'s
   [=generated bid/reporting id=] &ne; |leadingBidInfo|'s [=leading bid info/leading bid=]'s
   [=generated bid/reporting id=], [=increment a winning bid's k-anonymity count=] given
   |leadingBidInfo|'s [=leading bid info/leading non-k-anon-enforced bid=].
1. Let |buyerDone|, |sellerDone|, and |componentSellerDone| be [=booleans=], initially false.
1. If |leadingBidInfo|'s [=leading bid info/component seller=] is null, set |componentSellerDone|
   to true.
1. [=iteration/While=]:
   1. If |buyerDone|, |sellerDone|, and |componentSellerDone| are all true, then
      [=iteration/break=].
   1. Wait until one of the following fields of |leadingBidInfo| being not null:
      * [=leading bid info/buyer reporting result=];
      * [=leading bid info/seller reporting result=];
      * [=leading bid info/component seller reporting result=].
   1. If |buyerDone| is false and |leadingBidInfo|'s [=leading bid info/buyer reporting result=]
      is not null:
      1. Let |buyerMap| be |leadingBidInfo|'s [=leading bid info/buyer reporting result=]'s
         [=reporting result/reporting beacon map=].
      1. If |buyerMap| is null, set |buyerMap| to an empty [=map=] «[]».
      1. Let |macroMap| be |leadingBidInfo|'s [=leading bid info/buyer reporting result=]'s
         [=reporting result/reporting macro map=].
      1. [=Finalize a reporting destination=] with |reportingMap|,
         {{FenceReportingDestination/buyer}}, |buyerMap|, and |macroMap|.
      1. [=Send report=] with |leadingBidInfo|'s [=leading bid info/buyer reporting result=]'s
         [=reporting result/report url=] and |settings|.
      1. Set |buyerDone| to true.
   1. If |sellerDone| is false and |leadingBidInfo|'s [=leading bid info/seller reporting result=]
      is not null:
      1. Let |sellerMap| be |leadingBidInfo|'s [=leading bid info/seller reporting result=]'s
         [=reporting result/reporting beacon map=].
      1. If |sellerMap| is null, set |sellerMap| to an empty [=map=] «[]».
      1. [=Finalize a reporting destination=] with |reportingMap|,
         {{FenceReportingDestination/seller}}, and |sellerMap|.
      1. [=Send report=] with |leadingBidInfo|'s [=leading bid info/seller reporting result=]'s
         [=reporting result/report url=] and |settings|.
      1. Set |sellerDone| to true.
   1. If |componentSellerDone| is false and |leadingBidInfo|'s
      [=leading bid info/component seller reporting result=] is not null:
      1. Let |componentSellerMap| be |leadingBidInfo|'s
         [=leading bid info/component seller reporting result=]'s
         [=reporting result/reporting beacon map=].
      1. If |componentSellerMap| is null, set |componentSellerMap| to an empty [=map=] «[]».
      1. [=Finalize a reporting destination=] with |reportingMap|,
         {{FenceReportingDestination/component-seller}}, and |componentSellerMap|.
      1. [=Send report=] with |leadingBidInfo|'s [=leading bid info/component seller reporting result=]'s
         [=reporting result/report url=] and |settings|.
      1. Set |componentSellerDone| to true.
1. [=list/For each=] |reportUrl| of |auctionReportInfo|'s [=auction report info/debug win report urls=]:
  1. [=Send report=] with |report| and |settings|.
1. [=list/For each=] |reportUrl| of |auctionReportInfo|'s [=auction report info/debug loss report urls=]:
  1. [=Send report=] with |report| and |settings|.
1. [=Send real time reports=] with |auctionReportInfo|'s
  [=auction report info/real time reporting contributions map=] and |settings|.
1. [=Process the Private Aggregation contributions=] given |auctionConfig|, |reportingContextMap|.

</div>

<div algorithm>

To <dfn>create nested configs</dfn> given [=generated bid/ad component descriptors=]
|adComponentDescriptors|:
1. Let |nestedConfigs| be an empty [=list=] «».
1. If |adComponentDescriptors| is null:
  1. Return |nestedConfigs|.
1. [=set/For each=] |adComponentDescriptor| of |adComponentDescriptors|:
  1. Let |fencedFrameConfig| be a [=fenced frame config=] with the following [=struct/items=]:
    : [=fenced frame config/mapped url=]
    :: a [=struct=] with the following [=struct/items=]:
      : [=mapped url/value=]
      :: |adComponentDescriptor|'s [=ad descriptor/url=]

      : [=mapped url/visibility=]
      :: "<a for=visibility>`opaque`</a>"

    : [=fenced frame config/container size=]
    :: null

    : [=fenced frame config/content size=]
    :: If |adComponentDescriptor|'s [=ad descriptor/size=] is null, then null. Otherwise, a
       [=struct=] with the following [=struct/items=]:
       : [=content size/value=]
       :: |adComponentDescriptor|'s [=ad descriptor/size=] TODO: Resolve screen-relative sizes and
          macros and cast this properly.

       : [=content size/visibility=]
       :: "<a for=visibility>`opaque`</a>"

    : [=fenced frame config/interest group descriptor=]
    :: null

    : [=fenced frame config/on navigate callback=]
    :: null

    : [=fenced frame config/effective sandboxing flags=]
    :: a [=struct=] with the following [=struct/items=]:
      : [=effective sandboxing flags/value=]
      :: TODO: fill this in once fenced frame sandbox flags are more fully specified

      : [=effective sandboxing flags/visibility=]
      :: "<a for=visibility>`opaque`</a>"

    : [=fenced frame config/effective enabled permissions=]
    :: a [=struct=] with the following [=struct/items=]:
      : [=effective enabled permissions/value=]
      :: «"<code>{{PermissionPolicy/attribution-reporting}}</code>",
          "<code>[=private-aggregation=]</code>", "<code>[=shared-storage=]</code>",
          "<code>[=shared-storage-select-url=]</code>"»
      : [=effective enabled permissions/visibility=]
      :: "<a for=visibility>`opaque`</a>"

    : [=fenced frame config/fenced frame reporting metadata=]
    :: null

    : [=fenced frame config/exfiltration budget metadata=]
    :: null

    : [=fenced frame config/nested configs=]
    :: a [=struct=] with the following [=struct/items=]:
      : [=nested configs/value=]
      :: an empty [=list=] «»

      : [=nested configs/visibility=]
      :: "<a for=visibility>`opaque`</a>"

    : [=fenced frame config/embedder shared storage context=]
    :: null

  1. [=list/Append=] |fencedFrameConfig| to |nestedConfigs|.
1. Return |nestedConfigs|.

</div>

<div algorithm="validate and convert auction ad config">

To <dfn>validate and convert auction ad config</dfn> given an {{AuctionAdConfig}} |config| and a
[=boolean=] |isTopLevel|:
1. [=Assert=] that these steps are not running [=in parallel=].
1. Let |auctionConfig| be a new [=auction config=].
1. Let |seller| be the result of [=parsing an https origin=] with |config|["{{AuctionAdConfig/seller}}"].
1. If |seller| is failure, then return failure.
1. Set |auctionConfig|'s [=auction config/seller=] to |seller|.
1. If |config|["{{AuctionAdConfig/serverResponse}}"] [=map/exists=]:
  1. If |config|["{{AuctionAdConfig/requestId}}"] does not [=map/exist=], then [=exception/throw=] a
    {{TypeError}}.
  1. Let |resolvedAndTypeChecked| be the promise representing performing the following steps
    [=upon fulfillment=] of |config|["{{AuctionAdConfig/serverResponse}}"] with |result|:
    1. Set |auctionConfig|'s [=auction config/server response=] to the [=ArrayBuffer/transferred=]
      |result|.
    1. Set |auctionConfig|'s [=auction config/server response id=] to
      |config|["{{AuctionAdConfig/requestId}}"].
  1. [=Upon rejection=] of |resolvedAndTypeChecked|:
    1. Set |auctionConfig|'s [=auction config/server response=] to failure.

  Note: The JavaScript code calling {{Navigator/runAdAuction()}} is responsible for *not*
    resolving |config|["{{AuctionAdConfig/serverResponse}}"] until server responses have been
    retrieved from one or more [:Ad-Auction-Result:] and [:Ad-Auction-Result-Nonce:] headers,
    as resolving this Promise early would cause a race condition in which the
    [=script runners=] might run without the server responses that it needs. There
    are two ways that server responses can be retrieved.<br />
    (1) The JavaScript code issues a [=request=] whose [=request/initiator type=]
    is `"fetch"` and whose {{RequestInit/adAuctionHeaders}} option is set to `true`. The
    JavaScript code has to resolve |config|["{{AuctionAdConfig/serverResponse}}"] after the
    corresponding call to {{WindowOrWorkerGlobalScope/fetch()}} has resolved to a [=response=].
    The JavaScript code can also choose to wait to call {{Navigator/runAdAuction()}} until after
    the corresponding call to {{WindowOrWorkerGlobalScope/fetch()}} has resolved to a [=response=],
    and can then immediately resolve |config|["{{AuctionAdConfig/serverResponse}}"];<br />
    (2) issue an <a spec="html" lt="navigate an iframe or frame">iframe navigation</a>
    request with the <{iframe/adauctionheaders}> <a spec=html>content attribute</a> set to `true`.
    In this case, the JavaScript code is retrieved as part of the iframe navigation response,
    at which point the JavaScript code in the iframe makes the call to
    {{Navigator/runAdAuction()}}, and |config|["{{AuctionAdConfig/serverResponse}}"] can be
    specified directly without a Promise.

1. Otherwise:
  1. If |config|["{{AuctionAdConfig/requestId}}"] [=map/exists=], then [=exception/throw=]
    a {{TypeError}}.
  1. If |config|["{{AuctionAdConfig/decisionLogicURL}}"] does not [=map/exist=],
    then [=exception/throw=] a {{TypeError}}.
1. If |config|["{{AuctionAdConfig/decisionLogicURL}}"] [=map/exists=]:
  1. Let |decisionLogicURL| be the result of running the [=URL parser=] on
    |config|["{{AuctionAdConfig/decisionLogicURL}}"].
  1. If |decisionLogicURL| is failure, or it is not [=same origin=] with |auctionConfig|'s
    [=auction config/seller=], then return failure.
  1. Set |auctionConfig|'s [=auction config/decision logic url=] to |decisionLogicURL|.
1. If |config|["{{AuctionAdConfig/trustedScoringSignalsURL}}"] [=map/exists=]:
  1. Let |trustedScoringSignalsURL| be the result of [=parse and verify a trusted signals URL=] on
    |config|["{{AuctionAdConfig/trustedScoringSignalsURL}}"].
  1. If |trustedScoringSignalsURL| is failure, return failure.
  1. Set |auctionConfig|'s [=auction config/trusted scoring signals url=] to
    |trustedScoringSignalsURL|.
1. If |config|["{{AuctionAdConfig/maxTrustedScoringSignalsURLLength}}"] [=map/exists=]:
  1. If |config|["{{AuctionAdConfig/maxTrustedScoringSignalsURLLength}}"] &ge; 0, set |auctionConfig|'s
    [=auction config/max trusted scoring signals url length=] to
    |config|["{{AuctionAdConfig/maxTrustedScoringSignalsURLLength}}"], otherwise [=exception/throw=]
    a {{TypeError}}.
1. If |config|["{{AuctionAdConfig/trustedScoringSignalsCoordinator}}"] [=map/exists=]:
    1. Let |parsedCoordinator| be the result of [=parsing an https origin=] on
      |config|["{{AuctionAdConfig/trustedScoringSignalsCoordinator}}"].
    1. If |parsedCoordinator| is failure, then [=exception/throw=] a {{TypeError}}.
    1. Set |auctionConfig|'s [=auction config/trusted scoring signals coordinator=] to
      |parsedCoordinator|.
1. If |config|["{{AuctionAdConfig/sendCreativeScanningMetadata}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/send creative scanning metadata=] to
    |config|["{{AuctionAdConfig/sendCreativeScanningMetadata}}"].
1. If |config|["{{AuctionAdConfig/interestGroupBuyers}}"] [=map/exists=]:
  1. Let |buyers| be a new empty [=list=].
  1. [=list/For each=] |buyerString| in |config|["{{AuctionAdConfig/interestGroupBuyers}}"]:
    1. Let |buyer| be the result of [=parsing an https origin=] with |buyerString|.
    1. If |buyer| is failure, then return failure.
    1. [=list/Append=] |buyer| to |buyers|.
  1. Set |auctionConfig|'s [=auction config/interest group buyers=] to |buyers|.
1. If |config|["{{AuctionAdConfig/auctionSignals}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/auction signals=] to
    |config|["{{AuctionAdConfig/auctionSignals}}"].
  1. [=Handle an input promise in configuration=] given |auctionConfig| and |auctionConfig|'s
    [=auction config/auction signals=]:
    * To parse the value |result|:
      1. If |result| is {{undefined}} or null, set |auctionConfig|'s [=auction config/auction
        signals=] to null.
      1. Otherwise, set |auctionConfig|'s [=auction config/auction signals=] to the
        result of [=serializing a JavaScript value to a JSON string=] given |result|.
    * To handle an error, set |auctionConfig|'s [=auction config/auction signals=] to failure.
1. If |config|["{{AuctionAdConfig/requestedSize}}"] [=map/exists=]:
  1. Let |adSize| be the result from running [=parse an AdRender ad size=] with
    |config|["{{AuctionAdConfig/requestedSize}}"]
  1. If |adSize| is null, [=exception/throw=] a {{TypeError}}.
  1. Set |auctionConfig|'s [=auction config/requested size=] to |adSize|.
1. If |config|["{{AuctionAdConfig/allSlotsRequestedSizes}}"] [=map/exists=]:
  1. If |config|["{{AuctionAdConfig/allSlotsRequestedSizes}}"] is [=list/empty=],
    [=exception/throw=] a {{TypeError}}.
  1. Set |auctionConfig|'s [=auction config/all slots requested sizes=] to a new [=set=].
  1. [=list/For each=] |adSizeValue| in |config|["{{AuctionAdConfig/allSlotsRequestedSizes}}"]:
    1. Let |adSize| be the result of running [=parse an AdRender ad size=] with |adSizeValue|.
    1. If |adSize| is null, [=exception/throw=] a {{TypeError}}.
    1. If |auctionConfig|'s [=auction config/all slots requested sizes=] [=set/contains=] |adSize|,
      [=exception/throw=] a {{TypeError}}.
    1. [=set/Append=] |adSize| to |auctionConfig|'s [=auction config/all slots requested sizes=].
  1. If |auctionConfig|'s [=auction config/requested size=] is not null, and |auctionConfig|'s
    [=auction config/all slots requested sizes=] does not [=list/contain=] |auctionConfig|'s
    [=auction config/requested size=], [=exception/throw=] a {{TypeError}}.
1. If |config|["{{AuctionAdConfig/sellerSignals}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/seller signals=] to
    |config|["{{AuctionAdConfig/sellerSignals}}"].
  1. [=Handle an input promise in configuration=] given |auctionConfig| and |auctionConfig|'s
    [=auction config/seller signals=]:
    * To parse the value |result|:
      1. If |result| is {{undefined}} or null, set |auctionConfig|'s [=auction config/seller
        signals=] to null.
      1. Otherwise, set |auctionConfig|'s [=auction config/seller signals=] to the
        result of [=serializing a JavaScript value to a JSON string=], given |result|.
    * To handle an error, set |auctionConfig|'s [=auction config/seller signals=] to failure.
1. If |config|["{{AuctionAdConfig/auctionNonce}}"] [=map/exists=], then [=map/set=] |auctionConfig|'s
  [=auction config/auction nonce=] to the result of running [=get uuid from string=] with
  |config|["{{AuctionAdConfig/auctionNonce}}"].
1. If |config|["{{AuctionAdConfig/additionalBids}}"] [=map/exists=]:
  1. [=exception/Throw=] a {{TypeError}} if any of the following conditions hold:
    * |config|["{{AuctionAdConfig/auctionNonce}}"] does not [=map/exist=];
    * |config|["{{AuctionAdConfig/interestGroupBuyers}}"] does not [=map/exist=], or is [=list/empty=];
    * |config|["{{AuctionAdConfig/componentAuctions}}"] is not [=list/empty=].
  1. Set |auctionConfig|'s [=auction config/expects additional bids=] to true.
  1. [=Handle an input promise in configuration=] given |auctionConfig| and
    |config|["{{AuctionAdConfig/additionalBids}}"]:

    Note: The JavaScript code calling {{Navigator/runAdAuction()}} is responsible for *not*
      resolving |config|["{{AuctionAdConfig/additionalBids}}"] until additional bids have been
      retrieved from one or more [:Ad-Auction-Additional-Bid:] headers, as resolving this Promise
      early would cause a race condition in which additional bids might not be included in the
      auction. There are two ways that additional bids can be retrieved.<br />
      (1) The JavaScript code issues a [=request=] whose [=request/initiator type=] is `"fetch"` and whose
      {{RequestInit/adAuctionHeaders}} option is set to `true`. The JavaScript code has to resolve
      |config|["{{AuctionAdConfig/additionalBids}}"] after the corresponding call to
      {{WindowOrWorkerGlobalScope/fetch()}} has resolved to a [=response=].
      The JavaScript code can also choose to wait to call {{Navigator/runAdAuction()}} until after
      the corresponding call to {{WindowOrWorkerGlobalScope/fetch()}} has resolved to a response,
      and can then immediately resolve |config|["{{AuctionAdConfig/additionalBids}}"];<br />
      (2) issue an <a spec="html" lt="navigate an iframe or frame">iframe navigation</a>
      request with the <{iframe/adauctionheaders}> <a spec=html>content attribute</a> set to `true`.
      In this case, the JavaScript code is retrieved as part of the iframe navigation response,
      at which point the JavaScript code in the iframe makes the call to
      {{Navigator/runAdAuction()}}, and |config|["{{AuctionAdConfig/additionalBids}}"] can be
      immediately resolved.

    * To parse the value |result|:
      1. Set |auctionConfig|'s [=auction config/expects additional bids=] to false.
    * To handle an error:
      1. Set |auctionConfig|'s [=auction config/expects additional bids=] to failure.
1. If |config|["{{AuctionAdConfig/directFromSellerSignalsHeaderAdSlot}}"] [=map/exists=]:
  1. [=Handle an input promise in configuration=] given |auctionConfig| and
    |config|["{{AuctionAdConfig/directFromSellerSignalsHeaderAdSlot}}"]:

    Note: The JavaScript code calling {{Navigator/runAdAuction()}} is responsible for *not*
      resolving |config|["{{AuctionAdConfig/directFromSellerSignalsHeaderAdSlot}}"]
      until direct from seller signals have been retrieved from one or more [:Ad-Auction-Signals:]
      headers, as resolving this Promise early would cause a race condition in which the [=script runners=]
      might run without the direct from seller signals that it needs. There are two ways that
      direct from seller signals can be retrieved.<br />
      (1) The JavaScript code issues a [=request=] whose [=request/initiator type=] is `"fetch"` and whose
      {{RequestInit/adAuctionHeaders}} option is set to `true`. The JavaScript code has to resolve
      |config|["{{AuctionAdConfig/directFromSellerSignalsHeaderAdSlot}}"] after the corresponding
      call to {{WindowOrWorkerGlobalScope/fetch()}} has resolved to a [=response=]. The JavaScript
      code can also choose to wait to call {{Navigator/runAdAuction()}} until after the
      corresponding call to {{WindowOrWorkerGlobalScope/fetch()}} has resolved to a [=response=],
      and can then immediately resolve
      |config|["{{AuctionAdConfig/directFromSellerSignalsHeaderAdSlot}}"];<br />
      (2) issue an <a spec="html" lt="navigate an iframe or frame">iframe navigation</a>
      request with the <{iframe/adauctionheaders}> <a spec=html>content attribute</a> set to `true`.
      In this case, the JavaScript code is retrieved as part of the iframe navigation response,
      at which point the JavaScript code in the iframe makes the call to
      {{Navigator/runAdAuction()}}, and
      |config|["{{AuctionAdConfig/directFromSellerSignalsHeaderAdSlot}}"] can be specified
      directly without a Promise.

    * To parse the value |result|:
      1. Set |auctionConfig|'s [=auction config/direct from seller signals header ad slot=] to
        |result|.
    * To handle an error:
      1. Set |auctionConfig|'s [=auction config/direct from seller signals header ad slot=] to
        failure.
1. If |config|["{{AuctionAdConfig/deprecatedRenderURLReplacements}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/deprecated render url replacements=] to
    |config|["{{AuctionAdConfig/deprecatedRenderURLReplacements}}"].
  1. [=Handle an input promise in configuration=] given |auctionConfig| and |auctionConfig|'s
      [=auction config/deprecated render url replacements=]:
    * To parse the value |result|:
      1. Let |renderUrlReplacements| be a new empty [=list=] of [=ad keyword replacement=]s.
      1. If |result| is not null:
        1. [=list/For each=] |replacement| in |result|:
          1. If [=validate a url macro=] with |replacement|'s [=ad keyword replacement/match=]
            returns false, then [=exception/throw=] a {{TypeError}}.
          1. Otherwise, [=list/append=] |replacement| to |renderUrlReplacements|.
      1. Set |auctionConfig|'s [=auction config/deprecated render url replacements=] to
        |renderUrlReplacements|.
    * To handle an error, set |auctionConfig|'s
      [=auction config/deprecated render url replacements=] to failure.


1. If |config|["{{AuctionAdConfig/sellerTimeout}}"] [=map/exists=], set |auctionConfig|'s
  [=auction config/seller timeout=] to |config|["{{AuctionAdConfig/sellerTimeout}}"] in milliseconds
  or 500, whichever is smaller.
1. Let |reportingTimeout| be |config|["{{AuctionAdConfig/reportingTimeout}}"] if it [=map/exists=],
  50 otherwise.
1. Set |config|["{{AuctionAdConfig/reportingTimeout}}"] to |reportingTimeout| in milliseconds or
  5000, whichever is smaller.
1. If |config|["{{AuctionAdConfig/sellerExperimentGroupId}}"] [=map/exists=], then set
  |auctionConfig|'s [=auction config/seller experiment group id=] to
  |config|["{{AuctionAdConfig/sellerExperimentGroupId}}"].
1. If |config|["{{AuctionAdConfig/sellerCurrency}}"]  [=map/exists=]:
  1. If the result of [=checking whether a string is a valid currency tag=] on
    |config|["{{AuctionAdConfig/sellerCurrency}}"] is false, then return failure.
  1. Set |auctionConfig|'s [=auction config/seller currency=] to
    |config|["{{AuctionAdConfig/sellerCurrency}}"].
1. If |config|["{{AuctionAdConfig/perBuyerSignals}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/per buyer signals=] to
    |config|["{{AuctionAdConfig/perBuyerSignals}}"].
  1. [=Handle an input promise in configuration=] given |auctionConfig| and |auctionConfig|'s
    [=auction config/per buyer signals=]:
    * To parse the value |result|:
      1. If |result| is null:
        1. Set |auctionConfig|'s [=auction config/per buyer signals=] to null.
      1. Otherwise:
        1. Set |auctionConfig|'s [=auction config/per buyer signals=] to a new [=ordered map=] whose
          [=map/keys=] are [=origins=] and whose [=map/values=] are [=strings=].
        1. [=map/For each=] |key| → |value| of |result|:
          1. Let |buyer| be the result of [=parsing an https origin=] with |key|. If |buyer| is
            failure, throw a {{TypeError}}.
          1. Let |signalsString| be the result of [=serializing a JavaScript value to a JSON
            string=], given |value|.
          1. [=map/Set=] |auctionConfig|'s [=auction config/per buyer signals=][|buyer|] to
            |signalsString|.
    * To handle an error, set |auctionConfig|'s [=auction config/per buyer signals=] to failure.
1. For each |idlTimeoutMember|, |perBuyerTimeoutField|, |allBuyersTimeoutField| in the following table
  <table class="data">
    <thead><tr><th>IDL timeout member</th><th>Per buyer timeout field</th><th>All buyers timeout field</th></tr></thead>
    <tr>
      <td>"{{AuctionAdConfig/perBuyerTimeouts}}"</td>
      <td>[=auction config/per buyer timeouts=]</td>
      <td>[=auction config/all buyers timeout=]</td>
    </tr>
    <tr>
      <td>"{{AuctionAdConfig/perBuyerCumulativeTimeouts}}"</td>
      <td>[=auction config/per buyer cumulative timeouts=]</td>
      <td>[=auction config/all buyers cumulative timeout=]</td>
    </tr>
  </table>
  1. If |config| [=map/contains=] |idlTimeoutMember|:
    1. Set |auctionConfig|'s |perBuyerTimeoutField| to |config|[|idlTimeoutMember|].
    1. [=Handle an input promise in configuration=] given |auctionConfig| and |auctionConfig|'s
      |perBuyerTimeoutField|:
      * To parse the value |result|:
        1. If |result| is null:
          1. Set |auctionConfig|'s |perBuyerTimeoutField| to null.
        1. Otherwise:
          1. Set |auctionConfig|'s |perBuyerTimeoutField| to a new [=ordered map=] whose
            [=map/keys=] are [=origins=] and whose [=map/values=] are [=durations=] in milliseconds.
          1. [=map/For each=] |key| → |value| of |result|:
            1. If |perBuyerTimeoutField| is "{{AuctionAdConfig/perBuyerTimeouts}}", and
              |value| &gt; 500, then set |value| to 500.
            1. If |key| is "*", then set |auctionConfig|'s |allBuyersTimeoutField| to |value| in
              milliseconds, and [=iteration/continue=].
            1. Let |buyer| be the result of [=parsing an https origin=] with |key|. If |buyer| is
              failure, [=exception/throw=] a {{TypeError}}.
            1. [=map/Set=] |auctionConfig|'s |perBuyerTimeoutField|[|buyer|] to |value| in
              milliseconds.
      * To handle an error, set |auctionConfig|'s |perBuyerTimeoutField| to failure.
1. If |config|["{{AuctionAdConfig/perBuyerGroupLimits}}"] [=map/exists=], [=map/for each=]
  |key| → |value| of |config|["{{AuctionAdConfig/perBuyerGroupLimits}}"]:
  1. If |value| is 0, then return failure.
  1. If |key| is "*", then set |auctionConfig|'s [=auction config/all buyers group limit=]
    to |value|, and [=iteration/continue=].
  1. Let |buyer| be the result of [=parsing an https origin=] with |key|.
  1. If |buyer| is failure, then return failure.
  1. Set |auctionConfig|'s [=auction config/per buyer group limits=][|buyer|] to |value|.
1. If |config|["{{AuctionAdConfig/perBuyerExperimentGroupIds}}"] [=map/exists=], [=map/for each=]
  |key| → |value| of |config|["{{AuctionAdConfig/perBuyerExperimentGroupIds}}"]:
  1. If |key| is "*", then set |auctionConfig|'s
    [=auction config/all buyer experiment group id=] to |value|, and [=iteration/continue=].
  1. Let |buyer| the result of [=parsing an https origin=] with |key|.
  1. If |buyer| is failure, then return failure.
  1. Set |auctionConfig|'s [=auction config/per buyer experiment group ids=][|buyer|] to |value|.
1. If |config|["{{AuctionAdConfig/perBuyerMultiBidLimits}}"] [=map/exists=], [=map/for each=]
  |key| → |value| of |config|["{{AuctionAdConfig/perBuyerMultiBidLimits}}"]:
  1. If |key| is "*", then set |auctionConfig|'s
    [=auction config/all buyers multi-bid limit=] to |value|, and [=iteration/continue=].
  1. Let |buyer| the result of [=parsing an https origin=] with |key|.
  1. If |buyer| is failure, then return failure.
  1. Set |auctionConfig|'s [=auction config/per buyer multi-bid limits=][|buyer|] to |value|.
1. If |config|["{{AuctionAdConfig/perBuyerPrioritySignals}}"] [=map/exists=], [=map/for each=]
  |key| → |value| of |config|["{{AuctionAdConfig/perBuyerPrioritySignals}}"]:
  1. Let |signals| be an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=]
    are {{double}}.
  1. [=map/for each=] |k| → |v| of |value|:
    1. If |k| [=string/starts with=] "browserSignals.", [=exception/throw=] a {{TypeError}}.
    1. [=map/Set=] |signals|[|k|] to |v|.
  1. If |key| is "*", then set |auctionConfig|'s
    [=auction config/all buyers priority signals=] to |value|, and [=iteration/continue=].
  1. Let |buyer| be the result of [=parsing an https origin=] with |key|.
  1. If |buyer| is failure, then return failure.
  1. [=map/Set=] |auctionConfig|'s [=auction config/per buyer priority signals=][|buyer|] to
    |signals|.
1. If |config|["{{AuctionAdConfig/auctionReportBuyerKeys}}"] [=map/exists=]:
  1. Let |interestGroupBuyers| be |auctionConfig|'s [=auction config/interest group buyers=].
  1. If |interestGroupBuyers| is null, set |interestGroupBuyers| to a new [=list=].
  1. [=list/For each=] |index| of [=the exclusive range|the range=] 0 to |config|[
    "{{AuctionAdConfig/auctionReportBuyerKeys}}"]'s [=list/size=], exclusive:
    1. Let |key| be |config|["{{AuctionAdConfig/auctionReportBuyerKeys}}"][|index|].
    1. If |key| is not [=set/contained=] in [=the exclusive range|the range=] 0 to 2<sup>128</sup>,
      exclusive, [=exception/throw=] a {{TypeError}}.
    1. If |index| &ge; |interestGroupBuyers|' [=list/size=], [=iteration/continue=].

        Note: [=iteration/Continue=] is used (instead of [=iteration/break=]) to validate all given
        buyer keys.
    1. Let |origin| be |interestGroupBuyers|[|index|].
    1. [=map/Set=] |auctionConfig|'s [=auction config/auction report buyer keys=][|origin|]
      to |key|.

    Issue: Check behavior when an origin is repeated in {{AuctionAdConfig/interestGroupBuyers}}.
1. If |config|["{{AuctionAdConfig/auctionReportBuyers}}"] [=map/exists=]:
  1. [=map/For each=] |reportType| → |reportBuyerConfig| of |config|[
    "{{AuctionAdConfig/auctionReportBuyers}}"]:
    1. If « "`interestGroupCount`", "`bidCount`", "`totalGenerateBidLatency`",
      "`totalSignalsFetchLatency`" » does not [=list/contain=] |reportType|, [=iteration/continue=].

      Note: No error is thrown to allow forward compatibility if
          additional report types are added later.

      Issue: Should these strings be dash delimited?

    1. If |reportBuyerConfig|["{{AuctionReportBuyersConfig/bucket}}"] is not [=set/contained=] in
      [=the exclusive range|the range=] 0 to 2<sup>128</sup>, exclusive, [=exception/throw=] a
      {{TypeError}}.

      Issue: Consider validating the case where the bucket used (after summing) is too large.
      Currently, the implementation appears to overflow.
      (<a href="https://github.com/WICG/turtledove/issues/1040">WICG/turtledove#1040</a>)
    1. [=map/Set=] |auctionConfig|'s [=auction config/auction report
        buyers=][|reportType|] to |reportBuyerConfig|.

1. If |config|["{{AuctionAdConfig/auctionReportBuyerDebugModeConfig}}"] [=map/exists=]:
  1. Let |debugModeConfig| be |config|["{{AuctionAdConfig/auctionReportBuyerDebugModeConfig}}"].
  1. Let |enabled| be |debugModeConfig|["{{AuctionReportBuyerDebugModeConfig/enabled}}"].
  1. Let |debugKey| be |debugModeConfig|["{{AuctionReportBuyerDebugModeConfig/debugKey}}"].
  1. If |debugKey| is not null:
      1. If |debugKey| is not [=set/contained=] in [=the exclusive range|the
          range=] 0 to 2<sup>64</sup>, exclusive, [=exception/throw=] a
          {{TypeError}}.
      1. If |enabled| is false, [=exception/throw=] a {{TypeError}}.
  1. Set |auctionConfig|'s [=auction config/auction report buyer debug
      details=] to a new [=debug details=] with the items:
      : [=debug-details-enabled|enabled=]
      :: |enabled|
      : [=debug-details-key|key=]
      :: |debugKey|
1. If |config|["{{AuctionAdConfig/requiredSellerCapabilities}}"] [=map/exists=]:
  1. Let |sellerCapabilities| be a new [=set=] of [=seller capabilities=].
  1. [=list/For each=] |capabilityString| of
    |config|["{{AuctionAdConfig/requiredSellerCapabilities}}"]:
    1. If |capabilityString| is "`interest-group-counts`" or "`latency-stats`", then [=set/append=]
      |capabilityString| to |sellerCapabilities|.

      Note: For forward compatibility with new values, don't [=exception/throw=].

  1. Set |auctionConfig|'s [=auction config/required seller capabilities=] to |sellerCapabilities|.
1. If |config|["{{AuctionAdConfig/privateAggregationConfig}}"] [=map/exists=]:
  1. Let |aggregationCoordinator| be the result of [=obtaining the coordinator from a Private
    Aggregation config=] given |config|["{{AuctionAdConfig/privateAggregationConfig}}"].
  1. If |aggregationCoordinator| is a {{DOMException}}, return failure.
  1. Set |auctionConfig|'s [=auction config/seller Private Aggregation coordinator=] to
    |aggregationCoordinator|.
1. If |config|["{{AuctionAdConfig/perBuyerCurrencies}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/per buyer currencies=] to
    |config|["{{AuctionAdConfig/perBuyerCurrencies}}"]
  1. [=Handle an input promise in configuration=] given |auctionConfig| and |auctionConfig|'s
    [=auction config/per buyer currencies=]:
    * To parse the value |result|:
      1. If |result| is null:
        1. Set |auctionConfig|'s [=auction config/per buyer currencies=] to null.
      1. Otherwise:
        1. Set |auctionConfig|'s [=auction config/per buyer currencies=] to a new [=ordered map=]
          whose [=map/keys=] are [=origins=] and whose [=map/values=] are [=currency tags=].
        1. [=map/for each=] |key| → |value| of |result|:
          1. If the result of [=checking whether a string is a valid currency tag=] given |value| is
            false, [=exception/throw=] a {{TypeError}}.
          1. If |key| is "*", then set |auctionConfig|'s
            [=auction config/all buyers currency=] to |value|, and [=iteration/continue=].
          1. Let |buyer| be the result of [=parsing an https origin=] with |key|. If |buyer| is
            failure, [=exception/throw=] a {{TypeError}}.
          1. [=map/Set=] |auctionConfig|'s [=auction config/per buyer currencies=][|buyer|] to
            |value|.
    * To handle an error, set |auctionConfig|'s [=auction config/per buyer currencies=] to failure.
1. If |config|["{{AuctionAdConfig/sellerRealTimeReportingConfig}}"] [=map/exists=]:
  1. If |config|["{{AuctionAdConfig/sellerRealTimeReportingConfig}}"]["type"] is
    "`default-local-reporting`", then set |auctionConfig|'s
    [=auction config/seller real time reporting config=] to "`default-local-reporting`".
1. If |config|["{{AuctionAdConfig/perBuyerRealTimeReportingConfig}}"] [=map/exists=],
  [=map/For each=] |key| → |value| of |config|["{{AuctionAdConfig/perBuyerRealTimeReportingConfig}}"]:
  1. Let |buyer| the result of [=parsing an https origin=] with |key|.
  1. If |buyer| is failure, then return failure.
  1. If |value|["type"] is "`default-local-reporting`", then set |auctionConfig|'s
    [=auction config/per buyer real time reporting config=][|buyer|] to "`default-local-reporting`".
1. If |config|["{{AuctionAdConfig/componentAuctions}}"] is not [=list/empty=]:
  1. If |config|["{{AuctionAdConfig/interestGroupBuyers}}"] [=map/exists=] and is not [=list/empty=],
    then return failure.
  1. If |config|["{{AuctionAdConfig/deprecatedRenderURLReplacements}}"] [=map/exists=], then
    [=exception/throw=] a {{TypeError}}.
1. [=list/For each=] |component| in |config|["{{AuctionAdConfig/componentAuctions}}"]:
  1. If |isTopLevel| is false, then return failure.
  1. Let |componentAuction| be the result of running [=validate and convert auction ad config=] with
    |component| and false.
  1. If |componentAuction| is failure, then return failure.
  1. [=list/Append=] |componentAuction| to |auctionConfig|'s [=auction config/component auctions=].
1. Set |auctionConfig|'s [=auction config/config idl=] to |config|.
1. If |config|["{{AuctionAdConfig/resolveToConfig}}"] [=map/exists=]:
  1. Let |auctionConfig|'s [=auction config/resolve to config=] be
     |config|["{{AuctionAdConfig/resolveToConfig}}"].
  1. TODO: What should happen if this rejects?
  1. [=Upon fulfillment=] of |auctionConfig|'s [=auction config/resolve to config=] with
     |resolveToConfig|, set |auctionConfig|'s [=auction config/resolve to config=] to
     |resolveToConfig|.
1. Return |auctionConfig|.

</div>

<div algorithm>

  To <dfn>validate a url macro</dfn> given a [=string=] |macro|:
  1. Return true if any of the following conditions hold:
    * |macro| [=string/starts with=] "'${'" and [=string/ends with=] "'}'";
    * |macro| [=string/starts with=] "'%%'" and [=string/ends with=] "'%%'".
  1. Otherwise, return false.

</div>

<div algorithm>

  To <dfn>update bid count</dfn> given a [=list=] of [=interest group=]s |igs|:
  1. [=list/For each=] |ig| in |igs|:
    1. Let |loadedIg| be the [=interest group=] from the [=user agent=]'s [=interest group set=]
      whose [=interest group/owner=] is |ig|'s [=interest group/owner=] and whose
      [=interest group/name=] is |ig|'s [=interest group/name=], [=iteration/continue=] if none found.
    1. If the most recent entry in |loadedIg|'s [=interest group/bid counts=] corresponds to
      the current day in UTC, increment its count. If not, [=list/insert=] a new [=tuple=] of
      the time set to the current UTC day and a count of 1.
    1. [=list/Replace=] the [=interest group=] that has |loadedIg|'s [=interest group/owner=] and
      [=interest group/name=] in the [=user agent=]'s [=interest group set=] with |loadedIg|.

</div>

<div algorithm>

  To <dfn>update previous wins</dfn> given a [=generated bid=] |bid|:
  1. Let |ig| be |bid|'s [=generated bid/interest group=].
  1. Let |loadedIg| be the [=interest group=] from the [=user agent=]'s [=interest group set=]
    whose [=interest group/owner=] is |ig|'s [=interest group/owner=] and whose
    [=interest group/name=] is |ig|'s [=interest group/name=], return if none found.
  1. Let |win| be a new [=previous win=].
  1. Set |win|'s [=previous win/time=] to the [=current coarsened wall time=].
  1. Let |ad| be a new [=interest group ad=] with the following [=struct/items=]:
    : [=interest group ad/render url=]
    :: |bid|'s [=generated bid/bid ad=]'s [=interest group ad/render url=]
    : [=interest group ad/metadata=]
    :: |bid|'s [=generated bid/bid ad=]'s [=interest group ad/metadata=]
    : [=interest group ad/ad render ID=]
    :: |bid|'s [=generated bid/bid ad=]'s [=interest group ad/ad render ID=]
  1. Set |win|'s [=previous win/ad=] to |ad|.
  1. [=list/Append=] |win| to |loadedIg|'s [=interest group/previous wins=].
  1. [=list/Replace=] the [=interest group=] that has |loadedIg|'s [=interest group/owner=] and
    [=interest group/name=] in the [=user agent=]'s [=interest group set=] with |loadedIg|.

</div>

<div algorithm>

To <dfn>build bid generators map</dfn> given an [=auction config=] |auctionConfig|:
1. Let |bidGenerators| be a new [=ordered map=] whose [=map/keys=] are [=origins=] and whose
  [=map/values=] are [=per buyer bid generators=].
1. Let |negativeTargetInfo| be a new [=negative target info=].
1. [=list/For each=] |buyer| in |auctionConfig|'s [=auction config/interest group buyers=]:
  1. [=list/For each=] |ig| of the [=user agent=]'s [=interest group set=] whose
    [=interest group/owner=] is |buyer|:
    1. Let |igName| be |ig|'s [=interest group/name=].
    1. If |ig|'s [=interest group/additional bid key=] is not null:
      1. [=map/Set=] |negativeTargetInfo|[(|buyer|, |igName|)] to (|ig|'s
        [=interest group/joining origin=], |ig|'s [=interest group/additional bid key=]).
    1. [=iteration/Continue=] if any of the following conditions hold:
      * |ig|'s [=interest group/bidding url=] is null;
      * |ig|'s [=interest group/ads=] is null, or [=list/is empty=];
      * the result of running [=check if required seller capabilities are permitted=] with
        |auctionConfig| and |ig| is false.
    1. Let |signalsUrl| be |ig|'s [=interest group/trusted bidding signals url=].
    1. Let |slotSizeQueryParam| be the result of [=calculating the ad slot size query param=]
      given |ig| and |auctionConfig|.
    1. Let |joiningOrigin| be |ig|'s [=interest group/joining origin=].
    1. If |bidGenerators| does not [=map/contain=] |buyer|:
      1. Let |perBuyerGenerator| be a new [=per buyer bid generator=].
      1. Let |perSignalsUrlGenerator| be a new [=per signals url bid generator=].
      1. [=map/Set=] |perSignalsUrlGenerator|[|joiningOrigin|] to « |ig| ».
      1. [=map/Set=] |perSlotSizeQueryParam|[|slotSizeQueryParam|] to |perSignalsUrlGenerator|.
      1. [=map/Set=] |perBuyerGenerator|[|signalsUrl|] to |perSlotSizeQueryParam|.
      1. [=map/Set=] |bidGenerators|[|buyer|] to |perBuyerGenerator|.
      1. TODO: add a perBiddingScriptUrlGenerator layer that replaces the list of IGs with a map
        from biddingScriptUrl to a list of IGs.
    1. Otherwise:
      1. Let |perBuyerGenerator| be |bidGenerators|[|buyer|].
      1. If |perBuyerGenerator| does not [=map/contain=] |signalsUrl|:
        1. Let |perSignalsUrlGenerator| be a new [=per signals url bid generator=].
        1. [=map/Set=] |perSignalsUrlGenerator|[|joiningOrigin|] to « |ig| ».
        1. [=map/Set=] |perSlotSizeQueryParam|[|slotSizeQueryParam|] to |perSignalsUrlGenerator|.
        1. [=map/Set=] |perBuyerGenerator|[|signalsUrl|] to |perSlotSizeQueryParam|.
      1. Otherwise:
        1. Let |perSlotSizeQueryParam| be |perBuyerGenerator|[|signalsUrl|].
        1. If |perSlotSizeQueryParam| does not [=map/contain=] |slotSizeQueryParam|:
          1. Let |perSignalsUrlGenerator| be a new [=per signals url bid generator=].
          1. [=map/Set=] |perSignalsUrlGenerator|[|joiningOrigin|] to « |ig| ».
          1. [=map/Set=] |perSlotSizeQueryParam|[|slotSizeQueryParam|] to |perSignalsUrlGenerator|.
        1. Otherwise:
          1. Let |perSignalsUrlGenerator| be |perSlotSizeQueryParam|[|slotSizeQueryParam|].
          1. If |perSignalsUrlGenerator| does not [=map/contain=] |joiningOrigin|, then [=map/set=]
            |perSignalsUrlGenerator|[|joiningOrigin|] to « |ig| ».
          1. Otherwise, [=list/append=] |ig| to |perSignalsUrlGenerator|[|joiningOrigin|].
1. Return « |bidGenerators|, |negativeTargetInfo| ».

</div>

<div algorithm>

To <dfn>check if required seller capabilities are permitted</dfn> given an [=auction config=]
|auctionConfig| and an [=interest group=] |ig|:
  1. Let |seller| be |auctionConfig|'s [=auction config/seller=].
  1. Let |requiredSellerCapabilities| be |auctionConfig|'s
    [=auction config/required seller capabilities=].
  1. Return true if all of the following conditions hold:
    * |ig|'s [=interest group/seller capabilities=] is not null;
    * |ig|'s [=interest group/seller capabilities=][|seller|] [=map/exists=];
    * |requiredSellerCapabilities| is a [=set/subset=] of |ig|'s
      [=interest group/seller capabilities=][|seller|].
  1. Return false.
</div>

<div algorithm>
To <dfn>obtain the coordinator from a Private Aggregation config</dfn> given a
{{ProtectedAudiencePrivateAggregationConfig}} |config|, perform the following
steps. They return an [=aggregation coordinator=], null or a {{DOMException}}.

1. If |config|["{{ProtectedAudiencePrivateAggregationConfig/aggregationCoordinatorOrigin}}"]
    does not [=map/exist=], return null.
1. Return the result of [=obtaining the Private Aggregation coordinator=] given
    |config|["{{ProtectedAudiencePrivateAggregationConfig/aggregationCoordinatorOrigin}}"].

</div>

<div algorithm="generate potentially multiple bids">

To <dfn>generate potentially multiple bids</dfn> given an [=ordered map=]-or-null
|allTrustedBiddingSignals|, and an [=origin=]-or-null |crossOriginTrustedBiddingSignalsOrigin|,
a [=string=] |auctionSignals|, a {{BiddingBrowserSignals}} |browserSignals|, a [=string=]-or-null |perBuyerSignals|,
a {{DirectFromSellerSignalsForBuyer}} |directFromSellerSignalsForBuyer|, a [=duration=]
|perBuyerTimeout| in milliseconds, a [=currency tag=] |expectedCurrency|, an {{unsigned short}}
|multiBidLimit|, an [=interest group=] |ig|, a [=reporting context=] |reportingContext|, a
[=moment=] |auctionStartTime|, and an [=environment settings object=] |settings|, perform the
following steps. They return a failure if failing to fetch the script or wasm, otherwise a
[=tuple=] of ([=list=] of [=generated bids=], [=bid debug reporting info=],
[=list=] of [=real time reporting contributions=], [=Private Aggregation contributions=],
[=execution metrics=]).
  1. Let |igGenerateBid| be the result of [=building an interest group passed to generateBid=] with
    |ig|.
  1. Set |browserSignals|["{{BiddingBrowserSignals/joinCount}}"] to the sum of |ig|'s
     [=interest group/join counts=] for all days within the last 30 days.
  1. Set |browserSignals|["{{BiddingBrowserSignals/recency}}"] to the [=current coarsened wall
    time=] minus |ig|'s [=interest group/join time=], in milliseconds.
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/bidCount}}"] to the sum of |ig|'s
     [=interest group/bid counts=] for all days within the last 30 days.
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/adComponentsLimit}}"] to 40.
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/multiBidLimit}}"] to |multiBidLimit|.
  1. Let |prevWins| be a new <code>[=sequence=]<{{PreviousWin}}></code>.
  1. [=list/For each=] |prevWin| of |ig|'s [=interest group/previous wins=] for all days within the
    the last 30 days:
    1. Let |timeDelta| be |auctionStartTime| minus |prevWin|'s [=previous win/time=].
    1. Set |timeDelta| to 0 if |timeDelta| is negative, |timeDelta|'s nearest second (rounding down)
      otherwise.
    1. Let |prevWinAdIDL| be a new {{AuctionAd}} with the following [=struct/items=]:
      : {{AuctionAd/renderURL}}
      :: the [=URL serializer|serialization=] of |prevWin|'s [=interest group ad/render url=]
      : {{AuctionAd/metadata}}
      :: |prevWin|'s [=interest group ad/metadata=]
      : {{AuctionAd/adRenderId}}
      :: |prevWin|'s [=interest group ad/ad render ID=]
    1. Let |prevWinElement| be the <code>[=sequence=]<{{PreviousWinElement}}></code> «|timeDelta|, |prevWinAdIDL|».
    1. [=list/Append=] |prevWinElement| to |prevWins|.
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/prevWinsMs}}"] to |prevWins|.
  1. Let |metrics| be a new [=execution metrics=].
  1. Let |biddingScriptFetcher| be the result of [=creating a new script fetcher=] with
    |ig|'s [=interest group/bidding url=], and |settings|.
  1. Let |biddingScript| be the result of [=waiting for script body from a fetcher=] given
     |biddingScriptFetcher|.
  1. [=Add a sample to an averager=] given |metrics|'s [=execution metrics/code fetch time
    averager=] and |biddingScriptFetcher|'s [=script fetcher/fetch duration=].
  1. If |biddingScript| is failure, return failure.
  1. If |ig|'s [=interest group/bidding wasm helper url=] is not null:
    1. Let |wasmFetchStart| be |settings|'s [=environment settings object/current monotonic time=].
    1. Let |wasmModuleObject| be the result of [=fetching WebAssembly=] with |ig|'s
      [=interest group/bidding wasm helper url=] and |settings|.
    1. Let |wasmFetchDuration| be the [=duration from=] |wasmFetchStart| to
      |settings|'s [=environment settings object/current monotonic time=], in milliseconds.
    1. [=Add a sample to an averager=] given |metrics|'s [=execution metrics/code fetch time
      averager=] and |wasmFetchDuration|.
    1. If |wasmModuleObject| is not failure, then [=map/set=]
      |browserSignals|["{{BiddingBrowserSignals/wasmHelper}}"] to |wasmModuleObject|.
    1. Otherwise, return failure.
  1. Let |trustedBiddingSignals| be null.
  1. If |allTrustedBiddingSignals| is not null:
    1. [=Assert=] that |ig|'s [=interest group/trusted bidding signals keys=] is not null.
    1. Set |trustedBiddingSignals| to an [=ordered map=] whose [=map/keys=] are [=strings=] and
      whose [=map/values=] are {{any}}.
    1. [=list/For each=] |key| of |ig|'s [=interest group/trusted bidding signals keys=]:
      1. If |allTrustedBiddingSignals|[|key|] [=map/exists=], then [=map/set=]
        |trustedBiddingSignals|[|key|] to |allTrustedBiddingSignals|[|key|].
  1. Let |sameOriginTrustedBiddingSignals| be null.
  1. Let |crossOriginTrustedBiddingSignals| be null.
  1. If |trustedBiddingSignals| is not null:
    1. If |crossOriginTrustedBiddingSignalsOrigin| is null, then set
      |sameOriginTrustedBiddingSignals| to |trustedBiddingSignals|.
    1. Otherwise:
      1. Set |crossOriginTrustedBiddingSignals| to a new [=ordered map=] whose [=map/keys=] are
          [=strings=] and whose [=map/values=] are {{any}}.
      1. Let |originKey| be the [=serialization of an origin|serialization=] of
          |crossOriginTrustedBiddingSignalsOrigin|.
      1. [=map/Set=] |crossOriginTrustedBiddingSignalsOrigin|[|originKey|] to |trustedBiddingSignals|.
  1. Return the result of [=evaluating a bidding script=] with |biddingScript|, |multiBidLimit|,
    |ig|, |reportingContext|, |metrics|, |expectedCurrency|, |igGenerateBid|, |auctionSignals|,
    |perBuyerSignals|, |sameOriginTrustedBiddingSignals|, |crossOriginTrustedBiddingSignals|,
    |browserSignals|, |directFromSellerSignalsForBuyer| and |perBuyerTimeout|.
</div>

<div algorithm="generate and score bids">

To <dfn>generate and score bids</dfn> given an [=auction config=] |auctionConfig|, an
[=auction config=]-or-null |topLevelAuctionConfig|, a [=global object=] |global|, a [=list=] of
[=interest groups=] |bidIgs|, a [=reporting context map=] |reportingContextMap|,
and a [=real time reporting contributions map=] |realTimeContributionsMap|:
1. [=Assert=] that these steps are running [=in parallel=].
1. Let |settings| be |global|'s [=relevant settings object=].
1. Let |policyContainer| be |settings|'s [=environment settings object/policy container=].
1. Let |topLevelOrigin| be |settings|'s [=environment/top-level origin=].
1. Let |seller| be |auctionConfig|'s [=auction config/seller=].
1. Let |auctionStartTime| be the [=current coarsened wall time=].
1. Let |decisionLogicFetcher| be the result of [=creating a new script fetcher=] with
  |auctionConfig|'s [=auction config/decision logic url=] and |settings|.
1. Let |trustedScoringSignalsBatcher| be the result of [=creating a trusted scoring signals
  batcher=] with |auctionConfig|'s [=auction config/max trusted scoring signals url length=].
1. Let « |bidGenerators|, |negativeTargetInfo| » be the result of running
  [=build bid generators map=] with |auctionConfig|.
1. If |auctionConfig|'s [=auction config/aborted=] is true, return failure.
1. Let |leadingBidInfo| be a new [=leading bid info=].
1. Let |queue| be the result of [=starting a new parallel queue=].
1. Let |capturedAuctionSignalsHeaders| be |global|'s [=associated Document's=] [=node navigable's=]
  [=traversable navigable's=] [=traversable navigable/captured ad auction signals headers=].
1. If |auctionConfig|'s [=auction config/component auctions=] are not [=list/is empty|empty=]:
  1. [=Assert=] |topLevelAuctionConfig| is null.
  1. Let |pendingComponentAuctions| be |auctionConfig|'s [=auction config/component auctions=]'s
    [=list/size=].
  1. Let |topLevelDirectFromSellerSignalsForSeller| be null.
  1. Let |topLevelDirectFromSellerSignalsRetrieved| be false.
  1. [=list/For each=] |component| in |auctionConfig|'s [=auction config/component auctions=],
    [=parallel queue/enqueue steps|enqueue the following steps=] to |queue|:
    1. If |component|'s [=auction config/server response=] is not null:
      1. Let |compWinnerInfo| be the result of running [=parse and validate server response=] with
         |component|, |auctionConfig|, |global|, |bidIgs|, and |reportingContextMap|.
    1. Otherwise:
      1. Let |compWinnerInfo| be the result of running [=generate and score bids=] with |component|,
        |auctionConfig|, |global|, |bidIgs|, |reportingContextMap|, and |realTimeContributionsMap|.
    1. If [=recursively wait until configuration input promises resolve=] given |auctionConfig|
      does not return failure, and |compWinnerInfo| is not failure, then:
      1. If |topLevelDirectFromSellerSignalsRetrieved| is false:
        1. Let |topLevelDirectFromSellerSignals| be the result of running
          [=get direct from seller signals=] given |seller|, |auctionConfig|'s
          [=auction config/direct from seller signals header ad slot=], and |capturedAuctionSignalsHeaders|.
        1. Set |topLevelDirectFromSellerSignalsForSeller| to the result of running
          [=get direct from seller signals for a seller=] given |topLevelDirectFromSellerSignals|.
        1. Set |topLevelDirectFromSellerSignalsRetrieved| to true.
      1. If |compWinnerInfo|'s [=leading bid info/leading bid=] is not null, then run
        [=score and rank a bid=] with |auctionConfig|, |reportingContextMap|[|auctionConfig|],
        |compWinnerInfo|'s [=leading bid info/leading bid=], |leadingBidInfo|,
        |decisionLogicFetcher|, |trustedScoringSignalsBatcher|, null, "top-level-auction", null,
        |topLevelOrigin|, |realTimeContributionsMap|, and |policyContainer|.
      1. If |compWinnerInfo|'s [=leading bid info/leading non-k-anon-enforced bid=]
        is not null, then run [=score and rank a bid=] with |auctionConfig|, |reportingContextMap|[
        |auctionConfig|], |compWinnerInfo|'s [=leading bid info/leading non-k-anon-enforced bid=],
        |leadingBidInfo|, |decisionLogicFetcher|, |trustedScoringSignalsBatcher|,
        |topLevelDirectFromSellerSignalsForSeller|, null, "top-level-auction", null, |topLevelOrigin|,
        |realTimeContributionsMap|, and |policyContainer|.
    1. Decrement |pendingComponentAuctions| by 1.
  1. Wait until |pendingComponentAuctions| is 0.
  1. If |auctionConfig|'s [=auction config/aborted=] is true, return failure.
  1. Set |reportingContextMap|[|auctionConfig|]'s [=reporting context/local leader info=] to
    a copy of |leadingBidInfo|.
  1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is null, return null.
  1. Let |winningComponentConfig| be |leadingBidInfo|'s [=leading bid info/auction config=].
  1. Set |leadingBidInfo|'s [=leading bid info/auction config=] to |auctionConfig|.
  1. Set |leadingBidInfo|'s [=leading bid info/component seller=] to |winningComponentConfig|'s
    [=auction config/seller=].
  1. Let « |topLevelSellerSignals|, unusedTopLevelReportResultBrowserSignals » be the result of
    running [=report result=] with |leadingBidInfo|, |reportingContextMap|[|auctionConfig|],
    |topLevelDirectFromSellerSignalsForSeller|, |winningComponentConfig|, and |global|.
  1. Set |leadingBidInfo|'s [=leading bid info/auction config=] to |winningComponentConfig|.
  1. Set |leadingBidInfo|'s [=leading bid info/component seller=] to null.
  1. Set |leadingBidInfo|'s [=leading bid info/top level seller=] to |seller|.
  1. Set |leadingBidInfo|'s [=leading bid info/top level seller signals=] to
    |topLevelSellerSignals|.
  1. Let |directFromSellerSignals| be the result of running [=get direct from seller signals=] given
    |winningComponentConfig|'s [=auction config/seller=], |winningComponentConfig|'s
    [=auction config/direct from seller signals header ad slot=], and |capturedAuctionSignalsHeaders|.
  1. Let |directFromSellerSignalsForSeller| be the result of running
    [=get direct from seller signals for a seller=] given |directFromSellerSignals|.
  1. Let |directFromSellerSignalsForBuyer| be the result of running
    [=get direct from seller signals for a buyer=] with |directFromSellerSignals|, and
    |leadingBidInfo|'s [=leading bid info/leading bid=]'s [=generated bid/interest group=]'s
    [=interest group/owner=].
  1. Let « |sellerSignals|, |reportResultBrowserSignals| » be the result of running
    [=report result=] with |leadingBidInfo|, |reportingContextMap|[|winningComponentConfig|],
    |directFromSellerSignalsForSeller|, null, and |global|.
  1. Run [=report win=] with |leadingBidInfo|, |reportingContextMap|[|winningComponentConfig|],
    |sellerSignals|, |reportResultBrowserSignals|, |directFromSellerSignalsForBuyer|,
    and |settings|.
  1. Set |reportingContextMap|[|auctionConfig|]'s [=reporting context/winner reporting id=] to
    |leadingBidInfo|'s [=leading bid info/leading bid=]'s [=generated bid/reporting id=].
  1. Set |reportingContextMap|[|winningComponentConfig|]'s [=reporting context/winner reporting id=]
    to |leadingBidInfo|'s  [=leading bid info/leading bid=]'s [=generated bid/reporting id=].
  1. Return |leadingBidInfo|.

1. If [=waiting until configuration input promises resolve=] given |auctionConfig| returns failure,
  then return failure.
1. Let |allBuyersExperimentGroupId| be |auctionConfig|'s
  [=auction config/all buyer experiment group id=].
1. Let |allBuyersGroupLimit| be |auctionConfig|'s [=auction config/all buyers group limit=].
1. Let |auctionSignals| be |auctionConfig|'s [=auction config/auction signals=].
1. Let |directFromSellerSignals| be the result of running [=get direct from seller signals=] given
  |seller|, |auctionConfig|'s [=auction config/direct from seller signals header ad slot=], and
  |capturedAuctionSignalsHeaders|.
1. Let |directFromSellerSignalsForSeller| be the result of running
  [=get direct from seller signals for a seller=] given |directFromSellerSignals|.
1. Let |browserSignals| be a {{BiddingBrowserSignals}}.
1. Let |topLevelHost| be the result of running the <a spec=url>host serializer</a> on
  |topLevelOrigin|'s [=origin/host=].
1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/topWindowHostname}}"] to |topLevelHost|.
1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/seller}}"] to the [=serialization of an
  origin|serialization=] of |seller|.
1. If |auctionConfig|'s [=auction config/requested size=] is not null, [=map/set=]
   |browserSignals|["{{BiddingBrowserSignals/requestedSize}}"] to the result of running
   [=convert an ad size to a map=] with |auctionConfig|'s [=auction config/requested size=].
1. Let |auctionLevel| be "single-level-auction".
1. Let |reportingContext| be |reportingContextMap|[|auctionConfig|].
1. Let |componentAuctionExpectedCurrency| be null.
1. If |topLevelAuctionConfig| is not null:
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/topLevelSeller}}"]] to the
    [=serialization of an origin|serialization=] of |topLevelAuctionConfig|'s
    [=auction config/seller=].
  1. Set |auctionLevel| to "component-auction".
  1. Set |componentAuctionExpectedCurrency| to the result of [=looking up per-buyer currency=] with
    |topLevelAuctionConfig| and |seller|.
1. Let |pendingBuyers| be |bidGenerators|'s [=map/size=].
1. Let |additionalBids| be the result of running [=validate and convert additional bids=] with
  |auctionConfig|, |topLevelAuctionConfig|, |negativeTargetInfo|, |reportingContextMap| and |global|.
1. Let |pendingAdditionalBids| be the [=list/size=] of |additionalBids|.
1. [=list/For each=] |additionalBid| of |additionalBids|, run the following steps [=in parallel=]:
  1. [=Score and rank a bid=] with |auctionConfig|, |reportingContext|
    |additionalBid|'s [=decoded additional bid/bid=], |leadingBidInfo|, |decisionLogicFetcher|,
    |trustedScoringSignalsBatcher|, |directFromSellerSignalsForSeller|, null, |auctionLevel|,
    |componentAuctionExpectedCurrency|, |topLevelOrigin|, |realTimeContributionsMap|, and
    |policyContainer|.
  1. Decrement |pendingAdditionalBids| by 1.
1. [=map/For each=] |buyer| → |perBuyerGenerator| of |bidGenerators|,
  [=parallel queue/enqueue steps|enqueue the following steps=] to |queue|:
  1. Let |cumulativeTimeoutTracker| be the result of [=creating a cumulative timeout tracker=] given
    |auctionConfig| and |buyer|.
  1. Let |buyerExperimentGroupId| be |allBuyersExperimentGroupId|.
  1. Let |perBuyerExperimentGroupIds| be |auctionConfig|'s
    [=auction config/per buyer experiment group ids=].
  1. If |perBuyerExperimentGroupIds| is not null and |perBuyerExperimentGroupIds|[|buyer|]
    [=map/exists=], then set |buyerExperimentGroupId| to |perBuyerExperimentGroupIds|[|buyer|].
  1. Let |metrics| be the result of [=accessing per-participant metrics=] for |reportingContext|,
    |buyer|, [=worklet function/generate-bid=].
  1. <dfn>Apply interest groups limits to prioritized list</dfn>:
    1. Let |buyerGroupLimit| be |allBuyersGroupLimit|.
    1. Let |perBuyerGroupLimits| be |auctionConfig|'s
      [=auction config/per buyer group limits=].
    1. If |perBuyerGroupLimits| is not null and |perBuyerGroupLimits|[|buyer|] [=map/exists=], then
      set |buyerGroupLimit| to |perBuyerGroupLimits|[|buyer|].
    1. Let |igs| be a new [=list=] of [=interest groups=].
    1. [=map/For each=] signalsUrl → |perSlotSizeQueryParam| of |perBuyerGenerator|:
      1. [=map/For each=] slotSizeQueryParam → |perSignalsUrlGenerator| of |perSlotSizeQueryParam|:
        1. [=map/For each=] joiningOrigin → |groups| of |perSignalsUrlGenerator|:
          1. [=list/Extend=] |igs| with |groups|.
    1. [=Update storage metrics=] given |metrics| and |igs|.

      Note: This is done before any filtering, since it represents storage resource usage.

    1. [=list/Sort in descending order=] |igs|, with |a| being less than |b| if |a|'s
      [=interest group/priority=] is less than |b|'s [=interest group/priority=].
    1. [=list/Remove=] the first |buyerGroupLimit| items from |igs|.
    1. [=map/For each=] signalsUrl → |perSlotSizeQueryParam| of |perBuyerGenerator|:
      1. [=map/For each=] slotSizeQueryParam → |perSignalsUrlGenerator| of |perSlotSizeQueryParam|:
        1. [=map/For each=] joiningOrigin → |groups| of |perSignalsUrlGenerator|:
          1. [=list/Remove=] from |groups| any [=interest group=] [=list/contained=] in |igs|.
          1. Increment |metrics|'s [=per participant metrics/participating interest group count=]
            by [=list/size=] of |groups|.
  1. Let |perBuyerSignals| be null.
  1. If |auctionConfig|'s [=auction config/per buyer signals=] is not null and
    [=auction config/per buyer signals=][|buyer|] [=map/exists=], then set |perBuyerSignals| to
    |auctionConfig|'s [=auction config/per buyer signals=][|buyer|].
  1. Let |perBuyerTimeout| be |auctionConfig|'s [=auction config/all buyers timeout=].
  1. If |auctionConfig|'s [=auction config/per buyer timeouts=] is not null and
    [=auction config/per buyer timeouts=][|buyer|] [=map/exists=], then set |perBuyerTimeout| to
    |auctionConfig|'s [=auction config/per buyer timeouts=][|buyer|].
  1. Let |expectedCurrency| be the result of [=looking up per-buyer currency=] with |auctionConfig|
    and |buyer|.
  1. Let |multiBidLimit| be the result of [=looking up per-buyer multi-bid limit=] with |auctionConfig| and |buyer|.
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/forDebuggingOnlyInCooldownOrLockout}}"]
    to the result of running [=is debugging only in cooldown or lockout=] with |buyer|.
  1. Let |optedInForRealTimeReporting| be true if |auctionConfig|'s
    [=auction config/per buyer real time reporting config=][|buyer|] is "`default-local-reporting`",
    false otherwise.
  1. [=map/For each=] |slotSizeQueryParam| → |perSlotSizeQueryParam| of |perBuyerGenerator|:
    1. [=map/For each=] |signalsUrl| → |perSignalsUrlGenerator| of |perSlotSizeQueryParam|:
      1. Let |crossOriginTrustedBiddingSignalsOrigin| be null.
      1. If |buyer| is not [=same origin=] with |signalsUrl|'s [=url/origin=], then set
        |crossOriginTrustedBiddingSignalsOrigin| to |signalsUrl|'s [=url/origin=].
      1. Let |trustedBiddingSignalsBatcher| be a new [=trusted bidding signals batcher=].
      1. Let |fetchSignalStartTime| be |settings|'s [=environment settings object/current monotonic time=].
      1. [=map/For each=] joiningOrigin → |groups| of |perSignalsUrlGenerator|:
        1. [=list/For each=] |ig| of |groups|:
          1. [=Batch or fetch trusted bidding signals=] given |trustedBiddingSignalsBatcher|,
            |ig|, |signalsUrl|, |buyerExperimentGroupId|, |topLevelOrigin|, |slotSizeQueryParam|,
            and |policyContainer|.
        1. [=Fetch the current outstanding trusted signals batch=] given |trustedBiddingSignalsBatcher|,
            |signalsUrl|, |buyer|, |buyerExperimentGroupId|, |topLevelOrigin|, and |slotSizeQueryParam|.
        1. [=Fetch the trusted key value signals batch=] given |trustedBiddingSignalsBatcher|,
            |signalsUrl|, |buyer|, |buyerExperimentGroupId|, |topLevelOrigin|, and |slotSizeQueryParam|.
      1. [=Process updateIfOlderThanMs=] with |buyer|, and |trustedBiddingSignalsBatcher|'s
         [=trusted bidding signals batcher/all per interest group data=].
      1. Let |fetchSignalDuration| be the [=duration from=] |fetchSignalStartTime| to |settings|'s
        [=environment settings object/current monotonic time=], in milliseconds.
      1. [=Expend cumulative timeout time=] given |cumulativeTimeoutTracker| and
        |fetchSignalDuration|.
      1. [=map/For each=] joiningOrigin → |groups| of |perSignalsUrlGenerator|:
        1. [=list/For each=] |ig| of |groups|:
          1. If |cumulativeTimeoutTracker| [=cumulative timeout tracker/is expired=] then
            increment |metrics|'s [=per participant metrics/cumulative timeouts occurred=] by 1 and
            [=iteration/continue=].
          1. If |ig|'s [=interest group/bidding url=] is null, [=iteration/continue=].
          1. Let |effectiveBuyerTimeout| be the result of [=computing effective timeout=] given
            |cumulativeTimeoutTracker| and |perBuyerTimeout|.
          1. Let |generateBidStartTime| be |settings|'s
            [=environment settings object/current monotonic time=].
          1. Let |directFromSellerSignalsForBuyer| be the result of running
            [=get direct from seller signals for a buyer=] with |directFromSellerSignals|, and |ig|'s
            [=interest group/owner=].
          1. Let |dataVersion| be null.
          1. Let |allTrustedBiddingSignals| be an [=ordered map=]-or-null, initially null.
          1. Let |igName| be |ig|'s [=interest group/name=].
          1. If |trustedBiddingSignalsBatcher|'s
            [=trusted bidding signals batcher/no signals flags=][|igName|] does not [=map/exist=]:
            1. Set |dataVersion| to |trustedBiddingSignalsBatcher|'s
              [=trusted bidding signals batcher/data versions=][|igName|].
            1. Set |allTrustedBiddingSignals| to [=trusted bidding signals batcher/all trusted bidding signals=].
          1. Otherwise if |trustedBiddingSignalsBatcher|'s
            [=trusted bidding signals batcher/no signals flags=][|igName|] is "fetch-failed", and
            |optedInForRealTimeReporting| is true, then:
            1. [=Add a platform contribution=] with [=trusted bidding signals failure bucket=],
              |realTimeContributionsMap|, and |igName|.
          1. [=map/Remove=] |browserSignals|["{{BiddingBrowserSignals/dataVersion}}"].
          1. [=map/Remove=] |browserSignals|["{{BiddingBrowserSignals/crossOriginDataVersion}}"].
          1. If |dataVersion| is not null:
            1. If |crossOriginTrustedBiddingSignalsOrigin| is not null, then [=map/set=]
               |browserSignals|["{{BiddingBrowserSignals/crossOriginDataVersion}}"] to |dataVersion|.
            1. Otherwise, [=map/set=] |browserSignals|["{{BiddingBrowserSignals/dataVersion}}"] to
               |dataVersion|.
          1. Let |generateBidResult| be the result of [=generate potentially multiple bids=] given
            |allTrustedBiddingSignals|, |crossOriginTrustedBiddingSignalsOrigin|, |auctionSignals|,
            a [=map/clone=] of |browserSignals|, |perBuyerSignals|,
            |directFromSellerSignalsForBuyer|, |effectiveBuyerTimeout|, |expectedCurrency|,
            |multiBidLimit|, |ig|, |reportingContext|, |auctionStartTime|, and |settings|.
          1. If |generateBidResult| is failure, then:
            1. If |optedInForRealTimeReporting| is true, then [=add a platform contribution=] with
              [=bidding script failure bucket=], |realTimeContributionsMap| and |buyer|.
            1. [=iteration/Continue=].
          1. Let (|bidsBatch|, |bidDebugReportInfo|, |realTimeContributions|, |paContributions|,
                  |executionMetrics|) be |generateBidResult|.
          1. Let |generateBidDuration| be the [=duration from=] |generateBidStartTime| to |settings|'s
            [=environment settings object/current monotonic time=], in milliseconds.
          1. [=Expend cumulative timeout time=] given |cumulativeTimeoutTracker| and
            |generateBidDuration|.
          1. If |cumulativeTimeoutTracker| [=cumulative timeout tracker/is expired=] then:
            1. Increment |metrics|'s [=per participant metrics/cumulative timeouts occurred=] by 1.
            1. [=iteration/continue=].
          1. Let |bidsToScore| be the result of applying [=adjust bid list based on k-anonymity=] to |bidsBatch|.
          1. Let |foundKAnonBids| be false.
          1. [=list/For each=] |generatedBid| of |bidsToScore|:
            1. If |generatedBid|'s [=generated bid/for k-anon auction=] is true,
               set |foundKAnonBids| to true.
          1. If |bidsToScore| [=list/is not empty=] but |foundKAnonBids| is false:

            Note: [=generate potentially multiple bids=] is now rerun with only k-anonymous [=interest group/ads=] to give
            the buyer a chance to [=generate potentially multiple bids=] for k-anonymous [=interest group/ads=]. Allowing
            the buyer to first [=generate potentially multiple bids=] for non-k-anonymous [=interest group/ads=] provides a
            mechanism to bootstrap the k-anonymity count, otherwise no [=interest group/ads=] would
            ever trigger [=increment k-anonymity count=] and all ads would fail
            [=query k-anonymity count=].
            1. Let |kAnonRestrictedIG| be the result of running [=create a k-anon restricted deep copy of the interest group=]
              given |ig|.
            1. Let |effectiveBuyerTimeout| be the result of [=computing effective timeout=] given
              |cumulativeTimeoutTracker| and |perBuyerTimeout|.
            1. Let |generateBidStartTime| be |settings|'s
              [=environment settings object/current monotonic time=].
            1. Set (|generatedBids|, |bidDebugReportInfo|, |realTimeContributions|,
              |paContributions|, |executionMetrics|) to the result of running [=generate potentially
              multiple bids=] with |allTrustedBiddingSignals|,
              |crossOriginTrustedBiddingSignalsOrigin|, |auctionSignals|, a [=map/clone=] of |browserSignals|,
              |perBuyerSignals|, |directFromSellerSignalsForBuyer|, |effectiveBuyerTimeout|,
              |expectedCurrency|, 1 (for multiBidLimit), |kAnonRestrictedIG|, |reportingContext|,
              |auctionStartTime|, and |settings|.

              Note: passing 1 for multiBidLimit limits the rerun to producing at most a single bid.

            1. Let |generateBidDuration| be the [=duration from=] |generateBidStartTime| to
              |settings|'s [=environment settings object/current monotonic time=], in milliseconds.
            1. [=Expend cumulative timeout time=] given |cumulativeTimeoutTracker| and
              |generateBidDuration|.
            1. If |cumulativeTimeoutTracker| [=cumulative timeout tracker/is expired=] then:
              1. Increment |metrics|'s [=per participant metrics/cumulative timeouts occurred=]
                by 1.
              1. [=iteration/continue=].
            1. [=Assert=] that [=list/size=] of |generatedBids| &le; 1.
            1. [=list/For each=] |generatedBid| of |generatedBids|:
              1. [=Assert=] that [=query generated bid k-anonymity count=] given |generatedBid| returns true.
              1. [=Apply any component ads target to a bid=] given |generatedBid|.
              1. [=list/Append=] |generatedBid| to |bidsToScore|.
          1. [=Register bids for reporting=] given |bidsToScore|, |ig|, |bidDebugReportInfo|,
            |paContributions|, |executionMetrics|, and |reportingContext|.
          1. If |auctionConfig|'s [=auction config/per buyer real time reporting config=][|buyer|]
            is "`default-local-reporting`", then [=insert entries to map=] given
            |realTimeContributionsMap|, |buyer|, and |realTimeContributions|.
          1. [=list/For each=] |bidToScore| of |bidsToScore|:
            1. If |bidToScore|'s [=generated bid/for k-anon auction=] is true,
                [=list/append=] |bidToScore|'s [=generated bid/interest group=] to |bidIgs|.
            1. [=Score and rank a bid=] with |auctionConfig|, |reportingContext|, |bidToScore|,
              |leadingBidInfo|, |decisionLogicFetcher|, |trustedScoringSignalsBatcher|,
              |directFromSellerSignalsForSeller|, |dataVersion|, |auctionLevel|,
              |componentAuctionExpectedCurrency|, |topLevelOrigin|, |realTimeContributionsMap|,
              and |policyContainer|.
  1. [=Update cumulative buyer time metrics=] given |metrics| and |cumulativeTimeoutTracker|.
  1. Decrement |pendingBuyers| by 1.
1. Wait until both |pendingBuyers| and |pendingAdditionalBids| are 0.
1. If |auctionConfig|'s [=auction config/aborted=] is true, return failure.
1. Set |reportingContext|'s [=reporting context/local leader info=] to |leadingBidInfo|.
1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is null, return null.
1. If |topLevelAuctionConfig| is null:
  1. Let « |sellerSignals|, |reportResultBrowserSignals| » be the result of running
    [=report result=] with |leadingBidInfo|, |reportingContext|, |directFromSellerSignalsForSeller|,
    null, and |global|.
  1. Let |directFromSellerSignalsForWinner| be the result of running
      [=get direct from seller signals for a buyer=] with |directFromSellerSignals|, and
      |leadingBidInfo|'s [=leading bid info/leading bid=]'s [=generated bid/interest group=]'s
      [=interest group/owner=].
  1. Run [=report win=] with |leadingBidInfo|, |reportingContext|, |sellerSignals|,
    |reportResultBrowserSignals|, |directFromSellerSignalsForWinner|, and |settings|.
  1. Set |reportingContext|'s [=reporting context/winner reporting id=] to |leadingBidInfo|'s
    [=leading bid info/leading bid=]'s [=generated bid/reporting id=].
1. Let |replacements| be an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=]
    are [=strings=].
  1. [=list/For each=] [=ad keyword replacement=], |replacement|, within
    [=auction config/deprecated render url replacements=]:
    1. Let |k| be |replacement|'s [=ad keyword replacement/match=].
    1. Let |v| be |replacement|'s [=ad keyword replacement/replacement=].
    1. [=map/Set=] |replacements|[|k|] to |v|.
1. Set |leadingBidInfo|'s [=leading bid info/leading bid=]'s [=generated bid/ad descriptor=] to the
  result of [=fencedframeutil/substitute macros=] with |replacements| and [=leading bid info/leading bid=]'s
  [=generated bid/ad descriptor=].
1. If |leadingBidInfo|'s [=leading bid info/leading bid=]'s [=generated bid/ad descriptors=] is not null:
  1. [=list/For each=] [=generated bid/ad descriptor=], |adDescriptor|, within
    [=leading bid info/leading bid=]'s [=generated bid/ad descriptors=]:
    1. Set |adDescriptor| to the result of [=fencedframeutil/substitute macros=] with |replacements|
      and |adDescriptor|.
1. Return |leadingBidInfo|.

</div>

<div algorithm>
To <dfn>build an interest group passed to generateBid</dfn> given an [=interest group=] |ig|:

  1. Let |igGenerateBid| be a new {{GenerateBidInterestGroup}} with the following fields:
    <dl>
      <dt>{{GenerateBidInterestGroup/owner}}
      <dd>The [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      <dt>{{GenerateBidInterestGroup/name}}
      <dd>|ig|'s [=interest group/name=]
      <dt>{{GenerateBidInterestGroup/enableBiddingSignalsPrioritization}}
      <dd>|ig|'s [=interest group/enable bidding signals prioritization=]
      <dt>{{GenerateBidInterestGroup/priorityVector}}
      <dd>|ig|'s [=interest group/priority vector=] if not null, otherwise not set.
      <dt>{{GenerateBidInterestGroup/executionMode}}
      <dd>|ig|'s [=interest group/execution mode=]
      <dt>{{GenerateBidInterestGroup/biddingLogicURL}}
      <dd>The [=serialize a URL|serialization-or-undefined=] of |ig|'s [=interest group/bidding url=]
      <dt>{{GenerateBidInterestGroup/biddingWasmHelperURL}}
      <dd>The [=serialize a URL|serialization=] of |ig|'s [=interest group/bidding wasm helper url=]
      <dt>{{GenerateBidInterestGroup/updateURL}}
      <dd>The [=serialize a URL|serialization=] of |ig|'s [=interest group/update url=]
      <dt>{{GenerateBidInterestGroup/trustedBiddingSignalsURL}}
      <dd>The [=serialize a URL|serialization=] of |ig|'s [=interest group/trusted bidding signals url=]
      <dt>{{GenerateBidInterestGroup/trustedBiddingSignalsKeys}}
      <dd>|ig|'s [=interest group/trusted bidding signals keys=], if not null, otherwise not set.
      <dt>{{GenerateBidInterestGroup/trustedBiddingSignalsSlotSizeMode}}
      <dd>|ig|'s [=interest group/trusted bidding signals slot size mode=]
      <dt>{{GenerateBidInterestGroup/maxTrustedBiddingSignalsURLLength}}
      <dd>|ig|'s [=interest group/max trusted bidding signals url length=]
      <dt>{{GenerateBidInterestGroup/trustedBiddingSignalsCoordinator}}
      <dd>The [=serialization of an origin|serialization=] of |ig|'s [=interest group/trusted bidding signals coordinator=]
      <dt>{{GenerateBidInterestGroup/userBiddingSignals}}
      <dd>[=Parse a JSON string to a JavaScript value=] given |ig|'s [=interest group/user bidding signals=]

      <dt>{{GenerateBidInterestGroup/ads}}
      <dd>|ig|'s [=interest group/ads=] [=converted to an AuctionAd sequence=]
      <dt>{{GenerateBidInterestGroup/adComponents}}
      <dd>|ig|'s [=interest group/ad components=] [=converted to an AuctionAd sequence=]
    </dl>
  1. Return |igGenerateBid|.
</div>

<div algorithm>
To <dfn>convert to an AuctionAd sequence</dfn> given a [=list=]-or-null |ads|:

  1. If |ads| is null, then return {{undefined}}.
  1. Let |adsIDL| be a new <code>[=sequence=]<{{AuctionAd}}></code>.
  1. [=list/For each=] |ad| of |ads|:
    1. Let |adIDL| be a new {{AuctionAd}}.
    1. [=map/Set=] |adIDL|["{{AuctionAd/renderURL}}"] to the [=URL serializer|serialization=] of
      |ad|'s [=interest group ad/render url=].
    1. If |ad|'s [=interest group ad/selectable buyer and seller reporting IDs=] is not null:
      1. [=map/Set=] |adIDL|["{{AuctionAd/selectableBuyerAndSellerReportingIds}}"] to
        |ad|'s [=interest group ad/selectable buyer and seller reporting IDs=].
      1. If |ad|'s [=interest group ad/buyer and seller reporting id=] is not null then
        [=map/set=] |adIDL|["{{AuctionAd/buyerAndSellerReportingId}}"] to
        |ad|'s [=interest group ad/buyer and seller reporting id=].
      1. If |ad|'s [=interest group ad/buyer reporting id=] is not null then
        [=map/set=] |adIDL|["{{AuctionAd/buyerReportingId}}"] to
        |ad|'s [=interest group ad/buyer reporting id=].
    1. If |ad|'s [=interest group ad/size group=] is not null, then [=map/set=]
       |adIDL|["{{AuctionAd/sizeGroup}}"] to |ad|'s [=interest group ad/size group=].
    1. If |ad|'s [=interest group ad/metadata=] is not null, then [=map/set=]
      |adIDL|["{{AuctionAd/metadata}}"] to the result of
      [=parsing a JSON string to a JavaScript value=] given |ad|'s [=interest group ad/metadata=].
    1. If |ad|'s [=interest group ad/creative scanning metadata=] is not null, then [=map/set=]
      |adIDL|["{{AuctionAd/creativeScanningMetadata}}"] to it.
    1. [=list/Append=] |adIDL| to |adsIDL|.
  1. Return |adsIDL|.
</div>

<div algorithm>
To <dfn>fetch and decode trusted scoring signals</dfn> given a [=trusted scoring signals batcher=]
|batcher|, an [=auction config=] |auctionConfig|, a [=generated bid=] |generatedBid|, a
[=script fetcher=] |decisionLogicFetcher|, an [=origin=] |topLevelOrigin|, a [=real time reporting
contributions map=] |realTimeContributionsMap|, and a [=policy container=] |policyContainer|:

1. Let |isCrossOrigin| be false.
1. Let |sameOriginTrustedScoringSignals| be null.
1. Let |crossOriginTrustedScoringSignals| be null.
1. Let |scoringDataVersion| be null.
1. Let |sendCreativeScanningMetadata| be |auctionConfig|'s [=auction config/send creative scanning
  metadata=].
1. If |auctionConfig|'s [=auction config/trusted scoring signals coordinator=] is not null,
  set |sendCreativeScanningMetadata| to false.
1. Let |owner| be |generatedBid|'s [=generated bid/interest group=]'s [=interest group/owner=].
1. Let |mainAd| be the result of [=filling in creative info=] given |sendCreativeScanningMetadata|,
  |generatedBid|'s [=generated bid/ad descriptor=], |owner|, [=generated bid/bid ad=].
1. Let |adComponents| be a new empty [=set=].
1. [=list/for each=] |i| in [=the range=] from 0 to [=generated bid/bid ad components=]'s
  [=list/size=] - 1, inclusive:
    1. Let |adComponentCreativeInfo| be the result of [=filling in creative info=] given
      |sendCreativeScanningMetadata|, |generatedBid|'s [=generated bid/ad component descriptors=][|i|],
      |owner|, |generatedBid|'s [=generated bid/bid ad components=][|i|].
    1. [=set/Append=] |adComponentCreativeInfo| to |adComponents|.
1. If |auctionConfig|'s [=auction config/trusted scoring signals url=] is not null:
  1. Let |request| be a new [=trusted scoring signals request=] with the following [=struct/items=]:
      : [=trusted scoring signals request/send creative scanning metadata=]
      :: |sendCreativeScanningMetadata|.

      : [=trusted scoring signals request/seller=]
      :: |auctionConfig|'s [=auction config/seller=]

      : [=trusted scoring signals request/seller script fetcher=]
      :: |decisionLogicFetcher|

      : [=trusted scoring signals request/base url=]
      :: |auctionConfig|'s [=auction config/trusted scoring signals url=]

      : [=trusted scoring signals request/seller experiment group id=]
      :: |auctionConfig|'s [=auction config/seller experiment group id=]

      : [=trusted scoring signals request/top level origin=]
      :: |topLevelOrigin|

      : [=trusted scoring signals request/ad=]
      :: |mainAd|

      : [=trusted scoring signals request/ad components=]
      :: |adComponents|

      : [=trusted scoring signals request/policy container=]
      :: |policyContainer|

      : [=trusted scoring signals request/signal coordinator=]
      :: |auctionConfig|'s [=auction config/trusted scoring signals coordinator=]

      : [=trusted scoring signals request/owner origin=]
      :: |owner|

      : [=trusted scoring signals request/joining origin=]
      :: |generatedBid|'s [=generated bid/interest group=]'s [=interest group/joining origin=]

  1. If |auctionConfig|'s [=auction config/trusted scoring signals url=]'s [=url/origin=] is not
    [=same origin=] with |auctionConfig|'s [=auction config/seller=], then set |isCrossOrigin| to
    true.
  1. Let |result| be the result of [=fetching trusted scoring signals with batching=] with
    |batcher| and |request|.
  1. If |result| is not failure:
    1. Let |allTrustedScoringSignals| be |result|'s [=trusted scoring signals reply/all trusted
        scoring signals=]:
    1. Set |scoringDataVersion| to |result|'s [=trusted scoring signals reply/data version=].
    1. Let |trustedScoringSignals| be a new empty [=map=].
    1. [=map/Set=] |trustedScoringSignals|["`renderURL`"] to a new empty [=map=].
    1. If |allTrustedScoringSignals|["`renderURLs`"] [=map/exists=] and
      |allTrustedScoringSignals|["`renderURLs`"][|renderURL|] [=map/exists=], then [=map/set=]
      |trustedScoringSignals|["`renderURL`"][|renderURL|] to
      |allTrustedScoringSignals|["`renderURLs`"][|renderURL|].
    1. If |adComponentRenderURLs| is not [=list/empty=]:
      1. Let |adComponentRenderURLsValue| be a new empty [=map=].
      1. If |allTrustedScoringSignals|["`adComponentRenderURLs`"] [=map/exists=], [=set/for each=]
        |adComponentRenderURL| in |adComponentRenderURLs|:
        1. If |allTrustedScoringSignals|["`adComponentRenderURLs`"][|adComponentRenderURL|]
          [=map/exists=], then [=map/set=] |adComponentRenderURLsValue|[|adComponentRenderURL|] to
          |allTrustedScoringSignals|["`adComponentRenderURLs`"][|adComponentRenderURL|].
      1. [=map/Set=] |trustedScoringSignals|["`adComponentRenderURLs`"] to |adComponentRenderURLsValue|.
    1. If |isCrossOrigin| is false, set |sameOriginTrustedScoringSignals|
      to |trustedScoringSignals|.
    1. Otherwise:
      1. Set |crossOriginTrustedScoringSignals| to a new [=map=].
      1. Let |originKey| be the [=serialization of an origin|serialization=] given
          |auctionConfig|'s [=auction config/trusted scoring signals url=]'s [=url/origin=].
      1. [=map/Set=] |crossOriginTrustedScoringSignals|[|originKey|] to |trustedScoringSignals|.
  1. Otherwise if |auctionConfig|'s [=auction config/seller real time reporting config=]
    is "`default-local-reporting`",then:
    1. [=Add a platform contribution=] with [=trusted scoring signals failure bucket=],
      |realTimeContributionsMap|, and |auctionConfig|'s [=auction config/seller=].
1. Return «|isCrossOrigin|, |sameOriginTrustedScoringSignals|, |crossOriginTrustedScoringSignals|,
  |scoringDataVersion|»

</div>

<div algorithm>
To <dfn>score and rank a bid</dfn> given an [=auction config=] |auctionConfig|,
a [=reporting context=] |reportingContext|, a [=generated bid=] |generatedBid|,
a [=leading bid info=] |leadingBidInfo|, a [=script fetcher=] |decisionLogicFetcher|,
a [=trusted scoring signals batcher=] |trustedScoringSignalsBatcher|
a {{DirectFromSellerSignalsForSeller}} |directFromSellerSignalsForSeller|, an {{unsigned long}}-or-null
|biddingDataVersion|, an enum |auctionLevel|, which is "single-level-auction", "top-level-auction",
or "component-auction", a [=currency tag=] |componentAuctionExpectedCurrency|, an [=origin=]
|topLevelOrigin|, a [=real time reporting contributions map=] |realTimeContributionsMap|, and
a [=policy container=] |policyContainer|:

1. Let «|trustedScoringSignalsAreCrossOrigin|, |sameOriginTrustedScoringSignals|,
  |crossOriginTrustedScoringSignals|, |scoringDataVersion|» be the result of [=fetch and
  decode trusted scoring signals=] given |trustedScoringSignalsBatcher|, |auctionConfig|,
  |generatedBid|, |decisionLogicFetcher|, |topLevelOrigin|, |realTimeContributionsMap|,
  and |policyContainer|.
1. Let |adMetadata| be |generatedBid|'s [=generated bid/ad=].
1. Let |bidValue| be |generatedBid|'s [=generated bid/bid=].
1. If |generatedBid|'s [=generated bid/modified bid=] is not null, then set |bidValue| to
  |generatedBid|'s [=generated bid/modified bid=].
1. Let |owner| be |generatedBid|'s [=generated bid/interest group=]'s [=interest group/owner=].
1. Let |browserSignals| be a {{ScoringBrowserSignals}} with the following fields:
  <dl>
    <dt>{{ScoringBrowserSignals/topWindowHostname}}
    <dd>The result of running the <a spec=url>host serializer</a> on |topLevelOrigin|'s [=origin/host=]
    <dt>{{ScoringBrowserSignals/interestGroupOwner}}
    <dd>[=serialization of an origin|Serialized=] |owner|
    <dt>{{ScoringBrowserSignals/renderURL}}
    <dd>The result of running the [=URL serializer=] on |generatedBid|'s
      [=generated bid/ad descriptor=]'s [=ad descriptor/url=]
    <dt>{{ScoringBrowserSignals/renderSize}}
    <dd>The result of running [=convert an ad size to a map=] with |generatedBid|'s
        [=generated bid/ad descriptor=]'s [=ad descriptor/size=] if it is not null, {{undefined}} otherwise
    <dt>{{ScoringBrowserSignals/biddingDurationMsec}}
    <dd>|generatedBid|'s [=generated bid/bid duration=]
    <dt>{{ScoringBrowserSignals/bidCurrency}}
    <dd>The result of [=serializing a currency tag=] with |generatedBid|'s [=generated bid/bid=]'s
      [=bid with currency/currency=]
    <dt>{{ScoringBrowserSignals/dataVersion}}
    <dd>|scoringDataVersion| if it is not null and |trustedScoringSignalsAreCrossOrigin| is false,
        unset otherwise.
    <dt>{{ScoringBrowserSignals/crossOriginDataVersion}}
    <dd>|scoringDataVersion| if it is not null and |trustedScoringSignalsAreCrossOrigin| is true,
        unset otherwise.
    <dt>{{ScoringBrowserSignals/adComponents}}
    <dd>|generatedBid|'s [=generated bid/ad component descriptors=] [=converted to a string sequence=]
    <dt>{{ScoringBrowserSignals/forDebuggingOnlyInCooldownOrLockout}}
    <dd>The result of running [=is debugging only in cooldown or lockout=] with |seller|
    <dt>{{ScoringBrowserSignals/creativeScanningMetadata}}
    <dd>|generatedBid|'s [=generated bid/bid ad=]'s [=interest group ad/creative scanning metadata=]
      if non-null, unset otherwise.
    <dt>{{ScoringBrowserSignals/adComponentsCreativeScanningMetadata}}
    <dd>Unset if |generatedBid|'s [=generated bid/bid ad components=] [=list/is empty=];
      the result of [=extracting component ad creative scanning metadata=] given |generatedBid|'s
      [=generated bid/bid ad components=] otherwise.
  </dl>

1. Let |decisionLogicScript| be the result of [=wait for script body from a fetcher=] given
  |decisionLogicFetcher|.
1. If |decisionLogicScript| is failure, then:
  1. If |auctionConfig|'s [=auction config/seller real time reporting config=] is
    "`default-local-reporting`", then [=add a platform contribution=] with
    [=scoring script failure bucket=], |realTimeContributionsMap| and |seller|.
  1. Return.
1. Let |metrics| be the result of [=access per-participant metrics=] given |reportingContext|,
  |auctionConfig|'s [=auction config/seller=], [=worklet function/score-ad=].
1. [=Add a sample to an averager=] given |metrics|'s [=per participant metrics/code fetch time
  averager=] and |decisionLogicFetcher|'s [=script fetcher/fetch duration=].
1. Let « |scoreAdResult|, |debugWinReportUrl|, |debugLossReportUrl|, |realTimeContributions|,
  |paContributions|, |executionMetrics| » be the result of [=evaluating a scoring script=] with
  |decisionLogicScript|, |adMetadata|, |bidValue|'s [=bid with currency/value=], |auctionConfig|,
  |reportingContext|, |sameOriginTrustedScoringSignals|, |crossOriginTrustedScoringSignals|,
  |browserSignals|, |directFromSellerSignalsForSeller|, and |auctionConfig|'s [=auction config/
  seller timeout=].
1. Increment |metrics|'s [=per participant metrics/script executions attempted=] by 1.
1. If |executionMetrics|'s [=execution metrics/script timed out=] is true, increment |metrics|'s
  [=per participant metrics/script timeouts occurred=] by 1.
1. If |generatedBid|'s [=generated bid/for k-anon auction=] is true:

  Note: Non-k-anonymous bids do not participate in reporting (except for platform real-time
  contributions, and some special handling of private aggregation requests involving reject-reason);
  as it would be problematic to report a winner that didn't actually win.

  1. Let |reportingId| be |generatedBid|'s [=generated bid/reporting id=].
  1. If |reportingContext|'s [=reporting context/debug reporting info=][|reportingId|] does not
    [=map/exist=], set it to a new [=bid debug reporting info=].
  1. Let |bidDebugReportInfo| be |reportingContext|'s [=reporting context/debug reporting info=]
    [|reportingId|].
  1. If |auctionLevel| is "top-level-auction":
    1. Set |bidDebugReportInfo|'s [=bid debug reporting info/top level seller debug loss report
      url=] to |debugLossReportUrl|.
    1. Set |bidDebugReportInfo|'s [=bid debug reporting info/top level seller debug win report
      url=] to |debugWinReportUrl|.
  1. Otherwise:
    1. Set |bidDebugReportInfo|'s [=bid debug reporting info/seller debug loss report url=] to
      |debugLossReportUrl|.
    1. Set |bidDebugReportInfo|'s [=bid debug reporting info/seller debug win report url=] to
      |debugWinReportUrl|.
  1. If |auctionLevel| is "component-auction", then set |bidDebugReportInfo|'s [=bid debug reporting
    info/component seller=] to |seller|.
  1. If |auctionConfig|'s [=auction config/seller real time reporting config=] is
    "`default-local-reporting`", then [=insert entries to map=] given |realTimeContributionsMap|,
    |seller|, and |realTimeContributions|.
  1. [=set/Insert=] |reportingId| into |reportingContext|'s [=reporting context/seller
    participants=].
  1. [=Commit private aggregation contributions=] given |paContributions|, |reportingId|, and
    |reportingContext|.
1. Let |scoreAdOutput| be result of [=processing scoreAd output=] with |scoreAdResult|.
1. Return if any of the following conditions hold:
  * |scoreAdOutput| is failure;
  * |auctionLevel| is not "single-level-auction", and |scoreAdOutput|
    ["{{ScoreAdOutput/allowComponentAuction}}"] is false;
  * |scoreAdOutput|["{{ScoreAdOutput/desirability}}"] &le; 0.
1. If |auctionLevel| is "component-auction":
  1. Set |generatedBid|'s [=generated bid/component seller=] to |seller|.
  1. Let |bidToCheck| be |generatedBid|'s [=generated bid/bid=].
  1. If |scoreAdOutput|["{{ScoreAdOutput/bid}}"] [=map/exists=]:
    1. Let |modifiedBidValue| be |scoreAdOutput|["{{ScoreAdOutput/bid}}"].
    1. If |modifiedBidValue| &le; 0, return.
    1. Let |modifiedBidCurrency| be null.
    1. If |scoreAdOutput|["{{ScoreAdOutput/bidCurrency}}] [=map/exists=], then set
      |modifiedBidCurrency| to |scoreAdOutput|["{{ScoreAdOutput/bidCurrency}}].
    1. Set |generatedBid|'s [=generated bid/modified bid=] to a [=bid with currency=] with
      [=bid with currency/value=] |modifiedBidValue| and [=bid with currency/currency=]
      |modifiedBidCurrency|.
    1. Set |bidToCheck| to |generatedBid|'s [=generated bid/modified bid=].
  1. If the result of [=checking a currency tag=] with |componentAuctionExpectedCurrency| and
    |bidToCheck|'s [=bid with currency/currency=] is false, return.
  1. If the result of [=checking a currency tag=] with |auctionConfig|'s
    [=auction config/seller currency=] and |bidToCheck|'s [=bid with currency/currency=] is false,
    return.
1. If |auctionConfig|'s [=auction config/seller currency=] is not null:
  1. If |generatedBid|'s [=generated bid/bid=]'s [=bid with currency/currency=] is equal to
    |auctionConfig|'s [=auction config/seller currency=]:
    1. Set |generatedBid|'s [=generated bid/bid in seller currency=] to |generatedBid|'s
      [=generated bid/bid=]'s [=bid with currency/value=].
    1. If |scoreAdOutput|["{{ScoreAdOutput/incomingBidInSellerCurrency}}"] [=map/ exists=] and does
      not equal |generatedBid|'s [=generated bid/bid in seller currency=], return.
  1. Otherwise if |scoreAdOutput|["{{ScoreAdOutput/incomingBidInSellerCurrency}}"] [=map/ exists=],
    then set |generatedBid|'s [=generated bid/bid in seller currency=] to
    |scoreAdOutput|["{{ScoreAdOutput/incomingBidInSellerCurrency}}"].
1. Let |score| be |scoreAdOutput|["{{ScoreAdOutput/desirability}}"].
1. If |generatedBid|'s [=generated bid/for k-anon auction=] is false:
  1. Let |updateLeadingNonKAnonEnforcedBid| be false.
  1. If |leadingBidInfo|'s [=leading bid info/leading non-k-anon-enforced bid=]
     is null, or |score| &gt; |leadingBidInfo|'s [=leading bid info/top non-k-anon-enforced score=]:
    1. Set |updateLeadingNonKAnonEnforcedBid| to true.
    1. Set |leadingBidInfo|'s [=leading bid info/top non-k-anon-enforced bids count=] to 1.
  1. If |leadingBidInfo|'s [=leading bid info/leading non-k-anon-enforced bid=] is not null and
      |score| = |leadingBidInfo|'s [=leading bid info/top non-k-anon-enforced score=]:
      1. Increment |leadingBidInfo|'s [=leading bid info/top non-k-anon-enforced bids count=] by 1.
      1. Set |updateLeadingNonKAnonEnforcedBid| to true with 1 in |leadingBidInfo|'s
        [=leading bid info/top non-k-anon-enforced bids count=] chance.
  1. If |updateLeadingNonKAnonEnforcedBid| is true:
     1. Set |leadingBidInfo|'s [=leading bid info/top non-k-anon-enforced score=]
        to |score|.
     1. Set |leadingBidInfo|'s [=leading bid info/leading non-k-anon-enforced bid=] to |generatedBid|.
  1. Return.
1. Let |updateLeadingBid| be false.
1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is null, or |score| &gt;
  |leadingBidInfo|'s [=leading bid info/top score=]:
  1. Set |updateLeadingBid| to true.
  1. Set |leadingBidInfo|'s [=leading bid info/top bids count=] to 1.
  1. Set |leadingBidInfo|'s [=leading bid info/at most one top bid owner=] to true.
1. Otherwise if |score| equals |leadingBidInfo|'s [=leading bid info/top score=]:
  1. Increment |leadingBidInfo|'s [=leading bid info/top bids count=] by 1.
  1. Set |updateLeadingBid| to true with 1 in |leadingBidInfo|'s [=leading bid info/top bids count=]
    chance.
  1. If |updateLeadingBid| is false, then [=update highest scoring other bid=] with |score|,
    |leadingBidInfo|'s [=leading bid info/leading bid=], and |leadingBidInfo|.
  1. If |owner| is not [=same origin=] with |leadingBidInfo|'s [=leading bid info/leading bid=]'s
    [=generated bid/interest group=]'s [=interest group/owner=], then set |leadingBidInfo|'s
    [=leading bid info/at most one top bid owner=] to false.
1. Otherwise if |score| is greater than or equal to |leadingBidInfo|'s
  [=leading bid info/second highest score=], then [=update highest scoring other bid=] with |score|,
  |bidValue|, and |leadingBidInfo|.
1. If |updateLeadingBid| is true:
  1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is not null, then
    [=update highest scoring other bid=] with |leadingBidInfo|'s [=leading bid info/top score=],
    |leadingBidInfo|'s [=leading bid info/leading bid=], and |leadingBidInfo|.
  1. Set |leadingBidInfo|'s [=leading bid info/top score=] to |score|.
  1. Set |leadingBidInfo|'s [=leading bid info/leading bid=] to |generatedBid|.
  1. Set |leadingBidInfo|'s [=leading bid info/auction config=] to |auctionConfig|.
  1. Set |leadingBidInfo|'s [=leading bid info/bidding data version=] to |biddingDataVersion|.
  1. Set |leadingBidInfo|'s [=leading bid info/scoring data version=] to |scoringDataVersion|.

</div>

<div algorithm>
To <dfn>convert to a string sequence</dfn> given a [=list=]-or-null |adComponents|:

  1. If |adComponents| is null, return {{undefined}}.
  1. Let |result| be a new <code>[=sequence=]<{{USVString}}></code>.
  1. [=list/For each=] |component| of |adComponents|:
    1. [=list/Append=] [=URL serializer|serialized=] |component|'s [=ad descriptor/url=] to |result|.
  1. Return |result|.
</div>

<div algorithm>
To <dfn>extract component ad creative scanning metadata</dfn> given a [=list=] of
[=interest group ad=] |bidAdComponents|:

  1. Let |result| be a new <code>[=sequence=]<{{USVString}}?></code>.
  1. [=list/For each=] |componentAd| of |bidAdComponents|:
    1. [=list/Append=] |componentAd|'s [=interest group ad/creative scanning metadata=] to |result|.
  1. Return |result|.
</div>

<div algorithm>
To <dfn>update highest scoring other bid</dfn> given a {{double}} |score|, a
[=generated bid=]-or-null |bid|, and a [=leading bid info=] |leadingBidInfo|:

  1. If |bid| is null, return.
  1. Let |owner| be |bid|'s [=generated bid/interest group=]'s [=interest group/owner=].
  1. If |score| is greater than |leadingBidInfo|'s [=leading bid info/second highest score=]:
    1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bid=] to |bid|.
    1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bids count=] to 1.
    1. Set |leadingBidInfo|'s [=leading bid info/second highest score=] to |score|.
    1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bid owner=] to |owner| if
      |leadingBidInfo|'s [=leading bid info/at most one top bid owner=] is true, null otherwise.
  1. Otherwise if |score| is equal to |leadingBidInfo|'s [=leading bid info/second highest score=]:
    1. Increment |leadingBidInfo|'s [=leading bid info/highest scoring other bids count=] by 1.
    1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bid=] to |bid| with 1 in
      |leadingBidInfo|'s [=leading bid info/highest scoring other bids count=] chance.
    1. If |leadingBidInfo|'s [=leading bid info/highest scoring other bid owner=] is not null and
      |owner| is not [=same origin=] with |leadingBidInfo|'s
      [=leading bid info/highest scoring other bid owner=], then set |leadingBidInfo|'s
      [=leading bid info/highest scoring other bid owner=] to null.
</div>

The <dfn http-header><code>Ad-Auction-Allowed</code></dfn> HTTP response header is a
[=structured header=] whose value must be a [=structured header/boolean=].

<div algorithm>
To <dfn>validate fetching response headers</dfn> given a [=response=] |response|:

  1. If [=header list/getting a structured field value|getting=] [:Ad-Auction-Allowed:] and
     "`item`" from |response|'s [=response/header list=] does not return a true value, return false.
  1. If |response|'s [=response/status=] is not an [=ok status=], return false.
  1. Return true.
</div>

<div algorithm>
To <dfn>validate fetching response mime and body</dfn> given a [=response=] |response|, null,
failure, or a [=byte sequence=] |responseBody|, and a [=string=] |mimeType|:

  1. If |responseBody| is null or failure, return false.
  1. Let |headerMimeType| be the result of [=header list/extracting a MIME type=] from |response|'s
    [=response/header list=].
  1. Return false if any of the following conditions hold:
    * |headerMimeType| is failure;
    * |mimeType| is "`text/javascript`" and |headerMimeType| is not a [=JavaScript MIME type=];
    * |mimeType| is "`application/json`" and |headerMimeType| is not a [=JSON MIME type=].
    * |mimeType| is "`application/wasm`" and the result of [=header list/getting=] "`Content-Type`"
      from |response|'s [=response/header list=] is null or not [=byte-case-insensitive=] equal to
      "`application/wasm`".
    * |mimeType| is "`message/ad-auction-trusted-signals-response`" and the result of
      [=header list/getting=] "`Content-Type`" from |response|'s [=response/header list=] is null
      or not [=byte-case-insensitive=] equal to "`message/ad-auction-trusted-signals-response`".

      Note: This was intended to match the behavior of [=compiling a potential WebAssembly
      response=], but diverges by failing to remove leading and trailing [=HTTP tab or space
      bytes=].

  1. If |mimeType| is not "`application/wasm`":
    1. Let |mimeTypeCharset| be "utf-8".
    1. If |headerMimeType|'s [=MIME type/parameters=]["`charset`"] exists, set |mimeTypeCharset|
      to |headerMimeType|'s [=MIME type/parameters=]["`charset`"].
    1. Return true if any of the following conditions hold:
      * |mimeTypeCharset| is "utf-8", and |responseBody| is [=UTF-8=] encoded;
      * |mimeTypeCharset| is "us-ascii", and all bytes in |responseBody| are [=ASCII bytes=].
    1. Return false.
  1. Return true.
</div>

<div algorithm>
To <dfn>validate fetching response</dfn> given a [=response=] |response|, null, failure, or a
[=byte sequence=] |responseBody|, and a [=string=] |mimeType|:

  1. If the result of [=validating fetching response headers=] given |response| is false, then
     return false.
  1. If the result of [=validating fetching response mime and body=] given |response|,
     |responseBody|, |mimeType| is false, then return false.
  1. Return true.
</div>

<div algorithm>
To <dfn>fetch WebAssembly</dfn> given a [=URL=] |url| and an [=environment settings object=] |settings|:

  1. Let |request| be a new [=request=] with the following properties:
    :   [=request/URL=]
    ::  |url|
    :   [=request/header list=]
    ::  «`Accept`: `application/wasm`»
    :   [=request/client=]
    ::  `null`
    :   [=request/origin=]
    ::  |settings|'s [=environment settings object/origin=]
    :   [=request/mode=]
    ::  "`no-cors`"
    :   [=request/referrer=]
    ::  "`no-referrer`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/redirect mode=]
    ::  "`error`"
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/policy container=]
    ::  A new [=policy container=] whose [=policy container/IP address space=] is |settings|'s
      [=environment settings object/policy container=]'s [=policy container/IP address space=]

    Issue: Stop using "`no-cors`" mode where possible
    (<a href="https://github.com/WICG/turtledove/issues/667">WICG/turtledove#667</a>).
  1. Let |moduleObject| be null.
  1. [=Fetch=] |request| with [=fetch/processResponseConsumeBody=] set to the following steps given
    a [=response=] |response| and null, failure, or a [=byte sequence=] |responseBody|:
    1. If [=validate fetching response=] with |response|, |responseBody| and "`application/wasm`"
        returns false, set |moduleObject| to failure and return.
    1. Let |module| be the result of [=compiling a WebAssembly module=] |response|.
    1. If |module| is [=error=], set |moduleObject| to failure.
    1. Otherwise, set |moduleObject| to |module|.
  1. Wait for |moduleObject| to be set.
  1. Return |moduleObject|.
</div>

The <dfn http-header><code>Data-Version</code></dfn> HTTP response header is a
[=structured header=] whose value must be an [=structured header/integer=].
The <dfn http-header><code>X-fledge-bidding-signals-format-version</code></dfn> HTTP response header
is a [=structured header=] whose value must be an [=structured header/integer=].

<div algorithm>
To <dfn>fetch trusted signals</dfn> given a [=URL=] |url|, an [=origin=] |scriptOrigin|, a
[=policy container=] |policyContainer|, and a [=boolean=] |isBiddingSignal|. They return a
[=tuple=] consisting of ([=ordered map=] or null, [=ordered map=] or null, integer or null):

  1. Let |request| be a new [=request=] with the following properties:
    :   [=request/URL=]
    ::  |url|
    :   [=request/origin=]
    ::  |scriptOrigin|
    :   [=request/header list=]
    ::  «`Accept`: `application/json`»
    :   [=request/client=]
    ::  `null`
    :   [=request/mode=]
    ::  "`cors`"
    :   [=request/referrer=]
    ::  "`no-referrer`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/redirect mode=]
    ::  "`error`"
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/policy container=]
    ::  A new [=policy container=] whose [=policy container/IP address space=] is |policyContainer|'s
      [=policy container/IP address space=]

  1. Let |signals| be null.
  1. Let |dataVersion| be null.
  1. Let |formatVersion| be null.
  1. Let |perInterestGroupData| be an [=ordered map=] whose [=map/keys=] are [=interest group/name=]
    [=strings=] and whose [=map/values=] are [=bidding signals per interest group data=].
  1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true, and
    [=fetch/processResponseConsumeBody=] set to the following steps given a [=response=] |response|
    and null, failure, or a [=byte sequence=] |responseBody|:
    1. If [=validate fetching response=] with |response|, |responseBody| and "`application/json`"
      returns false, set |signals| to failure and return.
    1. Let |headers| be |response|'s [=response/header list=].
    1. Set |dataVersion| to the result of [=header list/getting a structured field value=]
      given [:Data-Version:] and "`item`" from |headers|.
    1. If |dataVersion| is not null:
      1. If |dataVersion| is not an integer, or is less than 0 or more than 2<sup>32</sup>&minus;1,
        set |signals| to failure and return.
    1. If |isBiddingSignal| is true, then set |formatVersion| to the result of
      [=header list/getting a structured field value=] given
      [:X-fledge-bidding-signals-format-version:] and "`item`" from |headers|.
    1. Set |signals| to the result of [=parsing JSON bytes to an Infra value=] |responseBody|.
  1. Wait for |signals| to be set.
  1. If |signals| is a parsing exception, or if |signals| is not an [=ordered map=], return a
    [=tuple=] (null, null, null).
  1. If |formatVersion| is 2:
    1. If |signals|["`keys`"] does not [=map/exist=], [=tuple=] (null, null, null ).
    1. Set |signals| to |signals|["`keys`"].
    1. If |signals| is not an [=ordered map=], return a [=tuple=] (null, null, null).
    1. If |signals|["`perInterestGroupData`"] [=map/exists=] and is an [=ordered map=]:
      1. [=Assert=] |isBiddingSignal| is true.
      1. Let |perInterestGroupData| be |signals|["`perInterestGroupData`"].
  1. [=map/For each=] |key| → |value| of |signals|:
    1. [=map/Set=] |signals|[|key|] to the result of [=serializing an Infra value to a JSON string=]
      given |value|.
  1. Return a [=tuple=] (|signals|, |perInterestGroupData|, |dataVersion|).
</div>

<div algorithm>
To <dfn>fetch trusted key value signals</dfn> given a [=URL=] |url|, a [=byte sequence=] |body|, a
[=string=]-or-null |context|, an [=origin=] |scriptOrigin|, a [=policy container=] |policyContainer|,
an [=map=]-or-null |indexMap| whose keys are [=strings=] and values are [=tuples=] consisting of an
interger and an integer , and a [=boolean=] |isBiddingSignal|:

1. Let |request| be a new [=request=] with the following properties:
  :   [=request/URL=]
  ::  |url|
  :   [=request/method=]
  ::  `POST`
  :   [=request/body=]
  ::  |body|
  :   [=request/origin=]
  ::  |scriptOrigin|
  :   [=request/header list=]
  ::  «`Content-Type`: `message/ad-auction-trusted-signals-request`,
       `Accept`: `message/ad-auction-trusted-signals-response`»
  :   [=request/client=]
  ::  `null`
  :   [=request/mode=]
  ::  "`cors`"
  :   [=request/referrer=]
  ::  "`no-referrer`"
  :   [=request/credentials mode=]
  ::  "`omit`"
  :   [=request/redirect mode=]
  ::  "`error`"
  :   [=request/service-workers mode=]
  ::  "`none`"
  :   [=request/policy container=]
  ::  A new [=policy container=] whose [=policy container/IP address space=] is |policyContainer|'s
    [=policy container/IP address space=]

1. Let |signals| be null.
1. Let |signalsMap| be an empty [=map=], whose keys are [=strings=] and values are [=maps=].
1. Let |dataVersion| be an empty [=ordered map=], whose [=map/keys=] are [=strings=] and [=map/values=] are integers.
1. Let |perInterestGroupData| be an [=ordered map=] whose [=map/keys=] are [=interest group/name=] [=strings=]
  and whose [=map/values=] are [=bidding signals per interest group data=].
1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true, and
  [=fetch/processResponseConsumeBody=] set to the following steps given a [=response=] |response|
  and null, failure, or a [=byte sequence=] |responseBody|:
  1. If [=validate fetching response=] with |response|, |responseBody| and
    "`message/ad-auction-trusted-signals-response`" returns false, return « failure, null, null ».
  1. Let |resultList| be the result of deserializing |responseBody| using |context|. The
    deserialization method may follow that described in
    [Section 2.3.6 of the Protected Audience Key Value Services](https://privacysandbox.github.io/draft-ietf-protected-audience-key-value-service/draft-ietf-protected-audience-key-value-services.html#name-parsing-a-response).
  1. [=list/For each=] |result| in |resultList|:
    1. If |result| [=map/contains=] "`dataVersion`":
      1. If |result|["dataVersion"] is not an integer, or is less than 0 or more than
        2<sup>32</sup>&minus;1, return « failure, null, null ».
    1. If |isBiddingSignal| is true:
      1. [=map/For each=] |name| → |value| in |result|["interestGroupNames"]:
        1. If |indexMap|[|name|] does not equal to |result|["index"], return « failure, null, null ».
        1. [=map/Set=] |perInterestGroupData|[|name|] to |value|.
        1. If |result| [=map/contains=] "`dataVersion`", [=map/set=] |dataVersion|[|name|] to |result|["dataVersion"].
      1. [=map/For each=] |key| → |value| in |result|["keys"]:
        1. [=map/Set=] |signalsMap|[|key|] to |value|.
    1. Otherwise:
      1. [=map/For each=] |url| → |value| in |result|["renderURLs"]:
        1. [=map/Set=] |signalsMap|[|url|] to |value|.
        1. If |result| [=map/contains=] `"dataVersion"`, [=map/set=] |dataVersion|[|url|] to |result|["dataVersion"].
      1. [=map/For each=] |url| → |value| in |result|["adComponentRenderURLs"]:
        1. [=map/Set=] |signalsMap|[|url|] to |value|.
1. If |signalsMap| is not empty, set |signals| to |signalsMap|.
1. Return « |signals|, |perInterestGroupData|, |dataVersion| ».

</div>

<div algorithm="update CORS-safelisted request-header">

Add "<code>message/ad-auction-trusted-signals-request</code>" to <var ignore>mimeType</var>’s
<a for="MIME type">essence</a> check list under "<code>content-type</code>" in
[CORS-safelisted request-header](https://fetch.spec.whatwg.org/#cors-safelisted-request-header).

</div>

<div algorithm>

To <dfn>encode trusted signals keys</dfn> given a [=list=] of [=strings=] |keys|:
1. Let |escapedKeys| be a new [=list=] of [=strings=].
1. [=list/For each=] |keyStr| in |keys|:
  1. [=list/Append=] the result of [=string/UTF-8 percent-encoding=] |keyStr| using
    [=component percent-encode set=] to |escapedKeys|.

  Issue: The Chrome implementation encodes 0x20 (SP) to U+002B (+), while [=string/UTF-8 percent-encoding=]
    encodes it to "%20".
1. Return the result of [=string/concatenating=] |escapedKeys| with separator set to ",".

</div>

<div algorithm>

To <dfn>convert an ad size to a string</dfn> given an [=ad size=] |adSize|.

1. Let |sizeList| be an empty [=list=].
1. Let |jsWidth| be |adSize|'s [=ad size/width=], [=converted to an ECMAScript value=].
1. [=list/Append=] [$ToString$](|jsWidth|) to |sizeList|.
1. [=list/Append=] |adSize|'s [=ad size/width=] to |sizeList|.
1. [=list/Append=] |adSize|'s [=ad size/width units=] to |sizeList|.
1. [=list/Append=] "," to |sizeList|.
1. Let |jsHeight| be |adSize|'s [=ad size/height=], [=converted to an ECMAScript value=].
1. [=list/Append=] [$ToString$](|jsHeight|) to |sizeList|.
1. [=list/Append=] |adSize|'s [=ad size/height units=] to |sizeList|.
1. Return the result of [=string/concatenating=] |sizeList|.

</div>

<div algorithm>

To <dfn>calculate the ad slot size query param</dfn> given an [=interest group=] |ig| and
[=auction config=] |config|:

1. Switch on |ig|'s [=interest group/trusted bidding signals slot size mode=]:
  <dl class=switch>
    <dt>"`none`"
    <dd>
    1. Return "".

    <dt>"`slot-size`"
    <dd>
    1. If |config|'s [=auction config/requested size=] is null, then return "".
    1. Otherwise:
      1. Let |adSizeString| the result of running [=convert an ad size to a string=] on |config|'s
        [=auction config/requested size=].
      1. Return the result of [=string/concatenating=] « "&amp;slotSize=", |adSizeString| ».

    <dt>"`all-slots-requested-sizes`"
    <dd>
    1. If |config|'s [=auction config/all slots requested sizes=] is null, then return "".
    1. Let |allSizesList| be a new [=list=] or [=strings=].
    1. [=list/For each=] |adSize| in |config|'s [=auction config/all slots requested sizes=]:
      1. Let |adSizeString| the result of running [=convert an ad size to a string=] on |adSize|.
      1. [=list/Append=] |adSizeString| to |allSizesList|.
    1.  Let |allSizes| be the result of [=string/concatenating=] |allSizesList|, with ","
      as a separator.
    1.  Return the result of [=string/concatenating=] « "&amp;allSlotsRequestedSizes=",
      |allSizes| ».
  </dl>

</div>

<div algorithm>
To <dfn>send report</dfn> given a [=URL=] |url|, and an [=environment settings object=] |settings|:

  1. Let |request| be a new [=request=] with the following properties:
    :   [=request/URL=]
    ::  |url|
    :   [=request/client=]
    ::  `null`
    :   [=request/origin=]
    ::  |settings|'s [=environment settings object/origin=]
    :   [=request/mode=]
    ::  "`no-cors`"
    :   [=request/referrer=]
    ::  "`no-referrer`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/redirect mode=]
    ::  "`error`"
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/policy container=]
    ::  A new [=policy container=] whose [=policy container/IP address space=] is |settings|'s
      [=environment settings object/policy container=]'s [=policy container/IP address space=]

    Issue: Stop using "`no-cors`" mode where possible
    (<a href="https://github.com/WICG/turtledove/issues/667">WICG/turtledove#667</a>).
  1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true.
</div>

<div algorithm>
To <dfn>get direct from seller signals</dfn> given an [=origin=] |seller|, a [=string=]-or-null
|adSlot|, and a [=map=] |capturedAuctionSignalsHeaders|:

  1. If |adSlot| is not a [=string=], then return null.
  1. Let |directFromSellerSignals| be null.
  1. Let |directFromSellerSignalsKey| be a new [=direct from seller signals key=] with its
    [=direct from seller signals key/seller=] set to |seller|, and
    [=direct from seller signals key/ad slot=] set to |adSlot|.
  1. If |capturedAuctionSignalsHeaders|[|directFromSellerSignalsKey|] [=map/exists=]:
    1. Set |directFromSellerSignals| to |capturedAuctionSignalsHeaders|[|directFromSellerSignalsKey|].
  1. Return |directFromSellerSignals|.
</div>

<div algorithm>
To <dfn>get direct from seller signals for a seller</dfn> given a
[=direct from seller signals=]-or-null |directFromSellerSignals|:

  1. Let |directFromSellerSignalsForSeller| be a new {{DirectFromSellerSignalsForSeller}}.
  1. If |directFromSellerSignals| is null, then return |directFromSellerSignalsForSeller|.
  1. [=map/Set=] |directFromSellerSignalsForSeller|["auctionSignals"] to the result of running
    [=parse a JSON string to an Infra value=] given |directFromSellerSignals|'s
    [=direct from seller signals/auction signals=].
  1. [=map/Set=] |directFromSellerSignalsForSeller|["sellerSignals"] to the result of running
    [=parse a JSON string to an Infra value=] given |directFromSellerSignals|'s
    [=direct from seller signals/seller signals=].
  1. Return |directFromSellerSignalsForSeller|.
</div>

<div algorithm>
To <dfn>get direct from seller signals for a buyer</dfn> given a
[=direct from seller signals=]-or-null |directFromSellerSignals|, and an [=origin=] |owner|:

  1. Let |directFromSellerSignalsForBuyer| be a new {{DirectFromSellerSignalsForBuyer}}.
  1. If |directFromSellerSignals| is null, then return |directFromSellerSignalsForBuyer|.
  1. [=map/Set=] |directFromSellerSignalsForBuyer|["auctionSignals"] to the result of running
    [=parse a JSON string to an Infra value=] given |directFromSellerSignals|'s
    [=direct from seller signals/auction signals=].
  1. If |directFromSellerSignals|'s [=direct from seller signals/per buyer signals=][|owner|]
    [=map/exists=]:
    1. [=map/Set=] |directFromSellerSignalsForBuyer|["perBuyerSignals"] to the result of running
      [=parse a JSON string to an Infra value=] given |directFromSellerSignals|'s
      [=direct from seller signals/per buyer signals=][|owner|].
  1. Return |directFromSellerSignalsForBuyer|.
</div>

<div algorithm>
To <dfn>report result</dfn> given a [=leading bid info=] |leadingBidInfo|, a
[=reporting context=] |reportingContext|, a [=direct from seller signals=]-or-null
|directFromSellerSignals|, an [=auction config=]-or-null |winningComponentConfig|,
and a [=global object=] |global|:
  1. Let |config| be |leadingBidInfo|'s [=leading bid info/auction config=].
  1. Let |bidCurrency| be null.
  1. If |winningComponentConfig| is not null:
    1. [=Assert=] that |leadingBidInfo|'s [=leading bid info/component seller=] is not null.
    1. Set |bidCurrency| to |winningComponentConfig|'s [=auction config/seller currency=].
    1. If |bidCurrency| is null, then set |bidCurrency| to the result of
      [=looking up per-buyer currency=] with |config| and |leadingBidInfo|'s
      [=leading bid info/component seller=].
  1. Otherwise, set |bidCurrency| to the result of [=looking up per-buyer currency=] with |config|
    and |leadingBidInfo|'s [=leading bid info/leading bid=]'s [=generated bid/interest group=]'s
    [=interest group/owner=].
  1. Let |winner| be |leadingBidInfo|'s [=leading bid info/leading bid=].
  1. Let |sellerCurrency| be |leadingBidInfo|'s [=leading bid info/auction config=]'s
    [=auction config/seller currency=].
  1. Let |highestScoringOtherBid| be |leadingBidInfo|'s
    [=leading bid info/highest scoring other bid=]'s [=generated bid/bid in seller currency=] (or
    0 if encountered a null).
  1. If |sellerCurrency| is null, then set |highestScoringOtherBid| to |leadingBidInfo|'s
      [=leading bid info/highest scoring other bid=]'s [=generated bid/bid=]'s
      [=bid with currency/value=] (or 0 if encountered a null).
  1. Let |bid| be |winner|'s [=generated bid/bid=]'s [=bid with currency/value=].
  1. Let |modifiedBid| be null.
  1. If |winner|'s [=generated bid/modified bid=] is not null:
    1. If |leadingBidInfo|'s [=leading bid info/component seller=] is not null, then set |bid| to
      |winner|'s [=generated bid/modified bid=].
    1. Otherwise, set |modifiedBid| to |winner|'s [=generated bid/modified bid=].
  1. Let |browserSignals| be a {{ReportResultBrowserSignals}} with the following fields:
    <dl link-for-hint="ReportingBrowserSignals">
      <dt>{{topWindowHostname}}
      <dd>The result of running the <a spec=url>host serializer</a> on |global|'s
        [=environment/top-level origin=]'s [=origin/host=].
      <dt>{{interestGroupOwner}}
      <dd>[=serialization of an origin|Serialized=] |winner|'s [=generated bid/interest group=]'s
        [=interest group/owner=].
      <dt>{{renderURL}}
      <dd>[=URL serializer|Serialized=] |winner|'s [=generated bid/ad descriptor=]'s [=ad descriptor/url=]
      <dt>{{bid}}
      <dd>[=round a value|Stochastically rounded=] |bid|
      <dt>{{bidCurrency}}
      <dd>The result of [=serializing a currency tag=] with |bidCurrency|
      <dt>{{highestScoringOtherBid}}
      <dd>|highestScoringOtherBid|
      <dt>{{highestScoringOtherBidCurrency}}
      <dd>|sellerCurrency| if it is not null, "`???`" otherwise
      <dt>{{topLevelSeller}}
      <dd>|leadingBidInfo|'s [=leading bid info/top level seller=] if it is not null, {{undefined}}
        otherwise
      <dt>{{componentSeller}}
      <dd>|leadingBidInfo|'s [=leading bid info/component seller=] if it is not null, {{undefined}}
        otherwise
      <dt>{{ReportResultBrowserSignals/desirability}}
      <dd>[=round a value|Stochastically rounded=] |leadingBidInfo|'s [=leading bid info/top score=]
      <dt>{{ReportResultBrowserSignals/topLevelSellerSignals}}
      <dd>|leadingBidInfo|'s [=leading bid info/top level seller signals=] if it is not null,
        {{undefined}} otherwise
      <dt>{{ReportResultBrowserSignals/modifiedBid}}
      <dd>[=round a value|Stochastically rounded=] |modifiedBid| if it is not null, {{undefined}}
        otherwise
      <dt>{{ReportResultBrowserSignals/dataVersion}}
      <dd>|leadingBidInfo|'s [=leading bid info/scoring data version=] if it is not null,
        {{undefined}} otherwise
    </dl>
  1. Let |igAd| be the [=interest group ad=] from |winner|'s [=generated bid/interest group=]'s
    [=interest group/ads=] whose [=interest group ad/render url=] is |winner|'s
    [=generated bid/ad descriptor=]'s [=ad descriptor/url=].
  1. If the |winner|'s [=generated bid/selected buyer and seller reporting ID=] is not null:
    1. [=Assert=] that the result of running [=query reporting ID k-anonymity count=] with |winner|'s
      [=generated bid/interest group=], |igAd|, and |winner|'s
      [=generated bid/selected buyer and seller reporting ID=] is true.

      Note: The winning [=interest group ad=] is expected to be k-anonymous for reporting because any
      [=generated bid/bid=] that included a [=generated bid/selected buyer and seller reporting ID=]
      wouldn't be considered k-anonymous, and thus couldn't win the auction and wouldn't be reported,
      unless that bid was k-anonymous for reporting with that [=generated bid/selected buyer and seller reporting ID=].

    1. [=map/Set=] |browserSignals|["{{ReportingBrowserSignals/selectedBuyerAndSellerReportingId}}"]
      to |winner|'s [=generated bid/selected buyer and seller reporting ID=].
    1. If |igAd|'s [=interest group ad/buyer and seller reporting ID=] is not null, [=map/set=]
      |browserSignals|["{{ReportingBrowserSignals/buyerAndSellerReportingId}}"] to it.
  1. Otherwise, if the result of running [=query reporting ID k-anonymity count=] with |winner|'s
    [=generated bid/interest group=], |igAd|, and null is true:
    1. If |igAd|'s [=interest group ad/buyer and seller reporting ID=] is not null, [=map/set=]
      |browserSignals|["{{ReportingBrowserSignals/buyerAndSellerReportingId}}"] to it.
  1. Let |metrics| be the result of [=access per-participant metrics=] given |reportingContext|,
    |config|'s [=auction config/seller=], [=worklet function/report-result=].
  1. Let |sellerReportingScriptFetcher| be the result of [=creating a new script fetcher=] with
     |config|'s [=auction config/decision logic url=] and |global|'s [=relevant settings object=].
  1. Let |sellerReportingScript| be the result of [=waiting for script body from a fetcher=] given
     |sellerReportingScriptFetcher|.
  1. [=Add a sample to an averager=] given |metrics|'s [=per participant metrics/code fetch time
    averager=] and |sellerReportingScriptFetcher|'s [=script fetcher/fetch duration=].
  1. Let « |sellerSignals|, |reportUrl|, |reportingBeaconMap|, ignored, |paContributions|,
    |executionMetrics| » be the result of [=evaluating a reporting script=] with
    |sellerReportingScript|, "`reportResult`",  |reportingContext|,
    |config|'s [=auction config/seller=], |config|'s
    [=auction config/seller Private Aggregation coordinator=],  |config|'s [=auction config/
    config idl=]'s {{AuctionAdConfig/reportingTimeout}}, and
    « |config|'s [=auction config/config idl=], |browserSignals|, |directFromSellerSignals| ».
  1. Set |metrics|'s [=per participant metrics/script executions attempted=] to 1.
  1. If |executionMetrics|'s [=execution metrics/script timed out=] is true, set |metrics|'s
    [=per participant metrics/script timeouts occurred=] to 1.
  1. Let |reportingResult| be a [=reporting result=] with the following [=struct/items=]:
     : [=reporting result/report url=]
     :: |reportUrl|
     : [=reporting result/reporting beacon map=]
     :: |reportingBeaconMap|
  1. If |leadingBidInfo|'s [=leading bid info/top level seller=] is null (i.e., if we are reporting
     for a component seller), set |leadingBidInfo|'s
     [=leading bid info/component seller reporting result=] to |reportingResult|.
  1. Otherwise, set |leadingBidInfo|'s [=leading bid info/seller reporting result=] to
     |reportingResult|.
  1. [=Commit private aggregation contributions=] given |paContributions|, |winner|'s [=generated
    bid/reporting id=] and |reportingContext|.
  1. [=map/Remove=] |browserSignals|["`desirability`"].
  1. [=map/Remove=] |browserSignals|["`modifiedBid`"].
  1. [=map/Remove=] |browserSignals|["`topLevelSellerSignals`"].
  1. [=map/Remove=] |browserSignals|["`dataVersion`"].

    Note: Remove fields specific to {{ReportResultBrowserSignals}} which only sellers can learn about,
    so that they are not passed to "`reportWin()`".

  1. Return « |sellerSignals|, |browserSignals| ».
</div>

<div algorithm>
To <dfn>report win</dfn> given a [=leading bid info=] |leadingBidInfo|, [=reporting context=]
|reportingContext|,  a [=string=] |sellerSignals|,
a {{ReportingBrowserSignals}} |browserSignals|, a [=direct from seller signals=]-or-null
|directFromSellerSignals|, and an [=environment settings object=] |settings|:

  1. Let |config| be |leadingBidInfo|'s [=leading bid info/auction config=].
  1. Let |winner| be |leadingBidInfo|'s [=leading bid info/leading bid=].
  1. Let |perBuyerSignals| be |config|'s [=auction config/per buyer signals=].
  1. Let |buyer| be |winner|'s [=generated bid/interest group=]'s [=interest group/owner=].
  1. Let |perBuyerSignalsForBuyer| be |perBuyerSignals|[|buyer|] if that member [=map/exists=],
    and null otherwise.
  1. Let |reportWinBrowserSignals| be a {{ReportWinBrowserSignals}} with the members that
    are declared on {{ReportingBrowserSignals}} initialized to their values in |browserSignals|.
  1. Add the following fields to |reportWinBrowserSignals|:
    <dl>
      <dt>{{ReportWinBrowserSignals/dataVersion}}
      <dd>|leadingBidInfo|'s [=leading bid info/bidding data version=] if it is not null,
        {{undefined}} otherwise.
      <dt>{{ReportWinBrowserSignals/adCost}}
      <dd>[=Round a value|Rounded=] |winner|'s [=generated bid/ad cost=]
      <dt>{{ReportWinBrowserSignals/seller}}
      <dd>[=serialization of an origin|Serialized=] |config|'s [=auction config/seller=]
      <dt>{{ReportWinBrowserSignals/madeHighestScoringOtherBid}}
      <dd>Set to true if |leadingBidInfo|'s [=leading bid info/highest scoring other bid owner=] is
        not null, and |buyer| is [=same origin=] with |leadingBidInfo|'s
        [=leading bid info/highest scoring other bid owner=], false otherwise
      <dt>{{ReportWinBrowserSignals/modelingSignals}}
      <dd>|winner|'s [=generated bid/modeling signals=] if it is not null, {{undefined}} otherwise
        (TODO: noise and bucket this signal)
    </dl>
  1. Let |ig| be |winner|'s [=generated bid/interest group=].
  1. Let |metrics| be the result of [=access per-participant metrics=] given |reportingContext|,
    |ig|'s [=interest group/owner=], [=worklet function/report-win=].
  1. Let |igAd| be the [=interest group ad=] from ig's [=interest group/ads=] whose
     [=interest group ad/render url=] is |winner|'s
     [=generated bid/ad descriptor=]'s [=ad descriptor/url=].
  1. If |winner|'s [=generated bid/selected buyer and seller reporting ID=] is not null:

      Note: If the winning [=generated bid/bid=] has a [=generated bid/selected buyer and seller reporting ID=],
      it would have already been set by the preceding call to [=report result=], and provided to this algorithm in the
      {{ReportingBrowserSignals}} returned by that algorithm and provided to this one.

    1. [=Assert=] that |reportWinBrowserSignals|'s ["{{ReportingBrowserSignals/selectedBuyerAndSellerReportingId}}"]
      is equal to |winner|'s [=generated bid/selected buyer and seller reporting ID=].
    1. [=Assert=] that the result of running [=query reporting ID k-anonymity count=] with
      |winner|'s [=generated bid/interest group=], |igAd|, and
      [=generated bid/selected buyer and seller reporting ID=] is true.
  1. Otherwise if |igAd|'s [=interest group ad/buyer and seller reporting ID=] is not null:

      Note: If the winning [=interest group ad=] has a [=interest group ad/buyer and seller reporting ID=],
      it would have already been set by the preceding call to [=report result=], and provided to this algorithm in the
      {{ReportingBrowserSignals}} returned by that algorithm and provided to this one.

    1. [=Assert=] that |reportWinBrowserSignals|'s ["{{ReportingBrowserSignals/buyerAndSellerReportingId}}"] is equal to
      |igAd|'s [=interest group ad/buyer and seller reporting ID=].
    1. [=Assert=] that the result of running [=query reporting ID k-anonymity count=] with
      |winner|'s [=generated bid/interest group=], |igAd|, and null is true.
  1. Otherwise if the result of running [=query reporting ID k-anonymity count=] with
    |winner|'s [=generated bid/interest group=], |igAd|, and null is true:
    1. If |igAd|'s [=interest group ad/buyer reporting ID=] is not null,
      [=map/set=] |reportWinBrowserSignals|["{{ReportWinBrowserSignals/buyerReportingId}}"] to
      |igAd|'s [=interest group ad/buyer reporting ID=].
    1. Otherwise, [=map/set=] |reportWinBrowserSignals|["{{ReportWinBrowserSignals/interestGroupName}}"]
      to |winner|'s [=generated bid/interest group=] [=interest group/name=].
  1. Let |buyerReportingScriptFetcher| be the result of [=creating a new script fetcher=] with
     |winner|'s [=generated bid/interest group=]'s [=interest group/bidding url=] and |settings|.
  1. Let |buyerReportingScript| be the result of [=waiting for script body from a fetcher=] given
     |buyerReportingScriptFetcher|.
  1. [=Add a sample to an averager=] given |metrics|'s [=per participant metrics/code fetch time
    averager=] and |buyerReportingScriptFetcher|'s [=script fetcher/fetch duration=].
  1. Let |reportFunctionName| be "`reportWin`".
  1. If |winner|'s [=generated bid/provided as additional bid=] is true:
    1. Set |reportFunctionName| be "`reportAdditionalBidWin`".
  1. Let « ignored, |resultUrl|, |reportingBeaconMap|, |reportingMacroMap|, |paContributions|,
    |executionMetrics| » be the result of [=evaluating a reporting script=] with
    |buyerReportingScript|, |reportFunctionName|, |reportingContext|, |ig|'s
    [=interest group/owner=], |ig|'s [=interest group/
    Private Aggregation coordinator=], |leadingBidInfo|'s [=leading bid info/auction config=]'s
    [=auction config/config idl=]'s {{AuctionAdConfig/reportingTimeout}}, and
    « |leadingBidInfo|'s [=leading bid info/auction config=]'s [=auction config/config idl=]'s
      {{AuctionAdConfig/auctionSignals}}, |perBuyerSignalsForBuyer|, |sellerSignals|,
      |reportWinBrowserSignals|, |directFromSellerSignals| ».
  1. Set |metrics|'s [=per participant metrics/script executions attempted=] to 1.
  1. If |executionMetrics|'s [=execution metrics/script timed out=] is true, set |metrics|'s
    [=per participant metrics/script timeouts occurred=] to 1.
  1. [=Commit private aggregation contributions=] given |paContributions|, |winner|'s [=generated
    bid/reporting id=] and |reportingContext|.
  1. Set |leadingBidInfo|'s [=leading bid info/buyer reporting result=] to a [=reporting result=]
     with the following [=struct/items=]:
     : [=reporting result/report url=]
     :: |resultUrl|

     : [=reporting result/reporting beacon map=]
     :: |reportingBeaconMap|

     : [=reporting result/reporting macro map=]
     :: |reportingMacroMap|
</div>

<div algorithm>
To <dfn>parse and validate server response</dfn> given an [=auction config=] |auctionConfig|, an
[=auction config=]-or-null |topLevelAuctionConfig|, a [=global object=] |global|,
a [=list=] of [=interest groups=] |bidIgs|, and a [=reporting context map=]
|reportingContextMap|, perform the following steps. They return a [=leading bid info=] or a failure.

1. [=Assert=] that these steps are running [=in parallel=].
1. If [=waiting until server response promise resolves=] given |auctionConfig| returns failure, then
  return failure.
1. Let |requestId| be the value of |auctionConfig|'s [=auction config/server response id=].
1. Let |requestContexts| be the value of |global|'s [=associated Document's=] [=node navigable's=]
  [=traversable navigable's=] [=traversable navigable/saved Bidding and Auction request context=].
1. If |requestContexts|[(|seller|,|requestId|)] does not [=map/exist=], return null.
1. Let |requestContext| be |requestContexts|[(|seller|,|requestId|)].
1. Let |response| be the [=server auction response=] which is the result of
   deserializing |auctionConfig|'s [=auction config/server response=]
   with |requestContext| according to [Section 2.3.5 of the Bidding and Auction Services IETF standard](https://privacysandbox.github.io/draft-ietf-bidding-and-auction-services/draft-ietf-bidding-and-auction-services.html#name-parsing-a-response).
1. If |response|'s [=server auction response/nonce=] [=map/exists=]:
  1. Let |capturedAuctionNonceHeaders| be |global|'s [=associated Document's=] [=node navigable's=]
    [=traversable navigable's=] [=traversable navigable/captured ad auction result nonce headers=].
  1. Let |seller| be |auctionConfig|'s [=auction config/seller=].
  1. If |capturedAuctionNonceHeaders|[|seller|] does not [=map/exist=] or does not
    [=list/contain=] the [=ASCII lowercase=] [=string representation=] of |response|'s
    [=server auction response/nonce=], then return failure.
1. Otherwise:
  1. Let |hash| be the [=SHA-256=] of |auctionConfig|'s [=auction config/server response=].
  1. Let |capturedAuctionResultHeaders| be |global|'s [=associated Document's=] [=node navigable's=]
    [=traversable navigable's=] [=traversable navigable/captured ad auction result headers=].
  1. Let |seller| be |auctionConfig|'s [=auction config/seller=].
  1. If |capturedAuctionResultHeaders|[|seller|] does not [=map/exist=] or does not [=list/contain=] |hash|,
    then return failure.
1. If |response| is failure, then return failure.
1. If |response|'s [=server auction response/top level seller=] is not null:
  1. If |topLevelAuctionConfig| is null return failure.
  1. If |topLevelAuctionConfig|'s [=auction config/seller=] is not equal to
    |response|'s [=server auction response/top level seller=], return failure.
1. Otherwise if |topLevelAuctionConfig| is not null, return failure.
1. Let |winningGroup| be the [=interest group=] in the [=user agent=]'s [=interest group set=]
   whose [=interest group/owner=] is |response|'s [=server auction response/interest group owner=] and
   [=interest group/name=] is |response|'s [=server auction response/interest group name=]. Return failure if none found.
1. If |winningGroup|'s [=interest group/ads=] is null, then return failure.
1. Let |winningAd| be null.
1. [=list/For each=] |ad| of |winningGroup|'s [=interest group/ads=]:
  1. If |response|'s [=server auction response/ad render url=] is |ad|'s
    [=interest group ad/render url=], then set |winningAd| to |ad|, and [=iteration/break=].
1. Return failure if any of the following conditions hold:
  * |winningAd| is null;
  * |response|'s [=server auction response/buyer and seller reporting id=] is not null and not
    |winningAd|'s [=interest group ad/buyer and seller reporting ID=];
  * |response|'s [=server auction response/buyer reporting id=] is not null and not
    |winningAd|'s [=interest group ad/buyer reporting ID=];
  * |response|'s [=server auction response/selected buyer and seller reporting ID=] is not null,
    |winningAd|'s [=interest group ad/selectable buyer and seller reporting IDs=] is not null and it
    does not [=list/contain=] |response|'s [=server auction response/selected buyer and seller reporting ID=].
1. Let |winningAdDescriptor| be a new [=ad descriptor=] whose [=ad descriptor/url=] is
   |response|'s [=server auction response/ad render url=].
1. Let |winningAdComponents| be a new [=list=] of [=ad descriptors=].
1. [=list/For each=] |componentAd| in |response|'s [=server auction response/ad components=]:
  1. Let |ad| be the [=interest group ad=] from |winningGroup|'s
     [=interest group/ad components=] where the [=interest group ad/render url=]
     equals |componentAd|. If there is no matching element, return failure.
  1. [=list/Append=] a new [=ad descriptor=] whose [=ad descriptor/url=] is
     |componentAd| to |winningAdComponents|.
1. Let |bidDebugReportingInfo| be a new [=bid debug reporting info=].
1. [=list/For each=] |key| → |maybeDebugReportUrl| in |response|'s
  [=server auction response/component win debugging only reports=]:
  1. If |maybeDebugReportUrl|'s [=url/scheme=] is not "`https`", then [=iteration/continue=].
  1. If |key|'s [=server auction debug report key/from seller=] is true:
    1. Set |bidDebugReportingInfo|'s [=bid debug reporting info/component seller=] to |seller|.
    1. If |key|'s [=server auction debug report key/is debug win=] is true, then set
      |bidDebugReportingInfo|'s [=bid debug reporting info/seller debug win report url=] to
      |maybeDebugReportUrl|.
    1. Otherwise, set |bidDebugReportingInfo|'s
      [=bid debug reporting info/seller debug loss report url=] to |maybeDebugReportUrl|.
  1. Otherwise,
    1. Set |bidDebugReportingInfo|'s [=bid debug reporting info/interest group owner=] to
      |response|'s [=server auction response/interest group owner=].
    1. If |key|'s [=server auction debug report key/is debug win=] is true, then set
      |bidDebugReportingInfo|'s [=bid debug reporting info/bidder debug win report url=] to
      |maybeDebugReportUrl|.
    1. Otherwise, set |bidDebugReportingInfo|'s
      [=bid debug reporting info/bidder debug loss report url=] to |maybeDebugReportUrl|.
1. Set |bidDebugReportingInfo|'s [=bid debug reporting info/server filtered debugging only reports=]
  to |response|'s [=server auction response/server filtered debugging only reports=].
1. Let |reportingContext| be |reportingContextMap|[|auctionConfig|].
1. Set |reportingContext|'s [=reporting context/debug reporting info=] to
  |bidDebugReportingInfo|.
1. Let |reportingId| be a [=reporting bid key=] with the following [=struct/items=]:
  : [=reporting bid key/context=]
  :: |reportingContext|
  : [=reporting bid key/source=]
  :: [=reporting bid source/bidding-and-auction-services=]
  : [=reporting bid key/bidder origin=]
  :: |response|'s [=server auction response/interest group owner=]
  : [=reporting bid key/bid identifier=]
  :: |response|'s [=server auction response/interest group name=]
1. [=Handle server response private aggregation fields=] given |response|, |requestContext| and
  |reportingId|.
1. Let |winningBid| be a new [=generated bid=] with the following [=struct/items=]:
  : [=generated bid/reporting id=]
  :: |reportingId|
  : [=generated bid/bid=]
  :: |response|'s [=server auction response/bid=]
  : [=generated bid/bid in seller currency=]
  :: Null
  : [=generated bid/ad=]
  :: |response|'s [=server auction response/ad metadata=]
  : [=generated bid/ad descriptor=]
  :: |winningAdDescriptor|
  : [=generated bid/ad component descriptors=]
  :: |winningAdComponents|
  : [=generated bid/ad cost=]
  :: Null
  : [=generated bid/modeling signals=]
  :: Null
  : [=generated bid/interest group=]
  :: |winningGroup|
  : [=generated bid/bid ad=]
  :: |winningAd|
  : [=generated bid/modified bid=]
  :: Null if |topLevelAuctionConfig| is null, otherwise |response|'s [=server auction response/bid=]
  : [=generated bid/bid duration=]
  :: 0
  : [=generated bid/component seller=]
  :: Null
  : [=generated bid/number of mandatory ad components=]
  :: [=list/Size=] of |winningAdComponents|
1. Let |buyerReportingResult| be a new [=reporting result=] with the following [=struct/items=]:
   : [=reporting result/report url=]
   :: The value of |response|'s [=server auction response/buyer reporting=]'s [=server auction reporting info/reporting url=].
   : [=reporting result/reporting beacon map=]
   :: The value of |response|'s [=server auction response/buyer reporting=]'s [=server auction reporting info/beacon urls=].

1. Let |sellerReportingResult| be a new [=reporting result=] with the following [=struct/items=]:
   : [=reporting result/report url=]
   :: The value of |response|'s [=server auction response/top level seller reporting=]'s [=server auction reporting info/reporting url=].
   : [=reporting result/reporting beacon map=]
   :: The value of |response|'s [=server auction response/top level seller reporting=]'s [=server auction reporting info/beacon urls=].

1. Let |componentSellerReportingResult| be a new [=reporting result=] with the following [=struct/items=]:
   : [=reporting result/report url=]
   :: The value of |response|'s [=server auction response/component seller reporting=]'s [=server auction reporting info/reporting url=].
   : [=reporting result/reporting beacon map=]
   :: The value of |response|'s [=server auction response/component seller reporting=]'s [=server auction reporting info/beacon urls=].
1. Let |topScore| be 0.0 if |response|'s [=server auction response/score=] is null,
   |response|'s [=server auction response/score=] otherwise.
1. Let |winningBidInfo| be a new [=leading bid info=] with the following [=struct/items=]:
   : [=leading bid info/top score=]
   :: |topScore|
   : [=leading bid info/top non-k-anon-enforced score=]
   :: |topScore|
   : [=leading bid info/top bids count=]
   :: 1
   : [=leading bid info/top non-k-anon-enforced bids count=]
   :: 1
   : [=leading bid info/leading bid=]
   :: |winningBid|
   : [=leading bid info/leading non-k-anon-enforced bid=]
   :: |winningBid|
   : [=leading bid info/auction config=]
   :: |auctionConfig|
   : [=leading bid info/highest scoring other bid=]
   :: Null
   : [=leading bid info/top level seller=]
   :: Null if |topLevelAuctionConfig| is null, otherwise |topLevelAuctionConfig|'s [=auction config/seller=].
   : [=leading bid info/top level seller signals=]
   :: Null
   : [=leading bid info/component seller=]
   :: Null if |topLevelAuctionConfig| is null, otherwise |auctionConfig|'s [=auction config/seller=].
   : [=leading bid info/bidding data version=]
   :: Null
   : [=leading bid info/scoring data version=]
   :: Null
   : [=leading bid info/buyer reporting result=]
   :: |buyerReportingResult|
   : [=leading bid info/seller reporting result=]
   :: |sellerReportingResult|
   : [=leading bid info/component seller reporting result=]
   :: |componentSellerReportingResult|
1. [=list/For each=] |igId| in |response|'s [=server auction response/bidding groups=]:
  1. Let |ig| be the [=interest group=] in the [=user agent=]'s [=interest group set=] whose
    [=interest group/owner=] is |igId|'s [=interest group/owner=] and [=interest group/name=] is |igId|'s
    [=interest group/name=]. [=iteration/Continue=] if none found.
  1. [=list/Append=] |ig| to |bidIgs|.
1. [=map/For each=] |igId| → |updateIfOlderThan| of |response|'s
   [=server auction response/update groups=]:
  1. Let |ig| be the [=interest group=] in the [=user agent=]'s [=interest group set=] whose
    [=interest group/owner=] is |igId|'s [=interest group/owner=] and [=interest group/name=] is |igId|'s
    [=interest group/name=]. [=iteration/Continue=] if none found.
  1. If |updateIfOlderThan| is less than 10 mintues, set it to 10 minutes.
  1. If [=current coarsened wall time=] &minus; |ig|'s [=interest group/last updated=] ≥
     |updateIfOlderThan|, set |ig|'s [=interest group/next update after=] to the
     [=current coarsened wall time=] + |updateIfOlderThan|.
1. Return |winningBidInfo|.

</div>

<div algorithm>
To <dfn>handle server response private aggregation fields</dfn> given a [=server auction response=]
|response|, a [=reporting context=] |reportingContext|, and a [=reporting bid key=] |reportingId|:

1. [=Assert=] that these steps are running [=in parallel=].
1. [=Commit server response private aggregation contributions=] given |response|'s
  [=server auction response/component win private aggregation contributions=], |reportingContext|,
  and |reportingId|.
1. [=Commit server response private aggregation contributions=] given |response|'s
  [=server auction response/server filtered private aggregation reserved contributions=],
  |reportingContext|, and |reportingId|.
1. [=Commit server response private aggregation contributions=] given |response|'s
  [=server auction response/server filtered private aggregation non reserved contributions=],
  |reportingContext|, and |reportingId|.

</div>

<div algorithm>
To <dfn>commit server response private aggregation contributions</dfn> given a [=map=] from a
[=server auction private aggregation contribution key=] to a [=list=] of [=on event contribution entries=]
|contributionsMap|, a [=reporting context=] |reportingContext|, and a [=reporting bid key=]
|reportingId|:

1. [=map/For each=] |key| → |contributions| of |contributionsMap|:
  1. Let |reportingOrigin| be |key|'s [=server auction private aggregation contribution key/reporting origin=].
  1. Let |event| be |key|'s [=server auction private aggregation contribution key/event=].
  1. Let |coordinator| be |key|'s [=server auction private aggregation contribution key/coordinator=].
  1. If |coordinator| is null, set |coordinator| to the [=default aggregation coordinator=].
  1. Let |eventToContributionsMap| be a new [=Private Aggregation contributions=].
  1. Let |batchingScope| be null.
  1. If |event| [=string/starts with=] "`reserved.`", set |batchingScope| to the
    result of running [=get or create a batching scope=] given |reportingOrigin|, |coordinator| and
    |reportingContext|.

    Note: Each non-reserved |event| will have a different [=batching scope=] that is created later.
  1. [=list/For each=] |contribution| of |contributions|:
    1. [=Assert=] |contribution|["{{PAExtendedHistogramContribution/bucket}}"] is a {{bigint}} and
      is [=set/contained=] in [=the exclusive range|the range=] 0 to 2<sup>128</sup>, exclusive.
    1. [=Assert=] |contribution|["{{PAExtendedHistogramContribution/value}}"] is a {{long}}.

      Note: All {{PAExtendedHistogramContribution/bucket}} and {{PAExtendedHistogramContribution/value}}
        have been calculated on server side already.
    1. Let |entry| be a new [=on event contribution entry=] with the items:
        : [=on event contribution entry/contribution=]
        :: |contribution|
        : [=on event contribution entry/batching scope=]
        :: |batchingScope|
        : [=on event contribution entry/debug scope=]
        :: A new [=debug scope=].
        : [=on event contribution entry/worklet function=]
        :: "`generate-bid`" (it does not matter for server returned contributions)
        : [=on event contribution entry/origin=]
        :: |reportingOrigin|
    1. If |eventToContributionsMap|[|event|] does not [=map/exist=], set
      |eventToContributionsMap|[|event|] to « |entry| ».
    1. Otherwise, [=list/append=] |entry| to |eventToContributionsMap|[|event|].
1. [=Commit private aggregation contributions=] given |eventToContributionsMap|, |reportingId| and
  |reportingContext|.

</div>

<h3 id="canloadadauctionfencedframe">canLoadAdAuctionFencedFrame()</h3>

*This first introductory paragraph is non-normative.*

The process of running an ad auction through {{Window/navigator}}.{{Navigator/runAdAuction()}} is an
expensive operation. To prevent wasted cycles if the resulting ad cannot be loaded in the current
context, {{Window/navigator}}.{{Navigator/canLoadAdAuctionFencedFrame()}} is provided as a method to
determine, before the ad auction begins, whether an ad auction-created <{fencedframe}> is allowed to
be loaded in the current context. A <{fencedframe}> has restrictions on where and how it can be
loaded that do not exist with <{iframe}>s.

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  boolean canLoadAdAuctionFencedFrame();
};
</xmp>

The <dfn for=Navigator method>canLoadAdAuctionFencedFrame()</dfn> method steps are:

1. Let |global| be [=this=]'s [=relevant global object=].

1. If |global|'s [=Window/browsing context=]'s [=required CSP=] is not null, then return false.

   Note: CSPEE lets arbitrary data flow from an embedder into a <{fencedframe}> via the policies it
   sets. Since this goes against the privacy guarantees of a Protected Audience-created
   <{fencedframe}>, this is disallowed.

1. Let |CSPList| be [=this=]'s [=relevant settings object=]'s [=environment settings object/policy
   container=]'s [=policy container/CSP list=].

1. [=list/For each=] |policy| of |CSPList|:

  1. [=set/For each=] |directive| of |policy|'s [=policy/directive set=]:

    1. If |directive|'s [=directive name|name=] is either "`fenced-frame-src`", "`frame-src`",
       "`child-src`", or "`default-src`", and if |directive|'s [=directive value|value=] does not
       [=set/contain=] any of "`https:`", "`https://*:*`", or "`*`", then return false.

1. Let |sandboxFlags| be |global|'s [=associated Document=]'s [=Document/active sandboxing flag
   set=].

1. If the [=set/intersection=] of |sandboxFlags| and TBD [=set/is not empty=], then return false.

   Issue: TODO: Get the mandatory unsandboxed [=sandboxing flag set=] once it exists in the fenced
   frame spec. This will then determine the intersection between that and the |sandboxFlags|.
   (<a href="https://github.com/WICG/turtledove/issues/1206">WICG/turtledove#1206</a>)

1. Return true.

<h3 id="getInterestGroupAdAuctionData">getInterestGroupAdAuctionData()</h3>

*This first introductory paragraph is non-normative.*

When a website or someone working on behalf of the website (e.g. a supply side platform, SSP) wants
to conduct an auction using a trusted auction server to select an advertisement to display to the
user, they can call the {{Window/navigator}}.{{Navigator/getInterestGroupAdAuctionData()}} function.
This function returns an opaque {{Uint8Array}} as the request and a request ID string. The request
can be sent to a trusted auction server through the JS [[FETCH]] API, which returns a response.
The response along with the request ID can be then passed as part of an auction configuration to
{{Window/navigator}}.{{Navigator/runAdAuction()}} to extract the results of the auction.

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<AdAuctionData> getInterestGroupAdAuctionData(optional AdAuctionDataConfig config = {});
};

dictionary AdAuctionPerSellerData {
  required USVString seller;
  Uint8Array request;
  DOMString error;
};

dictionary AdAuctionData {
  required USVString requestId;
  Uint8Array request;
  sequence<AdAuctionPerSellerData> requests;
};
</xmp>

<xmp class="idl">
dictionary AdAuctionOneSeller {
  required USVString seller;
  USVString coordinatorOrigin;
};

dictionary AdAuctionDataConfig {
  USVString seller;
  USVString coordinatorOrigin;
  sequence<AdAuctionOneSeller> sellers;

  unsigned long requestSize;
  record<USVString, AdAuctionDataBuyerConfig> perBuyerConfig;
};
</xmp>

<dl class=domintro>
  <dt>{{AdAuctionDataConfig/seller}}
  <dd>The seller that will be used as the {{AuctionAdConfig/seller}} in the
    following {{AuctionAdConfig}} passed to {{Window/navigator}}.{{Navigator/runAdAuction()}}.
    Can not be specified with the {{AdAuctionDataConfig/sellers}} field. Exactly
    one of {{AdAuctionDataConfig/seller}} and {{AdAuctionDataConfig/sellers}}
    must be specified.
  <dt>{{AdAuctionDataConfig/coordinatorOrigin}}
  <dd>The origin of the coordinator hosting public encryption keys for the server
    running the ad auction. The [=origin/scheme=] must be "`https`". An implementation
    may select which coordinators are acceptable.
    Can not be specified with the {{AdAuctionDataConfig/sellers}} field.
  <dt>{{AdAuctionDataConfig/sellers}}
  <dd>A list of seller origins and, optionally, their corresponding coordinators.
    When present, the {{AdAuctionData}} provided when the {{Promise}} returned
    by {{Navigator/getInterestGroupAdAuctionData}} resolves contains the
    {{AdAuctionData/requests}} field instead of the {{AdAuctionData/request}} field.
    Can not be specified with the {{AdAuctionDataConfig/seller}} or
    {{AdAuctionDataConfig/coordinatorOrigin}} fields. Exactly
    one of {{AdAuctionDataConfig/seller}} and {{AdAuctionDataConfig/sellers}}
    must be specified.
  <dt>{{AdAuctionDataConfig/requestSize}}
  <dd>The desired size for the returned {{AdAuctionData/request}}. If any buyers are specified in
    {{AdAuctionDataConfig/perBuyerConfig}}, this will be the exact size of the returned {{AdAuctionData/request}}.
    Otherwise the returned {{AdAuctionData/request}}'s size will be at most the
    {{AdAuctionDataConfig/requestSize}}.
  <dt>{{AdAuctionDataConfig/perBuyerConfig}}
  <dd>[=map/Keys=] are [=serialization of an origin|serialized origins=] of
    buyers that should be included in the returned request. [=map/Values=] are
    {{AdAuctionDataBuyerConfig}} for that buyer.
</dl>

<xmp class="idl">
dictionary AdAuctionDataBuyerConfig {
  unsigned long targetSize;
};
</xmp>

<dl class=domintro>
  <dt>{{AdAuctionDataBuyerConfig/targetSize}}
  <dd>The size of the request to allocate for this buyer. Required when
    {{AdAuctionDataConfig}}'s {{AdAuctionDataConfig/requestSize}} is not
    specified.
</dl>

A <dfn>server auction</dfn> is an auction executed on a trusted auction server.

A <dfn>server auction interest group</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction interest group">
  : <dfn>name</dfn>
  :: A [=string=] that uniquely defines each interest group, as in [=interest group/name=].
  : <dfn>bidding signals keys</dfn>
  :: Null or a [=list=] of [=string=], as in [=interest group/trusted bidding signals keys=]
  : <dfn>user bidding signals</dfn>
  :: Null or a [=string=], as in [=interest group/user bidding signals=]
  : <dfn>ads</dfn>
  :: A [=list=] of [=strings=] containing the corresponding [=interest group ad/ad render IDs=]
    from the [=interest group/ads=] field.
  : <dfn>components</dfn>
  ::  A [=list=] of [=strings=] containing the corresponding [=interest group ad/ad render IDs=]
    from the [=interest group/ad components=] field.
  : <dfn>browser signals</dfn>
  :: A [=server auction browser signals=].
  : <dfn>priority</dfn>
  :: A {{double}}. Used to select which interest groups for a given buyer are excluded
    from the serialized request due to space limitations.
</dl>

A <dfn>server auction browser signals</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction browser signals">
  : <dfn>bid count</dfn>
  :: A count of the number of bids for this interest group in the last 30 days.
    Calculated by summing the [=interest group/bid counts=] for all days within the last 30 days.
  : <dfn>join count</dfn>
  :: A count of the number of joins for this interest group in the last 30 days.
    Calculated by summing the [=interest group/join counts=].
  : <dfn>recency ms</dfn>
  :: A [=duration=], in milliseconds, representing the [=current coarsened wall time=] at
    the time this object was constructed minus the corresponding [=interest group=]'s
    [=interest group/join time=], in milliseconds.
  : <dfn>previous wins</dfn>
  :: A <code>[=sequence=]<[=server auction previous win=]></code>
</dl>

A <dfn>server auction previous win</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction previous win">
  : <dfn>time delta</dfn>
  :: A [=duration=], in milliseconds, representing the [=current coarsened wall time=] at
    the time this object was constructed minus the corresponding [=previous win=]'s [=previous win/time=], in seconds.
  : <dfn>ad render ID</dfn>
  :: A [=string=] containing the [=interest group ad/ad render ID=] for the ad represented by this entry.
</dl>

A <dfn>server auction request context</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction request context">
  : <dfn>request ID</dfn>
  :: A unique identifier associated with this and only this invocation of
    {{Window/navigator}}.{{Navigator/getInterestGroupAdAuctionData()}}. This is
    used to look-up a specific request context.
  : <dfn>request context</dfn>
  :: An opaque context used to handle the request, such as that returned from
     [Section 2.2.4 of Bidding and Auction Services](https://privacysandbox.github.io/draft-ietf-bidding-and-auction-services/draft-ietf-bidding-and-auction-services.html#name-generating-a-request)
</dl>

A <dfn>server auction response</dfn> is a [=struct=] that contains auction result from a
[=server auction=]. It has the following [=struct/items=]:

<dl dfn-for="server auction response">
  : <dfn>nonce</dfn>
  :: [=version 4 UUID=]. A nonce to match against the [:Ad-Auction-Result-Nonce:]
     header in a fetch response from the seller. Used as a method of authorizing the response.
  : <dfn>ad render url</dfn>
  :: [=URL=]. The [=leading bid info/leading bid=]'s [=generated bid/ad descriptor=]'s [=ad descriptor/url=] from the
     auction.
  : <dfn>ad components</dfn>
  :: A [=list=] of [=URLs=]. A list of winning bid's
     [=generated bid/ad component descriptors=]'s [=ad descriptor/urls=] from the
     auction.
  : <dfn>interest group name</dfn>
  :: A [=string=]. The winning bid's interest group [=interest group/name=].
  : <dfn>interest group owner</dfn>
  :: An [=origin=]. The winning bid's interest group [=interest group/owner=].
  : <dfn>bidding groups</dfn>
  :: A [=list=] of [=tuples=] consisting of an [=origin=]
     [=interest group/owner=] and a [=string=] [=interest group/name=] for
     each interest group that bid in the auction.
  : <dfn>update groups</dfn>
  :: A [=map=]. Its [=map/keys=] are [=tuples=] consisting of an [=origin=] for
     [=interest group/owner=] and a [=string=] for [=interest group/name=]. Its
     [=map/values=] are [=durations=] indicating the desired maximum time since
     the interest group was [=interest group/last updated=].
  : <dfn>score</dfn>
  :: Null or {{double}}. Null if the server auction is not a component auction,
     otherwise the {{ScoreAdOutput/desirability}} of component auction's winning bid.
  : <dfn>bid</dfn>
  :: Null or [=bid with currency=]. Null when the server auction is not a component auction.
     For component auctions, contains the winning bid's [=generated bid/modified bid=]
     when not null, otherwise the winning bid's [=generated bid/bid=].
  : <dfn>top level seller</dfn>
  :: Null or an [=origin=]. Null when the server auction is not a component auction.
     Otherwise the value is the expected top-level seller [=origin=] for
     that auction. This should match the [=auction config/seller=] for the top-level [=auction config=].
  : <dfn>ad metadata</dfn>
  :: Null or a JSON [=string=]. Null when the server auction is not a component auction.
     Otherwise the value contains the component auction's winning bid's [=generated bid/ad=].
  : <dfn>buyer reporting id</dfn>
  :: Null or a [=string=]. When not null, this will be verified with the winning bid's
    [=generated bid/ad=]'s [=interest group ad/buyer reporting ID=].
  : <dfn>buyer and seller reporting id</dfn>
  :: Null or a [=string=]. When not null, this will be verified with the winning bid's
    [=generated bid/ad=]'s [=interest group ad/buyer and seller reporting ID=].
  : <dfn>selected buyer and seller reporting id</dfn>
  :: Null or a [=string=], initially null. When not null, this will be verified with the winning bid's
    [=generated bid/ad=]'s [=interest group ad/selectable buyer and seller reporting IDs=].
  : <dfn>winner join candidate</dfn>
  :: Null or [=server auction join candidate=]. When not null, contains the
     k-anonymity hashes corresponding to the winning bid and indicates which
     k-anonymity hashes were used for k-anonymity enforcement on the server.
  : <dfn>ghost winner</dfn>
  :: Null or [=server auction ghost winner=]. When not null, contains information
     about the non-k-anonymous winner of a server auction.
  : error
  :: Null or [=string=]. When not null, contains an error message from the
     auction executed on the trusted auction server. May be used to provide
     additional context for the result of an auction.
  : <dfn>buyer reporting</dfn>
  :: [=Server auction reporting info=]
  : <dfn>top level seller reporting</dfn>
  :: Null or [=server auction reporting info=].
  : <dfn>component seller reporting</dfn>
  :: Null or [=server auction reporting info=].
  : <dfn>component win private aggregation contributions</dfn>
  :: A [=map=] whose [=map/keys=] are [=server auction private aggregation contribution keys=], and
    whose [=map/values=] are [=lists=] of [=on event contribution entries=]. Private aggregation
    contributions from winners of component auctions run on trusted auction servers. These need to
    be filtered by the client based on the top level auction's outcome.
  : <dfn>server filtered private aggregation reserved contributions</dfn>
  :: A [=map=] whose [=map/keys=] are [=server auction private aggregation contribution keys=], and
    whose [=map/values=] are [=lists=] of [=on event contribution entries=]. Server filtered private
    aggregation contributions with reserved event types (already set to "reserved.always"), which
    are not dependent on the final auction result and should always be reported.
  : <dfn>server filtered private aggregation non reserved contributions</dfn>
  :: A [=map=] whose [=map/keys=] are [=server auction private aggregation contribution keys=], and
    whose [=map/values=] are [=lists=] of [=on event contribution entries=]. Server filtered private
    aggregation contributions with non reserved event types, which are not dependent on the final
    auction result and should always be reported.
  : <dfn>component win debugging only reports</dfn>
  :: A [=map=] whose [=map/keys=] are [=server auction debug report keys=], and whose [=map/values=]
    are [=urls=].
  : <dfn>server filtered debugging only reports</dfn>
  :: A [=map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are [=lists=] of [=urls=].
</dl>

<dfn>server auction join candidate</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction join candidate">
  : <dfn>ad render url hash</dfn>
  :: A [=SHA-256=] hash of the [=k-anonymity key=] for the ad in the winning bid,
     as calculated using [=compute the key hash of ad=].
  : <dfn>ad component render url hashes</dfn>
  :: A [=list=] of [=SHA-256=] hashes of [=k-anonymity keys=] for each of the ad
     components in the winning bid, as calculated using
     [=compute the key hash of component ad=].
  : <dfn>reporting id hash</dfn>
  :: A [=SHA-256=] hash of the [=k-anonymity key=] for the reporting ID in the
     winning bid, as calculated using [=compute the key hash of reporting ID=].
</dl>

<dfn>server auction ghost winner</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction ghost winner">
  : <dfn>candidate</dfn>
  :: [=server auction join candidate=] associated with this winner.
  : <dfn>interest group owner</dfn>
  :: An [=origin=]. The [=leading bid info/leading non-k-anon-enforced bid=]'s [=generated bid/interest group=]'s [=interest group/owner=].
  : <dfn>interest group name</dfn>
  :: A [=string=]. The [=leading bid info/leading non-k-anon-enforced bid=]'s [=generated bid/interest group=]'s [=interest group/name=].
  : <dfn>ghost winner bid info</dfn>
  :: Null or a [=server auction ghost winner bid info=], initially null. Contains information needed for
     ghost winners in component auctions.
</dl>

A <dfn>server auction ghost winner bid info</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction ghost winner bid info">
  : <dfn>ad render url</dfn>
  :: A [=URL=]. The [=leading bid info/leading non-k-anon-enforced bid=]'s
     [=generated bid/ad descriptor=]'s [=ad descriptor/url=] from the auction.
  : <dfn>ad components</dfn>
  :: A [=list=] of [=URLs=]. A list of the [=leading bid info/leading non-k-anon-enforced bid=]'s
     [=generated bid/ad component descriptors=]'s [=ad descriptor/urls=] from the
     server auction.
  : <dfn>modified bid</dfn>
  :: [=bid with currency=]. Contains the [=leading bid info/leading non-k-anon-enforced bid=]'s [=generated bid/modified bid=]
     when not null, otherwise the [=leading bid info/leading non-k-anon-enforced bid=]'s [=generated bid/bid=].
  : <dfn>ad metadata</dfn>
  :: Null or a JSON [=string=],  initially null. Contains the component auction's [=leading bid info/leading non-k-anon-enforced bid=]'s [=generated bid/ad=].
  : <dfn>buyer reporting id</dfn>
  :: Null or a [=string=], initially null. When not null, this will be verified with the [=leading bid info/leading non-k-anon-enforced bid=]'s
    [=generated bid/ad=]'s [=interest group ad/buyer reporting ID=].
  : <dfn>buyer and seller reporting id</dfn>
  :: Null or a [=string=], initially null. When not null, this will be verified with the [=leading bid info/leading non-k-anon-enforced bid=]'s
    [=generated bid/ad=]'s [=interest group ad/buyer and seller reporting ID=].
  : <dfn>selected buyer and seller reporting id</dfn>
  :: Null or a [=string=], initially null. When not null, this will be verified with the [=leading bid info/leading non-k-anon-enforced bid=]'s
    [=generated bid/ad=]'s [=interest group ad/selectable buyer and seller reporting IDs=].
</dl>

A <dfn>server auction reporting info</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction reporting info">
  : <dfn>reporting url</dfn>
  :: Null or a [=URL=]
  : <dfn>beacon urls</dfn>
  :: [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=]
     are [=URLs=] whose [=url/schemes=] are "`https`".
</dl>

a <dfn>server auction debug report key</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="server auction debug report key">
  : <dfn>from seller</dfn>
  :: A [=boolean=].
  : <dfn>is debug win</dfn>
  :: A [=boolean=].
</dl>

a <dfn>server auction private aggregation contribution key</dfn> is a [=struct=] with the following
[=struct/items=]:
<dl dfn-for="server auction private aggregation contribution key">
  : <dfn>reporting origin</dfn>
  :: The [=origin=] of the script that contributed the contribution.
  : <dfn>coordinator</dfn>
  :: Null or an [=aggregation coordinator=].
  : <dfn>event</dfn>
  :: A [=string=].
</dl>

<div algorithm="getInterestGroupAdAuctionData()">

The <dfn for=Navigator method>getInterestGroupAdAuctionData(|configIDL|)</dfn> method steps are:

1. Let |global| be [=this=]'s [=relevant global object=].
1. If |global|'s [=associated Document=] is not [=allowed to use=] the "[=run-ad-auction=]"
  [=policy-controlled feature=], then [=exception/throw=] a "{{NotAllowedError}}" {{DOMException}}.
1. Let |settings| be [=this=]'s [=relevant settings object=].
1. Let |configs| be the result of running [=parse and verify ad auction data config=]
   on |configIDL| and |settings|'s [=environment/top-level origin=].
1. Let |p| be [=a new promise=].
1. Let |queue| be the result of [=starting a new parallel queue=].
1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |queue|:
  1. Let |igMap| be a new [=map=] whose [=map/keys=] are [=origins=] and [=map/values=] are [=lists=].
  1. Let |igPAggCoordinatorMap| be a new [=map=] whose [=map/keys=] are tuples of ([=origins=], [=strings=])
    and [=map/values=] are [=origins=].
  1. Let |startTime| be a [=moment=] equal to the [=current coarsened wall time=].
  1. [=list/For each=] |ig| of the [=user agent=]'s [=interest group set=]:
    1. If |ig|'s [=interest group/ads=] is null or [=list/is empty=], [=iteration/continue=].
    1. Let |owner| be |ig|'s [=interest group/owner=].
    1. Let |name| be |ig|'s [=interest group/name=].
    1. If |igMap|[|owner|] does not [=map/exist=], then [=map/set=] |igMap|[|owner|] to a new [=list=].
    1. Let |ads| be a new [=list=].
    1. [=list/For each=] |ad| in |ig|'s [=interest group/ads=], [=list/append=] |ad|'s [=interest group ad/ad render ID=] to |ads|.
    1. Let |components| be a new [=list=].
    1. [=list/For each=] |component| in |ig|'s [=interest group/ad components=], [=list/append=]
      |component|'s [=interest group ad/ad render ID=] to |components|.
    1. Let |prevWins| be a new <code>[=sequence=]<[=server auction previous win=]></code>.
    1. [=list/For each=] |prevWin| of |ig|'s [=interest group/previous wins=] for all days within the
      the last 30 days:
      1. Let |timeDelta| be |startTime| minus |prevWin|'s [=previous win/time=].
      1. Set |timeDelta| to 0 if |timeDelta| is negative, |timeDelta|'s nearest second (rounding down)
        otherwise.
      1. Let |serverPrevWin| be a new [=server auction previous win=] with the following [=struct/items=]:
        : [=server auction previous win/time delta=]
        :: |timeDelta|
        : [=server auction previous win/ad render ID=]
        :: the value of the [=interest group ad/ad render ID=] field in |prevWin|'s [=previous win/ad=], or the empty string if not present
      1. [=list/Append=] |serverPrevWin| to |prevWins|.
    1. Let |browserSignals| be a new [=server auction browser signals=] with the following [=struct/items=]:
      : [=server auction browser signals/bid count=]
      :: the sum of |ig|'s [=interest group/bid counts=] with a bid day within the last 30 days
      : [=server auction browser signals/join count=]
      :: the sum of |ig|'s [=interest group/join counts=] with a join day within the last 30 days
      : [=server auction browser signals/recency ms=]
      :: the [=current coarsened wall time=] minus |ig|'s [=interest group/join time=] in
         millseconds
      : [=server auction browser signals/previous wins=]
      :: |prevWins|
    1. Let |serverIg| be a new [=server auction interest group=] with the following [=struct/items=]:
      : [=server auction interest group/name=]
      :: |name|
      : [=server auction interest group/bidding signals keys=]
      :: |ig|'s [=interest group/trusted bidding signals keys=]
      : [=server auction interest group/user bidding signals=]
      :: |ig|'s [=interest group/user bidding signals=]
      : [=server auction interest group/ads=]
      :: |ads|
      : [=server auction interest group/components=]
      :: |components|
      : [=server auction interest group/browser signals=]
      :: |browserSignals|
      : [=server auction interest group/priority=]
      :: |ig|'s [=interest group/priority=]
    1. [=list/Append=] |serverIg| to |igMap|[|owner|].
    1. If |ig|'s [=interest group/Private Aggregation coordinator=] is not null, then [=map/set=]
      |igPAggCoordinatorMap|[(|owner|, |name|)] to it.
  1. Let |results| be a new [=list=] of [=auction data per seller results=].
  1. Let |requestId| be the [=string representation=] of a [=version 4 UUID=].
  1. [=list/For each=] |config| of |configs|:
    1. Let |seller| be |config|'s [=auction data config/seller=].
    1. If |config|'s [=auction data config/coordinator=] is not one of the [=implementation-defined=]
       Bidding and Auction Services coordinators supported by this [=user agent=]:
      1. Let |result| be a new [=auction data per seller result=] with the following [=struct/items=]:
        : [=auction data per seller result/seller=]
        :: |seller|
        : [=auction data per seller result/error=]
        :: "invalid coordinator"
      1. [=list/Append=] |result| to |results|.
      1. [=iteration/Continue=].
    1. Let |keyInfo| be the result of [=looking up the server encryption key=]
       with |config|'s [=auction data config/seller=] and |seller|'s [=auction data config/coordinator=].
    1. If |keyInfo| is failure:
      1. Let |result| be a new [=auction data per seller result=] with the following [=struct/items=]:
        : [=auction data per seller result/seller=]
        :: |seller|
        : [=auction data per seller result/error=]
        :: "key lookup failed"
      1. [=list/Append=] |result| to |results|.
      1. [=iteration/Continue=].
    1. Let (|key|, |keyId|) be |keyInfo|.
    1. Set |config|'s [=auction data config/encryption key=] to |key|.
    1. Set |config|'s [=auction data config/encryption key id=] to |keyId|.
    1. Let (|requestBlob|, |context|) be the result of serializing |igMap| with |config| and
      |igPAggCoordinatorMap|. The serialization method may follow that described in
      [Section 2.2.4 of Bidding and Auction Services](https://privacysandbox.github.io/draft-ietf-bidding-and-auction-services/draft-ietf-bidding-and-auction-services.html#name-generating-a-request).
    1. Let |result| be a new [=auction data per seller result=] with the following [=struct/items=]:
        : [=auction data per seller result/seller=]
        :: |seller|
        : [=auction data per seller result/request=]
        :: |requestBlob|
    1. [=list/Append=] |result| to |results|.
    1. Let |requestContext| be a new [=server auction request context=].
    1. Set |requestContext|'s [=server auction request context/request ID=] field to |requestId|.
    1. Set |requestContext|'s [=server auction request context/request context=] field to |context|.
    1. [=map/Set=] |global|'s [=associated Document's=] [=node navigable's=]
      [=traversable navigable's=] [=traversable navigable/saved Bidding and Auction request context=][(|seller|,|requestId|)] to |requestContext|.
  1. Let |IDLresults| be a new {{AdAuctionData}}.
  1. [=map/Set=] |IDLresults|["{{AdAuctionData/requestId}}"] to |requestId|.
  1. If |configIDL|[{{AdAuctionDataConfig/seller}}] [=map/exists=]:
    1. Let |sellerResult| be |results|[0].
    1. If |sellerResult|'s [=auction data per seller result/error=] is not null:
      1. [=Queue a global task=] on the [=DOM manipulation task source=], given |global|, to
         [=reject=] |p| with a {{TypeError}}.
      1. Abort these steps.
    1. Set |IDLresults|["{{AdAuctionData/request}}"] to |requestBlob|.
  1. Otherwise:
    1. [=list/For each=] |sellerResult| in |results|:
      1. Let |IDLresult| be a new {{AdAuctionPerSellerData}} whose {{AdAuctionPerSellerData/seller}}
         is the [=serialization of an origin|serialization=] of |sellerResult|'s [=auction data per seller result/seller=].
      1. If |sellerResult|'s [=auction data per seller result/error=] is not null:
        1. Set |IDLresult|["{{AdAuctionPerSellerData/error}}"] to |sellerResult|'s [=auction data per seller result/error=].
        1. [=list/Append=] |IDLresult| to |IDLresults|["{{AdAuctionData/requests}}"].
      1. Otherwise:
        1. Set |IDLresult|["{{AdAuctionPerSellerData/request}}"] to |sellerResult|'s [=auction data per seller result/request=].
        1. [=list/Append=] |IDLresult| to |IDLresults|["{{AdAuctionData/requests}}"].
  1. [=Queue a global task=] on the [=DOM manipulation task source=], given |global|, to
    resolve |p| with |IDLresults|.
1. Return p.

</div>

<div algorithm>
  To <dfn>parse and verify ad auction data config</dfn> given an
  {{AdAuctionDataConfig}} |configIDL| and [=origin=] |top_level_origin|:

  1. Let |configs| be a new [=list=] of [=auction data configs=].
  1. Let |perBuyerConfigs| be the result of running [=parse per buyer auction data configs=] on
      |configIDL|["{{AdAuctionDataConfig/perBuyerConfig}}"].
  1. Let |requestSize| be |configIDL|["{{AdAuctionDataConfig/requestSize}}"] if it [=map/exists=], null otherwise.
  1. If |perBuyerConfigs| [=map/is not empty=] and |requestSize| is null:
     1. Set |requestSize| to 0.
     1. [=list/For each=] |buyerConfig| of |perBuyerConfigs|'s [=map/values=]:
        1. If |buyerConfig|'s [=auction data buyer config/size=] is null,
           then [=exception/throw=] a {{TypeError}}.
        1. Set |requestSize| to |requestSize| + |buyerConfig|'s [=auction data buyer config/size=].
  1. If |configIDL|["{{AdAuctionDataConfig/seller}}"] [=map/exists=]:
    1. Let |seller| be the result of running [=parse an https origin=] on
       |configIDL|["{{AdAuctionDataConfig/seller}}"].
    1. If |configIDL|["{{AdAuctionDataConfig/coordinatorOrigin}}"] [=map/exists=]:
      1. Let |coordinator| be the result of running [=parse an https origin=] on
        |configIDL|["{{AdAuctionDataConfig/coordinatorOrigin}}"].
    1. Otherwise
      1. Let |coordinator| be the [=user agent=]'s default Bidding and Auction Services coordinator.
    1. If |seller| or |coordinator| are failure, then [=exception/throw=] a {{TypeError}}.
    1. Let |config| be a new [=auction data config=] with the following [=struct/items=]:
      : [=auction data config/publisher=]
      :: |top_level_origin|
      : [=auction data config/seller=]
      :: |seller|
      : [=auction data config/coordinator=]
      :: |coordinator|
      : [=auction data config/request size=]
      :: |requestSize|
      : [=auction data config/per buyer config=]
      :: |perBuyerConfigs|
    1. [=list/Append=] |config| to |configs|.
  1. Otherwise:
    1. If |configIDL|["{{AdAuctionDataConfig/sellers}}"] does not [=map/exist=], then [=exception/throw=] a {{TypeError}}.
    1. If |configIDL|["{{AdAuctionDataConfig/coordinatorOrigin}}"] [=map/exists=], then [=exception/throw=] a {{TypeError}}.
    1. [=list/For each=] |sellerConfig| in |configIDL|["{{AdAuctionDataConfig/sellers}}"]:
      1. Let |seller| be the result of running [=parse an https origin=] on
        |sellerConfig|["{{AdAuctionOneSeller/seller}}"].
      1. If |configs| [=list/contains=] an [=auction data config=] whose
         [=auction data config/seller=] is equal to |seller|, then
         [=exception/throw=] a {{TypeError}}.
      1. If |sellerConfig|["{{AdAuctionOneSeller/coordinatorOrigin}}"] [=map/exists=]:
        1. Let |coordinator| be the result of running [=parse an https origin=] on
          |sellerConfig|["{{AdAuctionOneSeller/coordinatorOrigin}}"].
      1. Otherwise:
        1. Let |coordinator| be the [=user agent=]'s default Bidding and Auction Services coordinator.
      1. If |seller| or |coordinator| are failure, then [=exception/throw=] a {{TypeError}}.
      1. Let |config| be a new [=auction data config=] with the following [=struct/items=]:
        : [=auction data config/publisher=]
        :: |top_level_origin|
        : [=auction data config/seller=]
        :: |seller|
        : [=auction data config/coordinator=]
        :: |coordinator|
        : [=auction data config/request size=]
        :: |requestSize|
        : [=auction data config/per buyer config=]
        :: |perBuyerConfigs|
      1. [=list/Append=] |config| to |configs|.
  1. Return |configs|.
</div>

<div algorithm>
  To <dfn>parse per buyer auction data configs</dfn> given an
  {{AdAuctionDataBuyerConfig}} |perBuyerConfigIDL|:
  1. Let |configs| be a new [=ordered map=] whose [=map/keys=] are [=origins=]
     and whose [=map/values=] are [=auction data configs=].
  1. [=map/For each=] |buyerIDL| → |buyerConfigIDL| of |perBuyerConfigIDL|:
    1. Let |buyerConfig| be a new [=auction data buyer config=].
    1. Set |buyerConfig|'s [=auction data buyer config/size=] to
       |buyerConfigIDL|["{{AdAuctionDataBuyerConfig/targetSize}}"] if it
       [=map/exists=], null otherwise.
    1. Let |buyer| be the result of running [=parse an https origin=] on |buyerIDL|.
    1. If |buyer| is failure, then [=exception/throw=] a {{TypeError}}.
    1. [=map/Set=] |configs|[|buyer|] to |buyerConfig|.
  1. Return |configs|.
</div>

<div algorithm>
  To <dfn>look up the server encryption key</dfn> given an [=origin=] |origin|
  and an [=origin=] |coordinator|:
  1. Let |keys| be a [=list=] of ([=byte sequence=], [=byte=]) [=tuples=] returned
     from looking up the [[RFC9180|HPKE]] public key encryption keys and their
     corresponding key IDs for |origin| specified by |coordinator|. The actual
     implementation of this lookup is [=implementation-defined=], and may
     consist of fetching the keys from a known [=URL=].
  1. If |keys| is failure or |keys| [=list/is empty=], return failure.
  1. Return an element from |keys|, chosen at random.
</div>

# Reporting # {#reporting}

## Common types and algorithms ## {#reporting-common}

A <dfn>reporting bid source</dfn> is an enum with the following possible values:
<dl dfn-for="reporting bid source">
: <dfn>`generate-bid`</dfn>
:: Bid produced by an invocation of `generateBid()`.
: <dfn>`additional-bid`</dfn>
:: Bid provided via [=validate and convert additional bids|the additional bids=] mechanism.
: <dfn>`bidding-and-auction-services`</dfn>
:: Bid provided via [=parse and validate server response|Bidding and Auction Services=] mechanism.

</dl>

A <dfn>reporting bid key</dfn> is a [=struct=] with the following [=struct/items=]:

  Note: This [=struct=] exists only to uniquely identify places bids came from, avoiding confusion
  in cases like bids made by the same interest group in different component auctions, or additional
  bids reusing names of regular interest groups. Implementations can likely find a more efficient
  way of achieving the same effect. Note that bids returned when `generateBid()` returns multiple
  items all share a key, as they share reporting information, too.

<dl dfn-for="reporting bid key">
  : <dfn>context</dfn>
  :: The [=reporting context=] corresponding to the component (or single-level) auction the bid
    originated in.
  : <dfn>source</dfn>
  :: A [=reporting bid source=] describing where the bid came from.
  : <dfn>bidder origin</dfn>
  :: The [=origin=] of the bidder.
  : <dfn>bid identifier</dfn>
  :: A [=string=] distinguishing this source of reports from others of the same origin in the same
    [=reporting bid key/context=].
</dl>

A <dfn>reporting context</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="reporting context">
  : <dfn>debug reporting info</dfn>
  :: A [=map=] from [=reporting bid key=] to [=bid debug reporting info=].
  : <dfn>private aggregation batching scope map</dfn>
  :: A [=map=] from a [=tuple=] consisting of an <dfn ignore>origin</dfn> (an
    [=origin=]) and a <dfn ignore>coordinator</dfn> (an [=aggregation
    coordinator=]) to a [=batching scope=].

    Note: Does not include [=batching scopes=] for contributions conditional on
        non-reserved events.
  : <dfn>private aggregation on event contributions</dfn>
  :: A [=map=] from a tuple of ([=reporting bid key=], [=string=]) to a [=list=] of [=on event
    contribution entries=].
  : <dfn>private aggregation allowed</dfn>
  :: A [=boolean=], initially false.
  : <dfn>local leader info</dfn>
  :: A [=leading bid info=], describing information on what, if anything, won the particular
    auction this [=reporting context=] is for.
  : <dfn>winner reporting id</dfn>
  :: A [=reporting bid key=] or null, initially null. This can be null even if [=reporting context/
    local leader info=] has a leader set, in case this context is for a component auction that lost
    at top-level.
  : <dfn>bidder participants</dfn>
  :: A [=set=] of [=reporting bid keys=], representing interest groups that got a chance to generate
    bids for the auction. This will be empty in top-level auctions, as the relevant state will be
    in the component auctions.
  : <dfn>seller participants</dfn>
  :: A [=set=] of [=reporting bid keys=], representing various `scoreAd()` executions. Note that
    some of these may be based on bids that started as additional bids or from component auctions
    run by Bidding and Auction services, and not interest groups, so this list may be quite
    different from [=reporting context/bidder participants=].
  : <dfn>participant metrics</dfn>
  :: A [=map=] from a pair ([=origin=], [=worklet function=]) to [=per participant metrics=].
</dl>

<div algorithm>
To <dfn>access per-participant metrics</dfn> given a [=reporting context=] |reportingContext|,
an [=origin=] |origin| and [=worklet function=] |workletFunction|:
1. Let |key| be (|origin|, |workletFunction|).
1. If |reportingContext|'s [=reporting context/participant metrics=][|key|] does not [=map/exist=],
  set it to a new [=per participant metrics=].
1. Return |reportingContext|'s [=reporting context/participant metrics=][|key|].

</div>

A <dfn>reporting context map</dfn> is a [=map=] from [=auction config=] to [=reporting context=].

<div algorithm>
  To <dfn>create a reporting context map</dfn> given the [=auction config=] |auctionConfig| and
  a [=boolean=] |privateAggregationAllowed|:
  1. Let |reportingContextMap| be a new [=reporting context map=].
  1. [=map/Set=] |reportingContextMap|[|auctionConfig|] to a new [=reporting context=].
  1. [=list/For each=] |component| in |auctionConfig|'s
    [=auction config/component auctions=], [=map/set=] |reportingContextMap|[|component|] to a new
    [=reporting context=].
  1. [=map/For each=] _ → |reportingContext| of |reportingContextMap|:
    1. Set |reportingContext|'s [=reporting context/private aggregation allowed=] to
      |privateAggregationAllowed|
  1. Return |reportingContextMap|.
</div>

<div algorithm>
  To <dfn>register bids for reporting</dfn> given a [=list=] of
  [=generated bids=] |generatedBids|, [=interest group=] |ig|, [=bid debug reporting info=]
  |bidDebugReportInfo|, a [=Private Aggregation contributions=] |paContributions|,
  [=execution metrics=] |executionMetrics| and a [=reporting context=] |reportingContext|:
  1. Let |id| be a new [=reporting bid key=] with the following [=struct/items=]:
    : [=reporting bid key/context=]
    :: |reportingContext|

    : [=reporting bid key/source=]
    :: [=reporting bid source/generate-bid=]

    : [=reporting bid key/bidder origin=]
    :: |ig|'s [=interest group/owner=]

    : [=reporting bid key/bid identifier=]
    :: |ig|'s [=interest group/name=]
  1. [=map/Set=] |reportingContext|'s [=reporting context/debug reporting info=][|id|] to
    |bidDebugReportInfo|.
  1. Let |metrics| be the result of [=access per-participant metrics=] given |reportingContext|,
    |ig|'s [=interest group/owner=], [=worklet function/generate-bid=].
  1. [=Merge samples to an averager=] given |metrics|'s [=per participant metrics/code fetch time
    averager=] and |executionMetrics|'s [=execution metrics/code fetch time averager=].
  1. Set |metrics|'s [=per participant metrics/script executions attempted=] to
    |metrics|'s [=per participant metrics/participating interest group count=].
  1. If |executionMetrics|'s [=execution metrics/script timed out=] is true, increment |metrics|'s
    [=per participant metrics/script timeouts occurred=] by 1.
  1. [=set/Insert=] |id| into |reportingContext|'s [=reporting context/bidder participants=].
  1. [=Commit private aggregation contributions=] given |paContributions|, |id| and
    |reportingContext|.
  1. [=list/For each=] |generatedBid| of |generatedBids|:
    1. Set |generatedBid|'s [=generated bid/reporting id=] to |id|.

</div>

## {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}} ## {#for-debugging-only-header}

*This first introductory paragraph is non-normative.*

"`generateBid()`" and "`scoreAd()`" can call
{{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}}'s
{{ForDebuggingOnly/reportAdAuctionWin(url)}} and {{ForDebuggingOnly/reportAdAuctionLoss(url)}}
methods for event-level <dfn>forDebuggingOnly reports</dfn> for winning and losing bids.

<div algorithm>
  To <dfn>collect a single forDebuggingOnly report</dfn> given a [=URL=] |reportUrl|, an [=origin=]
  |invokingOrigin|, a [=boolean=] |fromServer|, and a [=list=] |debugReportUrls|:

  Note: While the browser is experimenting with third party cookie deprecation (before they have
  been fully removed), the {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}}
  reporting APIs supply temporary labels indicating when a particular instance would have been
  downsampled instead of using the following steps to downsample it.

  1. If |reportUrl| is null, or the result of running [=is debugging only in cooldown or lockout=]
    with |invokingOrigin| is true, then return.
  1. If the result of running [=sample a debug report=] with |invokingOrigin| and |fromServer| is
    true, then [=list/append=] |reportUrl| to |debugReportUrls|.
</div>

<div algorithm>
  To <dfn>collect forDebuggingOnly reports</dfn> given a [=reporting context map=]
  |reportingContextMap|, [=origin=] |seller|, and [=leading bid info=]-or-null |winnerInfo|:

  1. Let |auctionReportInfo| be a new [=auction report info=].
  1. Let |winningBid| be |winnerInfo|'s [=leading bid info/leading bid=] if |winnerInfo| is
    not null, null otherwise.
  1. [=map/For each=] _ → |reportingContext| of |reportingContextMap|:
    1. [=map/For each=] |reportingId| -> |bidDebugReportInfo| of |reportingContext|'s
      [=reporting context/debug reporting info=]:
      1. Let |fromServer| be true if |reportingId|'s [=reporting bid key/source=] is
        [=reporting bid source/bidding-and-auction-services=], false otherwise.
      1. If |winningBid| is not null and |reportingId| is equal to |winningBid|'s
        [=generated bid/reporting id=]:
        1. [=Assert=] that |winningBid|'s [=generated bid/reporting id=] is not null.
        1. [=Collect a single forDebuggingOnly report=] with |bidDebugReportInfo|'s
          [=bid debug reporting info/bidder debug win report url=], |bidDebugReportInfo|'s
          [=bid debug reporting info/interest group owner=], |fromServer|, and |auctionReportInfo|'s
          [=auction report info/debug win report urls=].
        1. If |bidDebugReportInfo|'s [=bid debug reporting info/component seller=] is null:
          1. [=Collect a single forDebuggingOnly report=] with |bidDebugReportInfo|'s
            [=bid debug reporting info/seller debug win report url=], |seller|, |fromServer|, and
            |auctionReportInfo|'s [=auction report info/debug win report urls=].
        1. Otherwise:
          1. [=Collect a single forDebuggingOnly report=] with |bidDebugReportInfo|'s
            [=bid debug reporting info/seller debug win report url=], |bidDebugReportInfo|'s
            [=bid debug reporting info/component seller=], |fromServer|, and |auctionReportInfo|'s
            [=auction report info/debug win report urls=].
          1. [=Collect a single forDebuggingOnly report=] with |bidDebugReportInfo|'s
            [=bid debug reporting info/top level seller debug win report url=], |seller|, |fromServer|,
            and |auctionReportInfo|'s [=auction report info/debug win report urls=].
      1. Otherwise:
        1. [=Collect a single forDebuggingOnly report=] with |bidDebugReportInfo|'s
          [=bid debug reporting info/bidder debug loss report url=], |bidDebugReportInfo|'s
          [=bid debug reporting info/interest group owner=], |fromServer|, and |auctionReportInfo|'s
          [=auction report info/debug loss report urls=].
        1. If |bidDebugReportInfo|'s [=bid debug reporting info/component seller=] is null:
          1. [=Collect a single forDebuggingOnly report=] with |bidDebugReportInfo|'s
            [=bid debug reporting info/seller debug loss report url=], |seller|, |fromServer|, and
            |auctionReportInfo|'s [=auction report info/debug loss report urls=].
        1. Otherwise:
          1. [=Collect a single forDebuggingOnly report=] with |bidDebugReportInfo|'s
            [=bid debug reporting info/seller debug loss report url=], |bidDebugReportInfo|'s
            [=bid debug reporting info/component seller=], |fromServer|, |auctionReportInfo|'s
            [=auction report info/debug loss report urls=].
          1. [=Collect a single forDebuggingOnly report=] with |bidDebugReportInfo|'s
            [=bid debug reporting info/top level seller debug loss report url=], |seller|,
            |fromServer|, and |auctionReportInfo|'s [=auction report info/debug loss report urls=].
      1. [=map/For each=] |invokingOrigin| → |debugURLs| of |bidDebugReportInfo|'s
        [=bid debug reporting info/server filtered debugging only reports=]:
        1. If |debugURLs| [=list/is empty=]:
          1. If the result of running [=is debugging only in cooldown or lockout=] with
            |invokingOrigin| is false, then [=update debug report cooldown=] with |invokingOrigin|.
          1. [=iteration/Continue=].

          Note: An entry for |invokingOrigin| is still needed when |debugURLs| is empty. It could
            happen when forDebuggingOnly API is called but the bidding and auction server
            filtered the debug report URL out with the downsampling algorithm. In this case the
            client still needs to know that forDebuggingOnly API was called and update its cooldown
            information. This is different from forDebuggingOnly API not being called by one origin,
            in which case the list won't have an entry for that origin.
        1. [=list/For each=] |url| of |debugURLs|:
          1. [=Collect a single forDebuggingOnly report=] with |url|, |invokingOrigin|,
            |fromServer| (true), and |auctionReportInfo|'s [=auction report info/debug loss report urls=].

            Note: For server filtered ones, post auction signals were filled on the server side, so
              it's fine to collect them all to [=auction report info/debug loss report urls=] without
              the need of getting post auction signals for debug win urls.
  1. Return |auctionReportInfo|.
</div>

### Downsampling ### {#downsampling-header}

*This first introductory paragraph is non-normative.*

Implementations may define their own values for the below constants based on their privacy goal,
however we supply the below values as a starting point, inspired by what the initial implementation
of this specification uses:
  * <dfn>sampling rate</dfn> is 1/1000, which means only sending reports 1/1000 times the
    {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}} API is called.
  * <dfn>lockout period</dfn> is 3 years.
  * <dfn>long cooldown rate</dfn> is 1/10, which means 10% of the time putting an adtech in a long
    cooldown period if the adtech calls the API.
  * <dfn>long cooldown period</dfn> is 1 year.
  * <dfn>short cooldown period</dfn> is 2 weeks.

Note: More details of how these numbers are determined can be found in comments here:
(<a href="https://github.com/WICG/turtledove/issues/632">WICG/turtledove#632</a>).

The design of downsampling [=forDebuggingOnly reports=] has three main goals:
* Prevent sending debug reports very often to protect user privacy:
  * Only sending debug reports [=sampling rate=] times the forDebuggingOnly API is called;
  * if a report is sent, "lock-out" all adtechs out of sending a report for [=lockout period=];
  * if an adtech calls the API, put them in a "cool-down" period where calls to the API by that
    given adtech are not able to send reports.
* Prevent one adtech from substantially compromising a different adtech's access to debugging
  information. The "cool-down" period means that any particular adtech can only cause a very small
  fraction of people to send debug reports and be removed from the potential debugging pool.
* Prevent adtechs who accidentally (e.g. due to a bug in their code) call the API repeatedly for all
  users, from locking themselves out of sending any more reports for years. This is accomplished by
  only [=long cooldown rate=] of the time putting that adtech in a [=long cooldown period=], and
  rest of the time putting that adtech in a [=short cooldown period=].

The [=user agent=] has a <dfn>debug report lockout until</dfn>, which is null or a [=moment=], and
a <dfn>debug report cooldown</dfn>, which is null or a [=map=] whose [=map/keys=] are [=origins=]
and [=map/values=] are [=moments=] at which the cool down for the origin key expires.

<div algorithm>
  To <dfn>is debugging only in cooldown or lockout</dfn> given an [=origin=] |origin|:

  1. If [=user agent=]'s [=debug report lockout until=] is not null, and [=current coarsened wall
    time=] is less than [=user agent=]'s [=debug report lockout until=], return true.
  1. If [=user agent=]'s [=debug report cooldown=] is null, then return false.
  1. If [=user agent=]'s [=debug report cooldown=][|origin|] [=map/exists=] and [=current coarsened
    wall time=] is less than [=user agent=]'s [=debug report cooldown=][|origin|], then return true.
  1. Return false.
</div>

<div algorithm>
  To <dfn>sample a debug report</dfn> given an [=origin=] |origin| and a [=boolean=] |fromServer|:

  Note: forDebuggingOnly reports from [=server auction response=] were downsampled on trusted
    auction servers, so do not downsample them again on client.
  1. Let |canSendAfterSampled| be false.
  1. Let |sampleRand| be a random {{long}}, 0 &le; |sampleRand| &lt; 1000, so each possible long would be
    chosen with a probability equal to [=sampling rate=].
  1. If |fromServer| is true or |sampleRand| is 0:
    1. Set |canSendAfterSampled| to true.
    1. Set [=user agent=]'s [=debug report lockout until=] to [=current coarsened wall time=] plus
      [=lockout period=].
  1. [=Update debug report cooldown=] with |origin|.
  1. Return |canSendAfterSampled|.
</div>

<div algorithm>
  To <dfn>update debug report cooldown</dfn> given an [=origin=] |origin|:

  1. Let |cooldownRand| be a random {{long}} &ge; 0 and &lt; 10, which corresponds to
    [=long cooldown rate=].
  1. Let |cooldownPeriod| be [=long cooldown period=] if |cooldownRand| is 0,
    [=short cooldown period=] otherwise.
  1. Set [=user agent=]'s [=debug report cooldown=][|origin|] to [=current coarsened wall time=]
    plus |cooldownPeriod|.
</div>

## {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/realTimeReporting}} ## {#real-time-reporting-header}

*This first introductory paragraph is non-normative.*

The goal of real-time reporting is to get auction monitoring data to the buyer and seller as quickly
as possible (e.g. &lt; 5 mins). The primary use-case is rapid error detection i.e. detecting quickly
whether there are major problems with unexpected behavior in `generateBid()`, `scoreAd()`, or
fetching of bidding or scoring scripts or trusted signals.

Initial implementation of this specification defines
  * <dfn>number of user buckets</dfn> is 1024, which means buckets 0 to 1023 are supported by
    {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/realTimeReporting}} API.
  * <dfn>number of platform buckets</dfn> is 4, which are buckets for errors that are not visible in
    either `scoreAd()` or `generateBid()`.

<div id="real-time-report-example" class=example>
  <p> Each real time report is a [[RFC8949|CBOR]] message using the following data structure:</p>
  <pre highlight="js">
  {
    "version": 1,
    "histogram": {
      "buckets": [5, 32, 0, 1, ..., 129],  // 128 elements.
      "length": 1024    // 1024 buckets before bit packing.
    },
    "platformHistogram": {
      "buckets": [192],
      "length": 4  // 4 buckets before bit packing.
    }
  }
  </pre>
</div>

<div algorithm>
  To <dfn>sample real time contributions</dfn> given a [=list=] of
  [=real time reporting contributions=] |contributions|, perform the following steps. They return an
  integer or null:

  1. If |contributions| [=list/is empty=], then return null.
  1. Let |priorityWeightSum| be 0.
  1. [=list/For each=] |contribution| of |contributions|:
    1. Increment |priorityWeightSum| by |contribution|'s
      [=real time reporting contribution/priority weight=].
  1. Let |sampleRand| be a random {{double}}, 0 &le; sampleRand &lt; 1.
  1. Set |sampleRand| to |sampleRand| multiplied by |priorityWeightSum|.
  1. Set |priorityWeightSum| to 0.
  1. Let |selectedBucket| be -1.
  1. [=list/For each=] |contribution| of |contributions|:
    1. Increment |priorityWeightSum| by |contribution|'s
      [=real time reporting contribution/priority weight=].
    1. If |priorityWeightSum| &ge; |sampleRand|, then set |selectedBucket| to |contribution|'s
      [=real time reporting contribution/bucket=], and [=iteration/break=];
  1. [=Assert=] |selectedBucket| is not -1.
  1. Return |selectedBucket|.
</div>

<div algorithm>
  To <dfn>bit pack</dfn> a [=list=] of [=booleans=] |input|:

  1. Let |inputSize| be |input|'s [=list/size=].
  1. Let |packed| be a new [=list=] of [=bytes=].
  1. Let |currentByte| be 0.
  1. Let |numBits| be 0.
  1. [=list/For each=] |i| in [=the range=] from 0 to |inputSize|, exclusive:
    1. Set |currentByte| to |currentByte| * 2 + |input|[|i|].
    1. Increment |numBits| by 1.
    1. If |numBits| is 8, then:
      1. [=list/Append=] |currentByte| to |packed|.
      1. Set |currentByte| to 0 and |numBits| to 0.
    1. Otherwise if |i| is |inputSize| - 1, then:
      1. [=iteration/While=] |numBits| &lt; 8:
        1. Set |currentByte| to |currentByte| * 2.
        1. Increment |numBits| by 1.
      1. [=list/Append=] |currentByte| to |packed|.
  1. [=Assert=] that |packed|'s [=list/size=] is (|inputSize| + 7) / 8.0.
  1. Return |packed|.
</div>

<div algorithm>
  To <dfn>send a real time report</dfn> given a [=URL=] |url|, a [=list=] of [=booleans=]
  |histogram|, and an [=environment settings object=] |settings|:

  1. Let |totalBuckets| be the sum of [=number of user buckets=] and [=number of platform buckets=].
  1. [=Assert=] |histogram|'s [=list/size=] is |totalBuckets|.
  1. Let |userHistogram| and |platformHistogram| be new [=lists=] of [=booleans=].
  1. [=list/For each=] |i| in [=the range=] 0 to |totalBuckets|, exclusive:
    1. If |i| &lt; |userHistogram|, then [=list/append=] |histogram|[|i|] to |userHistogram|.
    1. Otherwise, [=list/append=] |histogram|[|i|] to |platformHistogram|.

  1. Let |body| be a new [=ordered map=] of the following [=map/entries=]:
    :   "version"
    ::  1
    :   "histogram"
    ::  a new [=ordered map=] of the following [=map/entries=]:
      :   "buckets"
      ::  the result of [=bit packing=] with |userHistogram|
      :   "length"
      ::  [=number of user buckets=]
    :   "platformHistogram"
    ::  a new [=ordered map=] of the following [=map/entries=]:
      :   "buckets"
      ::  the result of [=bit packing=] with |platformHistogram|
      :   "length"
      ::  [=number of platform buckets=]
  1. Let |request| be a new [=request=] with the following properties:
    :   [=request/URL=]
    ::  |url|
    :   [=request/header list=]
    ::  «`Content-Type`: `application/cbor`»
    :   [=request/method=]
    ::  `POST`
    :   [=request/body=]
    ::  the [=byte sequence=] resulting from [[RFC8949#name-specification-of-the-cbor-e|CBOR encoding]]
        |body|
    :   [=request/client=]
    ::  `null`
    :   [=request/origin=]
    ::  |settings|'s [=environment settings object/origin=]
    :   [=request/mode=]
    ::  "`no-cors`"
    :   [=request/referrer=]
    ::  "`no-referrer`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/redirect mode=]
    ::  "`error`"
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/policy container=]
    ::  A new [=policy container=] whose [=policy container/IP address space=] is |settings|'s
      [=environment settings object/policy container=]'s [=policy container/IP address space=]

    Issue: Stop using "`no-cors`" mode where possible
    (<a href="https://github.com/WICG/turtledove/issues/667">WICG/turtledove#667</a>).
  1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true.
</div>

<div algorithm>
  To <dfn>send real time reports</dfn> given a [=real time reporting contributions map=]
  |contributionsMap| and an [=environment settings object=] |settings|:

  1. [=map/For each=] |origin| → |contributions| of |contributionsMap|:
    1. Let |maybeBucket| be the result of [=sampling real time contributions=] with |contributions|.
    1. Let |histogram| be the result of [=applying RAPPOR noise=] with |maybeBucket|.
    1. Let |reportUrl| be a new [=URL=] with the following [=struct/items=]:
      :   [=url/scheme=]
      ::  |origin|'s [=origin/scheme=]
      :   [=url/host=]
      ::  |origin|'s [=origin/host=]
      :   [=url/port=]
      ::  |origin|'s [=origin/port=]
      :   [=url/path=]
      ::  « ".well-known", "interest-group", "real-time-report" »
    1. [=Send a real time report=] with |reportUrl|, |histogram| and |settings|.

      Issue: TODO: Spec rate limiting.
      (<a href="https://github.com/WICG/turtledove/issues/1215">WICG/turtledove#1215</a>)
</div>


### Platform contribution ### {#platform-contribution-header}

*This first introductory paragraph is non-normative.*

There are some errors not visible in either `scoreAd()` or `generateBid()`, like failures to fetch
the bidding or scoring script, trusted bidding or scoring signals. Certain buckets are used for
these errors.

The initial implementation supports four <dfn>platform contribution buckets</dfn> starting from
[=number of user buckets=]:
* <dfn>bidding script failure bucket</dfn>: [=number of user buckets=]
* <dfn>scoring script failure bucket</dfn>: [=number of user buckets=] plus 1
* <dfn>trusted bidding signals failure bucket</dfn>: [=number of user buckets=] plus 2
* <dfn>trusted scoring signals failure bucket</dfn>: [=number of user buckets=] plus 3

Platform contributions have a hardcoded <dfn>platform contribution priority weight</dfn>. The
initial implementation uses a value of 1.

<div algorithm>
  To <dfn>add a platform contribution</dfn> given a {{long}} |bucket|, a
  [=real time reporting contributions map=] |realTimeContributionsMap|, and an [=origin=] |origin|:

  1. [=Assert=] |bucket| is one of [=platform contribution buckets=].
  1. Let |contribution| be a new [=real time reporting contribution=] with the following [=struct/items=]:
    : [=real time reporting contribution/bucket=]
    :: |bucket|
    : [=real time reporting contribution/priority weight=]
    :: [=platform contribution priority weight=]
  1. [=Insert entries to map=] given |realTimeContributionsMap|, |origin|, and « |contribution| » .
</div>

### Apply noise (RAPPOR) ### {#rappor-header}

*This first introductory paragraph is non-normative.*

Basic <a href=https://research.google/pubs/rappor-randomized-aggregatable-privacy-preserving-ordinal-response>
RAPPOR</a> noises each coordinate of the bit vector independently, and it is parameterized by
<dfn>epsilon</dfn>, a measure of privacy loss. The initial implementation uses an [=epsilon=] value of
1, yielding a flipping probability of ~0.378.

<div algorithm>
  To <dfn>apply RAPPOR noise</dfn> given an integer-or-null |maybeBucket|:

  1. Let |totalBuckets| be the sum of [=number of user buckets=] and [=number of platform buckets=].
  1. Let |histogram| be a new [=list=] of [=booleans=], whose [=list/size=] is |totalBuckets|.
  1. If |maybeBucket| is not null:
    1. [=Assert=] 0 &le; |maybeBucket| &lt; |totalBuckets|.
    1. Set |histogram|[|maybeBucket|] to true.
  1. Let |f| be <code><span class="math">2.0/(1+e<sup>[=epsilon=]/2.0</sup>)</span></code>.
  1. [=list/For each=] |i| in [=the range=] from 0 to |totalBuckets|, exclusive:
    1. Let |rand| be a random {{double}}, 0 &le; |rand| &lt; 1
    1. If |rand| &lt; |f| / 2.0, then:
      1. Let |flipped| be false if |histogram|[|i|] is true, otherwise true.
      1. Set |histogram|[|i|] to |flipped|.
  1. Return |histogram|.
</div>

## {{InterestGroupScriptRunnerGlobalScope/privateAggregation}} ## {#private-aggregation-reporting-header}

*This first introductory paragraph is non-normative.*

For metrics that can be interpreted as histograms aggregated over the entire population, Protected
Audience provides integration with the [Private Aggregation API](https://github.com/patcg-individual-drafts/private-aggregation-api).
In addition to its {{PrivateAggregation/contributeToHistogram(contribution)}} method, the API is
extended with <a method for="PrivateAggregation">contributeToHistogramOnEvent(event, contribution)</a>
which permits histogram contributions to be conditional and to incorporate values not accessible to
the running script, like values of auction winning bids and various performance metrics.

<h4 dfn-type=dfn>Signal base value</h4>
A signal base value is one of the following:
<dl dfn-for="signal base value">
: "<dfn><code>winning-bid</code></dfn>"
:: The numeric value is the bid value of the winning bid.
: "<dfn><code>highest-scoring-other-bid</code></dfn>"
:: The numeric value is the bid value of the highest scoring bid that did not
    win.
: "<dfn><code>script-run-time</code></dfn>"
:: The numeric value is the number of milliseconds of CPU time the calling
    function (e.g. `generateBid()`) took to run.
: "<dfn><code>signals-fetch-time</code></dfn>"
:: The numeric value is the number of milliseconds it took for the trusted
    bidding or scoring signals fetch to complete, when called from
    `generateBid()` or `scoreAd()`, respectively. In other functions it evaluates to 0.
: "<dfn><code>bid-reject-reason</code></dfn>"
:: The numeric value is an integer representing the reason a bid was rejected.

    Note: this mapping to an integer is defined in [=determine a signal's numeric value=].

: "<dfn><code>average-code-fetch-time</code></dfn>"
:: The numeric value is the average time it took to fetch code resources (JavaScript or WebAssembly)
  for this particular worklet function, for this participant.
: "<dfn><code>participating-ig-count</code></dfn>"
:: The numeric value is the number of interest groups for the buyer actually participating in the
  auction, after considering prioritization and capabilities. Interest groups included in this might
  not actually get to bid if the cumulative timeout expires, or the script fails to load, etc; or
  might decide not to bid, but they would have gotten a chance if nothing went wrong.
: "<dfn><code>percent-scripts-timeout</code></dfn>"
:: The numeric value is percentage of executions of this script that hit their individual timeout,
  out of all executions that were expected to happen.
: "<dfn><code>regular-igs-count</code></dfn>"
:: Number of [=regular interest groups=] for the given buyer. (0 if this is used by a seller).
: "<dfn><code>percent-regular-ig-count-quota-used</code></dfn>"
:: Ratio of number of [=regular interest groups=] for the given buyer and [=Max regular interest
  groups per owner=] expressed as a percentage, capped to 110.
: "<dfn><code>negative-igs-count</code></dfn>"
:: Number of [=negative interest groups=] for the given buyer. (0 if this is used by a seller).
: "<dfn><code>percent-negative-ig-count-quota-used</code></dfn>"
:: Ratio of number of [=negative interest groups=] for the given buyer and [=Max negative interest
  groups per owner=] expressed as a percentage, capped to 110.
: "<dfn><code>ig-storage-used</code></dfn>"
:: Bytes of storage used by the given buyer. (0 if this is used by a seller).
: "<dfn><code>percent-ig-storage-quota-used</code></dfn>"
:: Percentage of [=max interest groups total size per owner=] used by the given buyer,
  capped to 110.
: "<dfn><code>cumulative-buyer-time</code></dfn>"
:: Time spent by the buyer from their cumulative buyer timeout limit; if the limit has been exceeded
  returns the limit + 1000; if this is used by a seller, or no cumulative buyer timeout is
  configured, returns 0.
: "<dfn><code>percent-igs-cumulative-timeout</code></dfn>"
:: Percentage of participating interest groups that did not get a chance to actually bid in the
  auction due to a cumulative buyer timeout occurring.

</dl>

<h4 dfn-type=dfn>On event contribution entry</h4>
An on event contribution entry is a [=struct=] with the following items:
<dl dfn-for="on event contribution entry">
: <dfn>contribution</dfn>
:: A {{PAExtendedHistogramContribution}}
: <dfn>batching scope</dfn>
:: A [=batching scope=] or null
: <dfn>debug scope</dfn>
:: A [=debug scope=]
: <dfn>debug details</dfn>
:: A [=debug details=] or null (default null)
: <dfn>worklet function</dfn>
:: A [=worklet function=].
: <dfn>origin</dfn>
:: The [=origin=] of the script that contributed the entry.

</dl>

<h4 dfn-type=dfn>Worklet function</h4>
A worklet function is one of the following:
<dl dfn-for="worklet function">
: "<dfn><code>generate-bid</code></dfn>"
:: The `generateBid()` function.
: "<dfn><code>score-ad</code></dfn>"
:: The `scoreAd()` function.
: "<dfn><code>report-result</code></dfn>"
:: The `reportResult()` function.
: "<dfn><code>report-win</code></dfn>"
:: The `reportWin()` function, or `reportAdditionalBidWin()` for additional bids.

</dl>

<div algorithm>
To <dfn>find corresponding bid and score phase function</dfn> given a [=worklet function=] |fn|:

  1.Switch on |fn|:
    <dl class="switch">
    : [=worklet function/generate-bid=]
    :: Return [=worklet function/generate-bid=].
    : [=worklet function/score-ad=]
    :: Return [=worklet function/score-ad=].
    : [=worklet function/report-result=]
    :: Return [=worklet function/score-ad=].
    : [=worklet function/report-win=]
    :: Return [=worklet function/generate-bid=].

    </dl>
</div>

### Averager ### {#private-aggregation-averager}
An <dfn>averager</dfn> is a a [=struct=] with the following [=struct/items=]:
<dl dfn-for="averager">
  : <dfn>count</dfn>
  :: A {{long}}, initially 0.
  : <dfn>sum</dfn>
  :: A {{double}}, initially 0.
</dl>

<div algorithm>
To <dfn>add a sample to an averager</dfn> given an [=averager=] |averager|, a {{double}} |sample|:
1. Increment |averager|'s [=averager/count=] by 1.
1. Increment |averager|'s [=averager/sum=] by |sample|.

</div>

<div algorithm>
To <dfn>merge samples to an averager</dfn> given [=averagers=] |dest| and |source|:
1. Set |dest|'s [=averager/count=] to |dest|'s [=averager/count=] + |source|'s [=averager/count=].
1. Set |dest|'s [=averager/sum=] to |dest|'s [=averager/sum=] + |source|'s [=averager/sum=].

</div>

<div algorithm>
To <dfn>get the value to report from an averager</dfn> given an [=averager=] |averager|:
1. If |averager|'s [=averager/count=] is 0, return 0.
1. Return |averager|'s [=averager/sum=] / [=averager/count=].

</div>

### Metrics structures ### {#private-aggregation-metrics-structures}
An <dfn>execution metrics</dfn> is a [=struct=] with the following [=struct/items=], representing
metrics collected from a single execution of a worklet function:
<dl dfn-for="execution metrics">
  : <dfn>code fetch time averager</dfn>
  :: An [=averager=].
  : <dfn>script timed out</dfn>
  :: A [=boolean=], initially false. This refers to the script hitting its own time out, and does
    not include the cumulative timeout affecting buyers.
</dl>

A <dfn>per participant metrics</dfn> is a [=struct=] with the following [=struct/items=],
representing metrics aggregated over a particular participant (e.g. bidder or seller). It has:
<dl dfn-for="per participant metrics">
  : <dfn>participating interest group count</dfn>
  :: A {{long}}, initially 0. See "<code>[=signal base value/participating-ig-count=]</code>".
  : <dfn>code fetch time averager</dfn>
  :: An [=averager=]. Used to compute "<code>[=signal base value/average-code-fetch-time=]</code>".
  : <dfn>script timeouts occurred</dfn>
  :: A {{long}}, initially 0. Used to compute
    "<code>[=signal base value/percent-scripts-timeout=]</code>".
  : <dfn>cumulative timeouts occurred</dfn>
  :: A {{long}}, initially 0. Number of interest groups affected by the cumulative timeout
    happening. Used to compute "<code>[=signal base value/percent-igs-cumulative-timeout=]</code>".
  : <dfn>cumulative buyer time</dfn>
  :: A [=duration=] in milliseconds, initially 0.
    See "<code>[=signal base value/cumulative-buyer-time=]</code>".
  : <dfn>script executions attempted</dfn>
  :: A {{long}}, initially 0. The denominator for computation of some percentage metrics, such as
    "<code>[=signal base value/percent-scripts-timeout=]</code>" and
    "<code>[=signal base value/percent-igs-cumulative-timeout=]</code>".
  : <dfn>regular interest group count</dfn>
  :: A {{long}}, initially 0. See "<code>[=signal base value/regular-igs-count=]</code>" and
    "<code>[=signal base value/percent-regular-ig-count-quota-used=]</code>".
  : <dfn>negative interest group count</dfn>
  :: A {{long}}, initially 0. See "<code>[=signal base value/negative-igs-count=]</code>" and
    "<code>[=signal base value/percent-negative-ig-count-quota-used=]</code>".
  : <dfn>storage quota used</dfn>
  :: A {{long}}, initially 0. See "<code>[=signal base value/ig-storage-used=]</code>" and
    "<code>[=signal base value/percent-ig-storage-quota-used=]</code>".
</dl>

<h4 dfn-type=dfn>Private Aggregation contributions</h4>
Private Aggregation contributions is a [=map=] from [=string=] to a [=list=] of [=on event
contribution entries=].

### Algorithms ### {#private-aggregation-algorithms}

<div algorithm>
To <dfn>prepare for private aggregation</dfn> given a
{{InterestGroupScriptRunnerGlobalScope}} |global|, a [=worklet function=] |workletFunction|,
a [=reporting context=] |reportingContext|, and [=origins=] |origin| and |aggregationCoordinator|:
1. Let |debugScope| be a new [=debug scope=].
1. Set |global|'s [=InterestGroupScriptRunnerGlobalScope/worklet function=] to |workletFunction|.
1. Set |global|'s [=InterestGroupScriptRunnerGlobalScope/origin=] to |origin|.
1. Set |global|'s [=InterestGroupScriptRunnerGlobalScope/private aggregation=] to a new
  [=PrivateAggregation=] with the following [=struct/items=]:
    : <a spec="private-aggregation-api" for="PrivateAggregation">allowed to use</a>
    :: |reportingContext|'s [=reporting context/private aggregation allowed=].
    : <a spec="private-aggregation-api" for="PrivateAggregation">scoping details</a>
    :: a new [=scoping details=] with the [=struct/items=]:
      : <a spec="private-aggregation-api" for="scoping details">get batching scope steps</a>
      :: An algorithm that performs the following steps:
          1. If |aggregationCoordinator| is null, set |aggregationCoordinator| to
            the [=default aggregation coordinator=].
          1. Return the result of running [=get or create a batching scope=] given
              |origin|, |aggregationCoordinator| and |reportingContext|.
      : <a spec="private-aggregation-api" for="scoping details">get debug scope steps</a>
      :: An algorithm that returns |debugScope|.

</div>

<div algorithm>
To <dfn>finalize private aggregation debug info</dfn> given a
{{InterestGroupScriptRunnerGlobalScope}} |global|:
  1. Let |debugScope| be the result of running |global|'s {{InterestGroupScriptRunnerGlobalScope/
    privateAggregation}}'s
      <a spec="private-aggregation-api" for="PrivateAggregation">scoping details</a>'s
      <a spec="private-aggregation-api" for="scoping details">get debug scope steps</a>.
  1. Let |debugDetails| be the result of [=get a debug details=] given |debugScope|.
  1. Let |onEventContributionMap| be |global|'s [=InterestGroupScriptRunnerGlobalScope/on event
    contribution map=].
  1. [=map/For each=] <var ignore>event</var> → |entries| of |onEventContributionMap|:
    1. [=list/For each=] |onEventEntry| of |entries|:
        1. If |onEventEntry|'s [=on event contribution entry/debug scope=] is |debugScope|,
          set |onEventEntry|'s [=on event contribution entry/debug details=] to |debugDetails|.
  1. [=Mark a debug scope complete=] given |debugScope|.
</div>

<div algorithm>
To <dfn>extract private aggregation contributions</dfn> given a
{{InterestGroupScriptRunnerGlobalScope}} |global|:
  1. Return |global|'s [=InterestGroupScriptRunnerGlobalScope/on event contribution map=].

Issue: TODO: regular histograms need to work the same way, too, so they get discarded for k-anon
runs; this method exists as an abstraction to help add that.
</div>

<div algorithm>
To <dfn>commit private aggregation contributions</dfn> given a [=Private Aggregation
contributions=] |onEventMap|, a [=reporting bid key=] |bidKey|, and a [=reporting context=]
|reportingContext|:
  1. [=map/For each=] |event| → |contributions| of |onEventMap|:
    1. Let |key| be (|bidKey|, |event|).
    1. If |reportingContext|'s [=reporting context/private aggregation on event contributions=][|key|]
      does not [=map/exist=], set it to a new [=list=].
    1. [=list/Extend=] |reportingContext|'s [=reporting context/private aggregation on event
      contributions=][|key|] with |contributions|.
</div>

<div algorithm>
To <dfn>get or create a batching scope</dfn> given an [=origin=] |origin|, an
[=aggregation coordinator=] |aggregationCoordinator| and a [=reporting context=] |reportingContext|,
perform the following steps. They return a [=batching scope=].
1. Let |batchingScopeMap| be |reportingContext|'s [=reporting context/private aggregation
  batching scope map=].
1. Let |tuple| be (|origin|, |aggregationCoordinator|).
1. If |batchingScopeMap|[|tuple|] does not [=map/exist=]:
    1. Set |batchingScopeMap|[|tuple|] to a new [=batching scope=].
    1. If |aggregationCoordinator| is not null, [=set the aggregation coordinator for a batching
      scope=] given |aggregationCoordinator| and |batchingScopeMap|[|tuple|].
1. Return |batchingScopeMap|[|tuple|].

</div>

<div algorithm>
To <dfn>process the Private Aggregation contributions</dfn> given an [=auction config=]
|auctionConfig| and a [=reporting context map=] |reportingContextMap|:

1. [=Process the Private Aggregation contributions for an auction=] given |auctionConfig|,
  |reportingContextMap|[|auctionConfig|].
1. [=list/For each=] |componentAuction| in |auctionConfig|'s [=auction config/component
  auctions=]:
  1. [=Process the Private Aggregation contributions for an auction=] given |componentAuction|,
    |reportingContextMap|[|componentAuction|].

</div>

<div algorithm>
To <dfn>process the Private Aggregation contributions for an auction</dfn> given
an [=auction config=] |auctionConfig| and a [=reporting context=] |reportingContext|:

1. If |auctionConfig|'s [=auction config/aborted=] is true, return.
1. Let |winnerId| be |reportingContext|'s [=reporting context/winner reporting id=]
1. Let |leadingBidInfo| be |reportingContext|'s [=reporting context/local leader info=].
1. Let |bidderOnceRep| be null.
1. If |reportingContext|'s [=reporting context/bidder participants=] [=set/is not empty=],
  set |bidderOnceRep| to a random [=set/item=] of [=reporting context/bidder participants=].
1. Let |sellerOnceRep| be null.
1. If |reportingContext|'s [=reporting context/seller participants=] [=set/is not empty=],
  set |sellerOnceRep| to a random [=set/item=] of [=reporting context/seller participants=].
1. [=map/For each=] (|bidId|, |event|) → |contributions| of |reportingContext|'s
  [=reporting context/private aggregation on event contributions=]:
  1. [=list/For each=] |onEventEntry| of |contributions|:
    1. [=iteration/Continue=] if any of the following conditions hold:
      * |event| is "`reserved.win`" and |bidId| is not |winnerId|;
      * |event| does not [=string/start with=] "`reserved.`" and |bidId| is not |winnerId|;
      * |event| is "`reserved.loss`" and |bidId| is |winnerId|.
    1. If |event| is "`reserved.once`":
      1. If |onEventEntry|'s [=on event contribution entry/worklet function=] is [=worklet function/
        generate-bid=]:
        1. If |bidId| &ne; |bidderOnceRep|, [=iteration/continue=].
      1. Otherwise:
        1. If |bidId| &ne; |sellerOnceRep|, [=iteration/continue=].
    1. Let |filledInContribution| be the result of [=filling in the contribution=] given
      |reportingContext|, |onEventEntry| and |leadingBidInfo|.

      Issue: Once <a href="https://github.com/WICG/turtledove/issues/627">WICG/turtledove#627</a>
      is resolved, align 'filling in' logic with `forDebuggingOnly`.

    1. If |event| does not [=string/start with=] "`reserved.`":
      1. Store |event|, |filledInContribution|, |onEventEntry|'s [=on event contribution entry/debug
        details=] in the {{FencedFrameConfig}} as appropriate.

      Note: Each non-reserved |event| will have a different [=batching scope=].

      Issue: Once <a href="https://github.com/WICG/turtledove/issues/616">WICG/turtledove#616</a>
      and any successors are landed, align integration and fill in fenced frame's
      <a spec="fenced-frame">report a private aggregation event</a>.
    1. Otherwise:
      1. Let |entry| be a new [=contribution cache entry=] with the items:
          : <a spec="private-aggregation-api" for="contribution cache entry">contribution</a>
          :: |filledInContribution|
          : <a spec="private-aggregation-api" for="contribution cache entry">batching scope</a>
          :: |onEventEntry|'s [=on event contribution entry/batching scope=]
          : <a spec="private-aggregation-api" for="contribution cache entry">debug scope</a>
          :: |onEventEntry|'s [=on event contribution entry/debug scope=]
          : <a spec="private-aggregation-api" for="contribution cache entry">debug details</a>
          :: |onEventEntry|'s [=on event contribution entry/debug details=]
      1. [=Append an entry to the contribution cache|Append=] |entry| to the [=contribution cache=].
1. Let |sellerBatchingScope| be the result of [=get or create a batching
    scope|getting or creating a batching scope=] given |auctionConfig|'s [=auction config/seller=],
    |auctionConfig|'s [=auction config/seller Private Aggregation coordinator=], and
    |reportingContext|.
1. Let |auctionReportBuyersDebugScope| be a new [=debug scope=].
1. [=map/For each=] |reportType| → |reportBuyerConfig| of |auctionConfig|'s
  [=auction config/auction report buyers=]:
  1. [=map/For each=] |buyerOrigin| → |buyerOffset| of |auctionConfig|'s
    [=auction config/auction report buyer keys=]:
    1. Let |bucket| be the sum of |buyerOffset| and |reportBuyerConfig|'s
      {{AuctionReportBuyersConfig/bucket}}.

      Issue: Handle overflow here or in validation. See <a
        href="https://github.com/WICG/turtledove/issues/1040">WICG/turtledove#1040</a>.
    1. Let |value| be the result (a {{double}}) of switching on
        |reportType|:
        <dl class="switch">
        : "`interestGroupCount`"
        :: The number of interest groups in the [=user agent=]'s [=interest
           group set=] whose [=interest group/owner=] is |buyerOrigin|.
        : "`bidCount`"
        :: The number of valid bids generated by interest groups whose
            [=interest group/owner=] is |buyerOrigin|.
        : "`totalGenerateBidLatency`"
        :: The sum of execution time in milliseconds for all `generateBid()`
            calls in the auction for interest groups whose
            [=interest group/owner=] is |buyerOrigin|.
        : "`totalSignalsFetchLatency`"
        :: The total time spent fetching trusted buyer signals in
            milliseconds, or 0 if the interest group didn't fetch any
            trusted signals.
        : None of the above values
        :: [=Assert=]: false, as this enum value is validated in [=validate and convert auction
          ad config=]

        </dl>

        Issue: More formally spec the values here.

    1. Set |value| to the result of multiplying |reportBuyerConfig|'s
        {{AuctionReportBuyersConfig/scale}} with |value|.
    1. Set |value| to the maximum of 0.0 and |value|.
    1. Set |value| to the result of converting |value| to an integer by
        truncating its fractional part.
    1. Set |value| to the minimum of |value| and 2<sup>31</sup>−1.
    1. Let |contribution| be a new {{PAHistogramContribution}} with the
        items:
        : {{PAHistogramContribution/bucket}}
        :: |bucket|
        : {{PAHistogramContribution/value}}
        :: |value|
        : {{PAHistogramContribution/filteringId}}
        :: 0

          Issue: Consider allowing the filtering ID to be set here.
    1. [=map/For each=] |ig| of the [=user agent=]'s [=interest group set=] whose
        [=interest group/owner=] is |buyerOrigin|:
      1. If seller capabilities of |ig| don't allow this reporting, [=iteration/continue=].

        Issue: Align behavior with seller capabilities handling once <a
            href="https://github.com/WICG/turtledove/issues/966">
            WICG/turtledove#966</a> is resolved.
      1. Let |entry| be a new [=contribution cache entry=] with the items:
          : <a spec="private-aggregation-api" for="contribution cache entry">contribution</a>
          :: |contribution|
          : <a spec="private-aggregation-api" for="contribution cache entry">batching scope</a>
          :: |sellerBatchingScope|
          : <a spec="private-aggregation-api" for="contribution cache entry">debug scope</a>
          :: |auctionReportBuyersDebugScope|
      1. [=Append an entry to the contribution cache|Append=] |entry| to
          the [=contribution cache=].
1. [=Mark a debug scope complete=] given |auctionReportBuyersDebugScope| and
    |auctionConfig|'s [=auction config/auction report buyer debug details=].
1. [=map/For each=] (|origin|, <var ignore>aggregationCoordinator</var>) →
    |batchingScope| of |reportingContext|'s [=reporting context/private aggregation batching
    scope map=]:
  1. [=Process contributions for a batching scope=] given |batchingScope|, |origin|,
    "<code>protected-audience</code>" and null.

</div>

<div algorithm>
To <dfn>fill in the contribution</dfn> given a [=reporting context=] |reportingContext|,
an [=on event contribution entry=] |onEventEntry| and a [=leading bid info=] |leadingBidInfo|,
perform the following steps. They return a {{PAHistogramContribution}}:
1. Let |contribution| be |onEventEntry|'s [=on event contribution entry/contribution=].
1. Let |bucket| be |contribution|["{{PAExtendedHistogramContribution/bucket}}"].
1. If |bucket| is a {{PASignalValue}}, set |bucket| to the result of [=filling
    in the signal value=] given |reportingContext|, |onEventEntry|, |bucket|, 2<sup>128</sup>−1
    and |leadingBidInfo|.
1. Let |value| be |contribution|["{{PAExtendedHistogramContribution/value}}"].
1. If |value| is a {{PASignalValue}}, set |value| to the result of [=filling in
    the signal value=] given |reportingContext|, |onEventEntry|, |value|, 2<sup>31</sup>−1 and
    |leadingBidInfo|.
1. Let |filledInContribution| be a new {{PAHistogramContribution}} with the
    items:
    : {{PAHistogramContribution/bucket}}
    :: |bucket|
    : {{PAHistogramContribution/value}}
    :: |value|
    : {{PAHistogramContribution/filteringId}}
    :: |contribution|["{{PAExtendedHistogramContribution/filteringId}}"]
1. Return |filledInContribution|.

</div>

<div algorithm>
To <dfn>fill in the signal value</dfn> given a [=reporting context=] |reportingContext|,
an [=on event contribution entry=] |onEventEntry|, a {{PASignalValue}} |value|, an
integer |maxAllowed| and a [=leading bid info=] |leadingBidInfo|, perform the following steps.
They return an integer.
1. [=Assert=]: |value|["{{PASignalValue/baseValue}}"] is a valid [=signal base
    value=].
1. Let |returnValue| be the result of [=determining a signal's numeric value=]
    given |reportingContext|, |onEventEntry|, |value|["{{PASignalValue/baseValue}}"] and
    |leadingBidInfo|.
1. If |value|["{{PASignalValue/scale}}"] [=map/exists=], set |returnValue| to
    the result of multiplying |value|["{{PASignalValue/scale}}"] with
    |returnValue|.
1. Set |returnValue| to the result of converting |returnValue| to an integer by
    truncating its fractional part.
1. If |value|["{{PASignalValue/offset}}"] [=map/exists=], set |returnValue| to
    the result of adding |returnValue| to |value|["{{PASignalValue/offset}}"].
1. Clamp |returnValue| to [=the inclusive range|the range=] 0 to |maxAllowed|,
    inclusive, and return the result.

</div>


<div algorithm>
To <dfn>determine a signal's numeric value</dfn> given a [=reporting context=] |reportingContext|,
an [=on event contribution entry=] |onEventEntry|, a [=signal base value=]
|signalBaseValue| and a [=leading bid info=] |leadingBidInfo|, perform the following steps.
They return a {{double}}.
1. Let |metrics| be the result of [=access per-participant metrics=] given |reportingContext|,
    |onEventEntry|'s [=on event contribution entry/origin=], [=on event contribution entry/
    worklet function=].
1. Let |bidAndScoreMetrics| be the result of [=access per-participant metrics=] given
  |reportingContext|, |onEventEntry|'s [=on event contribution entry/origin=], and the result of
  [=find corresponding bid and score phase function=] given [=on event contribution entry/worklet
  function=].
1. If |signalBaseValue| is:
  <dl class="switch">
  : "<code>[=signal base value/winning-bid=]</code>"
  :: 1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is null, return 0.
     1. Otherwise, return  |leadingBidInfo|'s [=leading bid info/leading bid=]'s [=generated bid/bid=].
  : "<code>[=signal base value/highest-scoring-other-bid=]</code>":
  :: 1. If |leadingBidInfo|'s [=leading bid info/highest scoring other bid=] is null, return 0.
     1. Otherwise, return |leadingBidInfo|'s [=leading bid info/highest scoring other bid=]'s
      [=generated bid/bid=].
  : "<code>[=signal base value/script-run-time=]</code>"
  :: Return the number of milliseconds of CPU time that the calling function
        (e.g. `generateBid()`) took to run.
  : "<code>[=signal base value/signals-fetch-time=]</code>"
  :: Switch on the associated [=worklet function=]:
    <dl class="switch">
    : <code>[=worklet function/generate-bid=]</code>
    :: Return the number of milliseconds it took for the trusted bidding signals
        fetch to complete, or 0 if no fetch was made.
    : <code>[=worklet function/score-ad=]</code>
    :: Return the number of milliseconds it took for the trusted scoring signals
        fetch to complete or 0 if no fetch was made.
    : <code>[=worklet function/report-result=]</code>
    : <code>[=worklet function/report-win=]</code>
    :: Return 0.

    </dl>
  : "<code>[=signal base value/bid-reject-reason=]</code>"
  :: 1. If the bid did not succeed purely because it didn't meet the required
        [=k-anonymity threshold=], return 8.
     1. Let |bidRejectReason| be "`not-available`".
     1. If the seller provided a reject reason, set |bidRejectReason| to that
        value.
     1. If |bidRejectReason| is:
        <dl class="switch">
        : "`not-available`"
        :: Return 0.
        : "`invalid-bid`"
        :: Return 1.
        : "`bid-below-auction-floor`"
        :: Return 2.
        : "`pending-approval-by-exchange`"
        :: Return 3.
        : "`disapproved-by-exchange`"
        :: Return 4.
        : "`blocked-by-publisher`"
        :: Return 5.
        : "`language-exclusions`"
        :: Return 6.
        : "`category-exclusions`"
        :: Return 7.
        : None of the above values
        :: [=Assert=]: false

          Note: this enum value is validated in `scoreAd()`.

          Issue: Verify this once
          <a href="https://github.com/WICG/turtledove/issues/627">WICG/turtledove#627</a> is resolved.

          Issue: There are some automatically generated values that are not described here.

          Issue: Verify handling when the bid was not rejected.

        </dl>
  : "<code>[=signal base value/average-code-fetch-time=]</code>"
  :: Return the result of [=getting the value to report from an averager=] given |metrics|'s [=per
    participant metrics/code fetch time averager=].

  : "<code>[=signal base value/participating-ig-count=]</code>"
  :: Return |bidAndScoreMetrics|'s [=per participant metrics/participating interest group count=].

  : "<code>[=signal base value/percent-scripts-timeout=]</code>"
  :: Return the result of [=computing a percentage metric=] given |metrics|'s [=per participant
    metrics/script timeouts occurred=] and |metrics|'s [=per participant metrics/script executions
    attempted=].

  : "<code>[=signal base value/regular-igs-count=]</code>"
  :: Return |bidAndScoreMetrics|'s [=per participant metrics/regular interest group count=].

  : "<code>[=signal base value/percent-regular-ig-count-quota-used=]</code>"
  :: Return the result of [=computing a percentage metric=] given |bidAndScoreMetrics|'s [=per
    participant metrics/regular interest group count=] and [=max regular interest groups per
    owner=].

  : "<code>[=signal base value/negative-igs-count=]</code>"
  :: Return |bidAndScoreMetrics|'s [=per participant metrics/negative interest group count=].

  : "<code>[=signal base value/percent-negative-ig-count-quota-used=]</code>"
  :: Return the result of [=computing a percentage metric=] given |bidAndScoreMetrics|'s [=per
    participant metrics/negative interest group count=] and [=max negative interest groups per
    owner=].

  : "<code>[=signal base value/ig-storage-used=]</code>"
  :: Return |bidAndScoreMetrics|'s [=per participant metrics/storage quota used=].

  : "<code>[=signal base value/percent-ig-storage-quota-used=]</code>"
  :: Return the result of [=computing a percentage metric=] given |bidAndScoreMetrics|'s [=per
    participant metrics/storage quota used=] and [=max interest groups total size per owner=].

  : "<code>[=signal base value/cumulative-buyer-time=]</code>"
  :: Return |bidAndScoreMetrics|'s [=per participant metrics/cumulative buyer time=].

  : "<code>[=signal base value/percent-igs-cumulative-timeout=]</code>"
  :: Return the result of [=computing a percentage metric=] given |bidAndScoreMetrics|'s [=per
    participant metrics/cumulative timeouts occurred=] and |bidAndScoreMetrics|'s [=per participant
    metrics/script executions attempted=].

  </dl>

</div>

<div algorithm>
To <dfn>compute a percentage metric</dfn> given {{long}}s |numerator| and |denominator|:
1. If |denominator| is 0, return 0.
1. Let |result| be 100.0 * |numerator| / |denominator|, performing the computation with
  {{double}}s.
1. If |result| &gt; 110.0, set |result| to 110.0

  Note: Since [=perform storage maintenance|Interest Group Storage Maintenance=] happens
  periodically, metrics measuring storage utilization <span class="allow-2119">may</span> report
  values that exceed 100%. The 110% cap exists to make it easier to allocate histogram bucket space
  for those metrics, by providing a predictable upper bound.

1. Return |result|.

</div>

<div algorithm>
To <dfn>update storage metrics</dfn> given [=per participant metrics=] |metrics| and a [=list=] of
[=interest groups=] |igs|:
1. [=list/For each=] |ig| of |igs|:
  1. If [=interest group/additional bid key=] is null, increment |metrics|'s [=per participant
    metrics/regular interest group count=] by 1.
  1. Otherwise, increment |metrics|'s [=per participant metrics/negative interest group count=]
    by 1.
  1. Increment |metrics|'s [=per participant metrics/storage quota used=] by |ig|'s [=interest
    group/estimated size=]

</div>

<div algorithm>
To <dfn>update cumulative buyer time metrics</dfn> given [=per participant metrics=] |metrics| and a
[=cumulative timeout tracker=] |tracker|:
1. If |tracker|'s [=cumulative timeout tracker/limit=] is null, return.
1. If |tracker| [=cumulative timeout tracker/is expired=], set |metrics|'s
  [=per participant metrics/cumulative buyer time=] to |tracker|'s [=cumulative timeout tracker/
  limit=] + 1000ms.
1. Otherwise, set |metrics|'s [=per participant metrics/cumulative buyer time=] to |tracker|'s
  [=cumulative timeout tracker/limit=] - |tracker|'s [=cumulative timeout tracker/remaining=].

</div>

## Get storage interest groups for owner ## {#get-storage-interest-groups-for-owner-header}

*This first introductory paragraph is non-normative.*

The [=get storage interest groups for owner=] algorithm returns a Web IDL array of interest groups. This allows a Protected Audience buyer within a shared storage worklet to gain insights into their users and to send Private Aggregation reports.

<xmp class="idl">
dictionary StorageInterestGroup : AuctionAdInterestGroup {
  unsigned long long joinCount;
  unsigned long long bidCount;
  sequence<PreviousWin> prevWinsMs;
  USVString joiningOrigin;
  long long timeSinceGroupJoinedMs;
  long long lifetimeRemainingMs;
  long long timeSinceLastUpdateMs;
  long long timeUntilNextUpdateMs;
  unsigned long long estimatedSize;
};
</xmp>

<div algorithm>
  To <dfn>get storage interest groups for owner</dfn> given an [=origin=] |owner|:

  1. Let |resultIgs| be an empty [=list=].
  1. Let |now| be a [=moment=] equal to the [=current coarsened wall time=].
  1. [=list/For each=] |ig| of [=user agent=]'s [=interest group set=]:
    1. If |ig|'s [=interest group/owner=] does not equal |owner|, then [=iteration/continue=].
    1. Let |resultIg| be an empty {{StorageInterestGroup}} dictionary.
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/owner}}"] to the [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=].
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/name}}"] to |ig|'s [=interest group/name=].
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/enableBiddingSignalsPrioritization}}"] to |ig|'s [=interest group/enable bidding signals prioritization=].
    1. If |ig|'s [=interest group/priority vector=] is not null:
      1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/priorityVector}}"] to |ig|'s [=interest group/priority vector=].
    1. If |ig|'s [=interest group/seller capabilities=] is not null:
      1. Let |resultSellerCapabilities| be an [=ordered map=].
      1. [=map/For each=] |origin| → |originSellerCapabilities| of |ig|'s [=interest group/seller capabilities=]:
        1. Let |serializedOrigin| be the [=serialization of an origin|serialization=] of |origin|.
        1. [=map/Set=] |resultSellerCapabilities|[|serializedOrigin|] to |originSellerCapabilities|.
      1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/sellerCapabilities}}"] to |resultSellerCapabilities|.
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/executionMode}}"] to |ig|'s [=interest group/execution mode=].
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/biddingLogicURL}}"] to the [=serialize a URL|serialization=] of |ig|'s [=interest group/bidding url=].
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/biddingWasmHelperURL}}"] to the [=serialize a URL|serialization=] of |ig|'s [=interest group/bidding wasm helper url=].
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/updateURL}}"] to the [=serialize a URL|serialization=] of |ig|'s [=interest group/update url=].
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/trustedBiddingSignalsURL}}"] to the [=serialize a URL|serialization=] of |ig|'s [=interest group/trusted bidding signals url=].
    1. If |ig|'s [=interest group/trusted bidding signals keys=] is not null:
      1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/trustedBiddingSignalsKeys}}"] to |ig|'s [=interest group/trusted bidding signals keys=].
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/trustedBiddingSignalsSlotSizeMode}}"] to |ig|'s [=interest group/trusted bidding signals slot size mode=].
    1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/maxTrustedBiddingSignalsURLLength}}"] to |ig|'s [=interest group/max trusted bidding signals url length=].
    1. If |ig|'s [=interest group/user bidding signals=] is not null:
      1. Let |parsedUserBiddingSignals| be |ig|'s [=interest group/user bidding signals=] [=parsing a JSON string to a JavaScript value|parsed to a JavaScript value=].
      1. If [=an exception was thrown=], then return failure.
      1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/userBiddingSignals}}"] to |parsedUserBiddingSignals|.
    1. If |ig|'s [=interest group/ads=] is not null:
      1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/ads}}"] to |ig|'s [=interest group/ads=] [=converted to an AuctionAd sequence=].
      1. If [=an exception was thrown=], then return failure.
    1. If |ig|'s [=interest group/ad components=] is not null:
      1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/adComponents}}"] to |ig|'s [=interest group/ad components=] [=converted to an AuctionAd sequence=].
      1. If [=an exception was thrown=], then return failure.
    1. If |ig|'s [=interest group/ad sizes=] is not null:
      1. Let |resultAdSizes| be an [=ordered map=].
      1. [=map/For each=] |sizeName| → |adSize| of |ig|'s [=interest group/ad sizes=]:
        1. [=map/Set=] |resultAdSizes|[|sizeName|] to |adSize| [=convert an ad size to a map|converted to a map=].
      1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/adSizes}}"] to |resultAdSizes|.
    1. If |ig|'s [=interest group/size groups=] is not null:
      1. [=map/Set=] |resultIg|["{{GenerateBidInterestGroup/sizeGroups}}"] to |ig|'s [=interest group/size groups=].
    1. [=map/Set=] |resultIg|["{{AuctionAdInterestGroup/priority}}"] to |ig|'s [=interest group/priority=].
    1. If |ig|'s [=interest group/priority signals overrides=] is not null:
      1. [=map/Set=] |resultIg|["{{AuctionAdInterestGroup/prioritySignalsOverrides}}"] to |ig|'s [=interest group/priority signals overrides=].
    1. If |ig|'s [=interest group/additional bid key=] is not null:
      1. Let |encoded| be the result of running [=forgiving-base64 encode=] with |ig|'s [=interest group/additional bid key=].
      1. If |encoded| is failure, then return failure.
      1. [=map/Set=] |resultIg|["{{AuctionAdInterestGroup/additionalBidKey}}"] to the result of running [=forgiving-base64 encode=] with |ig|'s [=interest group/additional bid key=].
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/joinCount}}"] to the sum of |ig|'s [=interest group/join counts=] for all days within the last 30 days.
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/bidCount}}"] to the sum of |ig|'s [=interest group/bid counts=] for all days within the last 30 days.
    1. Let |resultPrevWins| be a new <code>[=sequence=]<{{PreviousWin}}></code>.
    1. [=list/For each=] |prevWin| of |ig|'s [=interest group/previous wins=] for all days within the
      the last 30 days:
      1. Let |timeDelta| be (|now| &minus; |prevWin|'s [=previous win/time=]) in millseconds.
      1. Set |timeDelta| to 0 if |timeDelta| is negative, |timeDelta|'s nearest second (rounding down)
        otherwise.
      1. Let |metadata| be |prevWin|'s [=interest group ad/metadata=] [=parsing a JSON string to a JavaScript value|parsed to a JavaScript value=].
      1. If [=an exception was thrown=], then return failure.
      1. Let |prevWinAdIDL| be a new {{AuctionAd}} with the following [=struct/items=]:
        : {{AuctionAd/renderURL}}
        :: the [=URL serializer|serialization=] of |prevWin|'s [=interest group ad/render url=]
        : {{AuctionAd/metadata}}
        :: |metadata|.
        : {{AuctionAd/adRenderId}}
        :: |prevWin|'s [=interest group ad/ad render ID=]
      1. Let |prevWinElement| be the <code>[=sequence=]<{{PreviousWinElement}}></code> «|timeDelta|, |prevWinAdIDL|».
      1. [=list/Append=] |prevWinElement| to |resultPrevWins|.
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/prevWinsMs}}"] to |resultPrevWins|.
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/joiningOrigin}}"] to the [=serialization of an origin|serialization=] of |ig|'s [=interest group/joining origin=].
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/timeSinceGroupJoinedMs}}"] to (|now| &minus; |ig|'s [=interest group/join time=]) in millseconds.
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/lifetimeRemainingMs}}"] to (|ig|'s [=interest group/expiry=] &minus; |now|) in millseconds.
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/timeSinceLastUpdateMs}}"] to (|now| &minus; |ig|'s [=interest group/last updated=]) in millseconds.
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/timeUntilNextUpdateMs}}"] to (|ig|'s [=interest group/next update after=] &minus; |now|) in millseconds.
    1. [=map/Set=] |resultIg|["{{StorageInterestGroup/estimatedSize}}"] to |ig|'s [=interest group/estimated size=].
    1. [=list/Append=] |resultIg| to |resultIgs|.
  1. Return |resultIgs|.
</div>

# Additional Bids and Negative Targeting # {#additional-bids-and-negative-targeting}

## createAuctionNonce() ## {#create-auction-nonce}

*This first introductory paragraph is non-normative.*

{{Window/navigator}}.{{Navigator/createAuctionNonce()}} creates an <dfn>auction nonce</dfn>, which
is a one-time canonical [=string=] representation of a [=version 4 UUID=] that is uniquely
associated with a single call to {{Window/navigator}}.{{Navigator/runAdAuction()}}. For multi-seller
auctions, a distinct auction nonce can be uniquely associated with each of the
{{AuctionAdConfig/componentAuctions}}. The auction nonce(s) will need to be passed back in via a
subsequent call to {{Window/navigator}}.{{Navigator/runAdAuction()}} via the {{AuctionAdConfig}}.
This is currently only needed for [=auctions=] that use [=additional bids=], in which the auction
nonce is combined with a [=signed additional bid with metadata/seller nonce=] to construct a bid
nonce that must be included in each [=additional bid=]. For backwards compatibility, [=additional
bids=] may include an auction nonce directly in place of a bid nonce.

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<DOMString> createAuctionNonce();
};
</xmp>

<div algorithm="createAuctionNonce()">
The <dfn for=Navigator method>createAuctionNonce()</dfn> method steps are:

  1. Let |p| be [=a new promise=].
  1. Run the following steps [=in parallel=]:
    1. Let |nonce| be the [=string representation=] of a [=version 4 UUID=].

    <div class=note>
    Because we're going in parallel:
      * There is no guarantee that the promise will be resolved before other tasks get queued on the
        main thread;
      * ...which gives browsers the freedom to generate this UUID in another process, and
        asynchronously send it back to the main thread at an arbitrary future time.
    </div>
    1. [=Queue a global task=] on [=DOM manipulation task source=], given [=this=]'s
      [=relevant global object=], to [=resolve=] |p| with |nonce|.
  1. Return |p|.
</div>

## Additional Bids ## {#additional-bids-section}

*This first introductory paragraph is non-normative.*

In addition to [=generate potentially multiple bids|bids generated by interest groups=], sellers can enable buyers to
introduce bids generated outside of the auction, which are called <dfn>additional bids</dfn>.
[=Additional bids=] are commonly triggered using contextual signals. Buyers compute the
[=additional bids=], likely as part of a contextual auction. Buyers need to package up each
[=additional bid=] using a new data structure that encapsulates all of the information needed for
the [=additional bid=] to compete against other bids in a Protected Audience [=auction=].

<div id="additional-bid-example" class=example>
  <p> Each additional bid is expressed using the following JSON data structure:</p>
  <pre highlight="js">
  const additionalBid = {
    "bid": {
      "ad": 'ad-metadata',
      "adCost": 2.99,
      "bid": 1.99,
      "bidCurrency": "USD",
      "render": "https://www.example-dsp.com/ad/123.jpg",
      "adComponents": [adComponent1, adComponent2],
      "allowComponentAuction": true,
      "modelingSignals": 123,
    },
    "interestGroup": {
      "owner": "https://www.example-dsp.com"
      "name": "campaign123",
      "biddingLogicURL": "https://www.example-dsp.com/bid_logic.js"
    },
    "negativeInterestGroups": {
      joiningOrigin: "https://www.example-advertiser.com",
      interestGroupNames: [
        "example_advertiser_negative_interest_group_a",
        "example_advertiser_negative_interest_group_b",
      ]
    },
    "auctionNonce": "12345678-90ab-cdef-fedcba09876543210",
    "seller": "https://www.example-ssp.com",
    "topLevelSeller": "https://www.another-ssp.com"
  }
  </pre>
</div>

<div algorithm>
To <dfn>validate and convert additional bids</dfn> given an [=auction config=] |auctionConfig|, an
[=auction config=]-or-null |topLevelAuctionConfig|, a [=negative target info=] |negativeTargetInfo|,
a [=reporting context map=] |reportingContextMap|, and a [=global object=] |global|:

  1. [=Assert=] that these steps are running [=in parallel=].
  1. [=Assert=] that |auctionConfig|'s [=auction config/auction nonce=] is not null.
  1. Let |auctionNonce| be the [=string representation=] of |auctionConfig|'s
    [=auction config/auction nonce=].
  1. Let |capturedAdditionalBidsHeaders| be |global|'s [=associated Document's=]
    [=node navigable's=] [=traversable navigable's=] [=traversable navigable/captured ad auction
    additional bids headers=].
  1. Let |additionalBids| be a new [=list=] of [=decoded additional bids=].
  1. [=list/For each=] |encodedSignedAdditionalBidWithMetadata| of
    |capturedAdditionalBidsHeaders|[|auctionNonce|]:
    1. Let |signedAdditionalBid| be the result of running [=forgiving-base64 decode=] with
      |encodedSignedAdditionalBidWithMetadata|'s [=signed additional bid with metadata/signed
      additional bid=].
    1. If |signedAdditionalBid| is failure, then [=iteration/continue=].
    1. Let |additionalBid| be the result of running [=parse a signed additional bid=] given
      |signedAdditionalBid|, |reportingContextMap|, |encodedSignedAdditionalBidWithMetadata|'s
      [=signed additional bid with metadata/seller nonce=], |auctionConfig|,
      |topLevelAuctionConfig|, and |negativeTargetInfo|.
    1. If |additionalBid| is not null:
      1. [=list/Append=] |additionalBid| to |additionalBids|.
      1. Let |bidCopy| be a clone of |additionalBid|.
      1. Set |bidCopy|'s [=generated bid/for k-anon auction=] to false.
  1. Return |additionalBids|.
</div>

<div algorithm>
To <dfn>parse a signed additional bid</dfn> given a [=byte sequence=] |signedAdditionalBid|,
a [=reporting context map=] |reportingContextMap|, a [=string=]-or-null |sellerNonce|, an [=auction
config=] |auctionConfig|, an [=auction config=]-or-null |topLevelAuctionConfig|, and a [=negative
target info=] |negativeTargetInfo|:

  1. [=Assert=] that these steps are running [=in parallel=].
  1. Let |parsedSignedAdditionalBid| be the result of running [=parse a JSON string to an infra value=]
    given |signedAdditionalBid|.
  1. Return null if any of the following conditions hold:
    * |parsedSignedAdditionalBid| is not a [=map=];
    * |parsedSignedAdditionalBid|["bid"] does not [=map/exist=], or is not a [=string=];
    * |parsedSignedAdditionalBid|["signatures"] does not [=map/exist=], or is not a [=list=].
  1. Let |signatures| be a new [=list=] of [=signed additional bid signatures=].
  1. Let |decodeSignatureFailed| be false.
  1. [=list/For each=] |sig| of |parsedSignedAdditionalBid|["signatures"]:
    1. Set |decodeSignatureFailed| to true and [=iteration/break=] if any of the following
      conditions hold:
      * |sig| is not a [=map=];
      * |sig|["key"] does not [=map/exist=], or is not a [=string=];
      * |sig|["signature"] does not [=map/exist=], or is not a [=string=].
    1. Let |maybeKey| be the result of running [=forgiving-base64 decode=] with |sig|["key"].
    1. Let |maybeSignature| be the result of running [=forgiving-base64 decode=] with
      |sig|["signature"].
    1. Set |decodeSignatureFailed| to true and [=iteration/break=] if any of the following
      conditions hold:
      * |maybeKey| is failure, or its [=byte sequence/length=] is not 32;
      * |maybeSignature| is failure, or its [=byte sequence/length=] is not 64;
    1. Let |signature| be a [=signed additional bid signatures=], whose
      [=signed additional bid signature/key=] is |maybeKey|, and
      [=signed additional bid signature/signature=] is |maybeSignature|.
    1. [=list/Append=] |signature| to |signatures|.
  1. If |decodeSignatureFailed| is true, then return null.
  1. Let |decodedAdditionalBid| be the result of [=decode an additional bid json=] given
    |parsedSignedAdditionalBid|["bid"], |reportingContextMap|, |auctionConfig|,
    |topLevelAuctionConfig|, and |sellerNonce|.
  1. Return null if any of the following conditions hold:
    * |decodedAdditionalBid| is failure;
    * The result of [=checking a currency tag=] with |decodedAdditionalBid|'s
      [=decoded additional bid/bid=]'s [=generated bid/bid=]'s [=bid with currency/currency=] and
      the result of running [=look up per-buyer currency=] with |auctionConfig|.
  1. Let |verifiedSignatureKeys| be a new [=set=] of [=byte sequences=].
  1. [=list/For each=] |signature| of |signatures|:
    1. Let |isSignatureValid| be the result of running [=verify=] |signature|'s
      [=signed additional bid signature/signature=] on message |parsedSignedAdditionalBid|["bid"]
      using |signature|'s [=signed additional bid signature/key=], with 0 for Ed25519ctx.
    1. If |isSignatureValid| is true, then [=set/append=] |signature|'s
      [=signed additional bid signature/key=] to |verifiedSignatureKeys|.
  1. If the result of [=checking whether negative targeted=] given |decodedAdditionalBid|,
    |verifiedSignatureKeys| and |negativeTargetInfo| is true, then return null.
  1. Return |decodedAdditionalBid|.
</div>

<div algorithm>
To <dfn>decode an additional bid json</dfn> given a [=string=] |additionalBidJson|,
a [=reporting context map=] |reportingContextMap|, an [=auction config=] |auctionConfig|, an
[=auction config=]-or-null |topLevelAuctionConfig|, and a [=string=]-or-null |sellerNonce|:

  1. [=Assert=] that these steps are running [=in parallel=].
  1. Let |parsedAdditionalBid| be the result of [=parse a JSON string to an infra value=] given
    |additionalBidJson|.
  1. If |parsedAdditionalBid| is not a [=map=], then return failure.
  1. Let |result| be a new [=decoded additional bid=].
  1. Return failure if any of the following conditions hold:
    * |parsedAdditionalBid|["auctionNonce"] [=map/exists=] and |parsedAdditionalBid|["bidNonce"]
      [=map/exists=];
    * |parsedAdditionalBid|["auctionNonce"] does not [=map/exist=] and
      |parsedAdditionalBid|["bidNonce"] does not [=map/exist=];
    * |parsedAdditionalBid|["seller"] does not [=map/exist=];
    * The result of running the [=parse an https origin=] with |parsedAdditionalBid|["seller"] is
      failure, or not [=same origin=] with |auctionConfig|'s [=auction config/seller=].
  1. If |sellerNonce| is not null:
    1. Return failure if any of the following conditions hold:
      1. |parsedAdditionalBid|["bidNonce"] does not [=map/exist=];
      1. |parsedAdditionalBid|["bidNonce"] is not the result of [=calculate expected bid nonce=]
        given the [=string representation=] of |auctionConfig|'s [=auction config/auction nonce=]
        and |sellerNonce|.
  1. Otherwise:
    1. Return failure if any of the following conditions hold:
      * |parsedAdditionalBid|["auctionNonce"] does not [=map/exist=];
      * |parsedAdditionalBid|["auctionNonce"] is not the [=string representation=] of
        |auctionConfig|'s [=auction config/auction nonce=];

  1. If |topLevelAuctionConfig| is null:
    1. If |parsedAdditionalBid|["topLevelSeller"] [=map/exists=], then return failure.
  1. Otherwise:
    1. If |parsedAdditionalBid|["topLevelSeller"] does not [=map/exist=], then return failure.
    1. Let |bidTopLevelSeller| be the result of running the [=parse an https origin=] with
      |parsedAdditionalBid|["topLevelSeller"].
    1. If |bidTopLevelSeller| is failure, or |bidTopLevelSeller| is not [=same origin=] with
      |topLevelAuctionConfig|'s [=auction config/seller=], then return failure.
  1. If |parsedAdditionalBid|["interestGroup"] does not [=map/exist=], then return failure.
  1. Let |igMap| be |parsedAdditionalBid|["interestGroup"].
  1. Return failure if any the following conditions hold:
    * |igMap| is not a [=map=];
    * |igMap|["name"] does not [=map/exist=], or is not a [=string=];
    * |igMap|["biddingLogicURL"] does not [=map/exist=], or is not a [=string=];
    * |igMap|["owner"] does not [=map/exist=], or is not a [=string=];
  1. Let |igOwner| be the result of running [=parse an https origin=] given |igMap|["owner"].
  1. Let |igName| be |igMap|["name"].
  1. Let |igBiddingUrl| be the result of running [=url parser=] on |igMap|["biddingLogicURL"].
  1. Return failure if any of the following conditions hold:
    * |igOwner| is failure;
    * |auctionConfig|'s [=auction config/interest group buyers=] does not [=list/contain=] |igOwner|;
    * |igBiddingUrl| is failure;
    * |igOwner| is not [=same origin=] with |igBiddingUrl|.
  1. Let |ig| be a new [=interest group=] with the following properties:
    :   [=interest group/owner=]
    ::  |igOwner|
    :   [=interest group/name=]
    ::  |igName|
    :   [=interest group/bidding url=]
    ::  |igBiddingUrl|
  1. If |parsedAdditionalBid|["bid"] does not [=map/exist=], or is not a [=map=], return failure.
  1. Let |bidMap| be |parsedAdditionalBid|["bid"].
  1. If |bidMap|["render"] does not [=map/exist=] or is not a [=string=], then return failure.
  1. Let |renderUrl| be the result of running [=URL parser=] on |bidMap|["render"].

  1. If |renderUrl| is failure, then return failure.
  1. Let |ad| be a new [=interest group ad=] whose [=interest group ad/render url=] is |renderUrl|.
  1. Set |ig|'s [=interest group/ads=] to « |ad| ».
  1. Let |bidVal| be |bidMap|["bid"] if it [=map/exists=], otherwise return failure.
  1. If |bidVal| is not a {{double}}, or is less than or equal to 0, then return failure.
  1. Let |adMetadata| be "null".
  1. If |bidMap|["ad"] [=map/exists=]:
    1. Set |adMetadata| to the result of running [=serialize an Infra value to a JSON string=] with
      |bidMap|["ad"].
  1. Let |bidCurrency| be null.
  1. If |bidMap|["bidCurrency"] [=map/exists=]:
    1. If |bidMap|["bidCurrency"] is not a [=string=], or the result of [=checking whether a string
      is a valid currency tag=] is failure, then return failure.
    1. Set |bidCurrency| to |bidMap|["bidCurrency"].
  1. Let |adCost| be null.
  1. If |bidMap|["adCost"] [=map/exists=]:
    1. If |bidMap|["adCost"] is not a {{double}}, then return failure.
    1. Set |adCost| to |bidMap|["adCost"].
  1. Let |modelingSignals| be null.
  1. If |bidMap|["modelingSignals"] [=map/exists=]:
    1. If |bidMap|["modelingSignals"] is not a {{double}}, then return failure.
    1. If |bidMap|["modelingSignals"] &ge; 0, and &lt; 4096, then set |modelingSignals| to
      |bidMap|["modelingSignals"].
  1. Let |adComponents| be a new [=list=] of [=ad descriptors=].
  1. If |bidMap|["adComponents"] [=map/exists=]:
    1. If |bidMap|["adComponents"] is not a [=list=], then return failure.
    1. [=list/For each=] |component| of |bidMap|["adComponents"]:
      1. If |component| is not a [=string=], then return failure.
      1. Let |componentUrl| be the result of running [=URL parser=] on |component|.
      1. If |componentUrl| is failure, then return failure.
      1. Let |componentDescriptor| be a new [=ad descriptor=] whose [=ad descriptor/url=] is
        |componentUrl|.
      1. [=list/Append=] |componentDescriptor| to |adComponents|.
    1. Set |ig|'s [=interest group/ad components=] to |adComponents|.
  1. If |parsedAdditionalBid|["negativeInterestGroup"] [=map/exists=]:
    1. If |parsedAdditionalBid|["negativeInterestGroups"] [=map/exists=], or
      |parsedAdditionalBid|["negativeInterestGroup"] is not a [=string=], then return failure.
    1. [=list/Append=] |parsedAdditionalBid|["negativeInterestGroup"] to |result|'s
      [=decoded additional bid/negative target interest group names=].
  1. If |parsedAdditionalBid|["negativeInterestGroups"] [=map/exists=]:
    1. Let |multipleNegativeIg| be |parsedAdditionalBid|["negativeInterestGroups"].
    1. Return failure if any of the following conditions hold:
      * |multipleNegativeIg| is not a [=map=];
      * |multipleNegativeIg|["joiningOrigin"] does not [=map/exist=], or is not a [=string=];
      * |multipleNegativeIg|["interestGroupNames"] does not [=map/exist=], or is not a [=list=].
    1. Let |joiningOrigin| be the result of running [=parse an https origin=] with
      |multipleNegativeIg|["joiningOrigin"].
    1. If |joiningOrigin| is failure, then return failure.
    1. Set |result|'s [=decoded additional bid/negative target joining origin=] to |joiningOrigin|.
    1. [=list/For each=] |igName| of |multipleNegativeIg|["interestGroupNames"]:
      1. If |igName| is not a [=string=], then return failure.
      1. [=list/Append=] |igName| to |result|'s
        [=decoded additional bid/negative target interest group names=].
  1. Set |result|'s [=decoded additional bid/bid=] to a new [=generated bid=] with the following
    properties:
    : [=generated bid/reporting id=]
    :: A [=reporting bid key=] with the following [=struct/items=]:
      : [=reporting bid key/context=]
      :: |reportingContextMap|[|auctionConfig|]
      : [=reporting bid key/source=]
      :: [=reporting bid source/additional-bid=]
      : [=reporting bid key/bidder origin=]
      :: |ig|'s [=interest group/owner=]
      : [=reporting bid key/bid identifier=]
      :: A [=string=] representation of a new globably unique identifier. This is needed since
        |igName| may not be unique.
    :   [=generated bid/bid=]
    ::  A [=bid with currency=] whose [=bid with currency/value=] is |bidVal|, and
      [=bid with currency/currency=] is |bidCurrency|
    :   [=generated bid/ad=]
    ::  |adMetadata|
    :   [=generated bid/ad descriptor=]
    ::  An [=ad descriptor=] whose [=ad descriptor/url=] is |renderUrl|
    :   [=generated bid/ad component descriptors=]
    ::  |adComponents|
    :   [=generated bid/ad cost=]
    ::  |adCost|
    :   [=generated bid/modeling signals=]
    ::  |modelingSignals|
    :   [=generated bid/interest group=]
    ::  |ig|
    :   [=generated bid/bid ad=]
    ::  A [=interest group ad=] whose [=interest group ad/render url=] is |renderUrl|, and
      [=interest group ad/metadata=] is |adMetadata|
    :   [=generated bid/provided as additional bid=]
    ::  true
  1. Return |result|.
</div>

<div algorithm>
To <dfn>calculate expected bid nonce</dfn> given a [=string=] |auctionNonce| and a [=string=]
|sellerNonce|:

  1. Return the result of [=forgiving-base64 encoding=] the [=SHA-256=] hash of the result of
    [=string/concatenating=] «|auctionNonce|, |sellerNonce|».

</div>

A <dfn>signed additional bid signature</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="signed additional bid signature">
  : <dfn>key</dfn>
  :: A [=byte sequence=] of length 32.
  : <dfn>signature</dfn>
  :: A [=byte sequence=] of length 64.
</dl>

A <dfn>decoded additional bid</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="decoded additional bid">
  : <dfn>bid</dfn>
  :: A [=generated bid=]. Fields analogous to those returned by `generateBid()`.
  : <dfn>negative target interest group names</dfn>
  :: A [=list=] of [=strings=].
  : <dfn>negative target joining origin</dfn>
  :: Null or an [=origin=]. Required if there is more than one entry in
    [=decoded additional bid/negative target interest group names=].
</dl>

## Negative Targeting ## {#negative-targeting-section}

*This first introductory paragraph is non-normative.*

In online ad auctions for ad space, it's sometimes useful to prevent showing an ad to certain
audiences, a concept known as <dfn>negative targeting</dfn>. To facilitate [=negative targeting=] in
Protected Audience [=auctions=], each [=additional bid=] is allowed to identify one or more
[=negative interest groups=]. If the user has been joined to any of the identified
[=negative interest groups=], the [=additional bid=] is dropped; otherwise it participates in the
[=auction=], competing alongside bids created by calls to `generateBid()`. An [=additional bid=]
that specifies no [=negative interest groups=] is always accepted into the [=auction=].

<div algorithm>
To <dfn>check whether negative targeted</dfn> given a [=decoded additional bid=] |additionalBid|, a
[=set=] of [=byte sequences=] |verifiedSignatureKeys|, and a [=negative target info=]
|negativeTargetInfo|:

  1. [=Assert=] that these steps are running [=in parallel=].
  1. Let |negativeTargeted| be false.
  1. Let |additionalBidBuyer| be |additionalBid|'s [=decoded additional bid/bid=]'s
    [=generated bid/interest group=]'s [=interest group/owner=].
  1. [=list/For each=] |igName| of |additionalBid|'s
    [=decoded additional bid/negative target interest group names=]:
    1. If |negativeTargetInfo|[(|additionalBidBuyer|, |igName|)] [=map/exists=]:
      1. Let (|joiningOrigin|, |additionalBidKey|) be
        |negativeTargetInfo|[(|additionalBidBuyer|, |igName|)].
      1. If |verifiedSignatureKeys| [=list/contains=] |additionalBidKey|:
        1. If |joiningOrigin| is not null:
          1. If |joiningOrigin| is not [=same origin=] with |additionalBid|'s
            [=decoded additional bid/negative target joining origin=], then [=iteration/continue=].
        1. Set |negativeTargeted| to true, and [=iteration/break=].

   Note: If the signature doesn't verify successfully, the [=additional bid=] proceeds as if the
      [=negative interest group=] is not present. This ensures that only the
      [=interest group/owner=] of the [=negative interest group=], who created the
      {{AuctionAdInterestGroup/additionalBidKey}}, is allowed to
      [=negative targeting|negatively target=] the interest group, and that nobody else can learn
      whether the [=interest group set=] [=list/contains=] the interest group.
  1. Return |negativeTargeted|.
</div>

A <dfn>negative target info</dfn> is a [=map=]. Its [=map/keys=] are [=tuples=] consisting of an
[=origin=] for [=interest group/owner=] and a [=string=] for [=interest group/name=].
Its [=map/values=] are [=tuples=] consisting of an [=origin=] for [=interest group/joining origin=]
and a [=byte sequence=] for [=interest group/additional bid key=].

### Negative Interest Groups ### {#negative-interest-groups}

*This section is non-normative.*

Though [=negative interest groups=] are joined using the same {{Navigator/joinAdInterestGroup()}}
API as [=regular interest groups=], they remain distinct from one another. Only
[=negative interest groups=]'s [=interest group/additional bid key=] can be non-null, while only
[=regular interest groups=]'s [=interest group/ads=] can be non-null. Because the subset of fields
used by a [=negative interest group=] cannot be meaningfully updated, a [=negative interest group=]'s
[=interest group/update url=] must be null, otherwise a {{TypeError}} will be [=exception/thrown=] by
{{Navigator/joinAdInterestGroup()}} API.

[=Additional bids=] specify the [=negative interest groups=] they're [=negatively targeting=]
against using at most one of the following two fields in their JSON data structure:
  * negativeInterestGroup, for a single negative interest group;
  * negativeInterestGroups, for more than one negative interest groups.

If an [=additional bid=] needs to specify more than one [=negative interest groups=], all of those
[=negative interest groups=] must be joined from the [=same origin=], and that [=origin=] must be
identified ahead of time in the [=additional bid=]'s `joiningOrigin` field. Any
[=negative interest group=] that wasn't joined from that identified [=origin=] is ignored for
[=negative targeting=].

<div id="negative-igs-example" class=example>
  <p>Use `negativeInterestGroup` in additional bid's JSON:</p>
  <pre highlight="js">
  const additionalBid = {
    ...
    "negativeInterestGroup": "example_advertiser_negative_interest_group",
    ...
  }
  </pre>
  <p>Use `negativeInterestGroups` in additional bid's JSON:</p>
  <pre highlight="js">
  const additionalBid = {
    ...
    "negativeInterestGroups": {
      joiningOrigin: "https://example-advertiser.com",
      interestGroupNames: [
        "example_advertiser_negative_interest_group_a",
        "example_advertiser_negative_interest_group_b",
      ]
    },
    ...
  }
  </pre>
</div>

# K-anonymity # {#k-anonymity}

Two goals of this specification rely on applying [=k-anonymity=] thresholds:

  * To prevent cross-site leaks:  Inputs to event-level reporting functions, `reportWin()` and
    `reportResult()`, only contain limited cross-site information. As described in
    [[#privacy-considerations]], part of this limiting is done by
    applying [=k-anonymity=] requirements to the ad URLs.
  * To ensure that the same ad or ad component is being shown to at least some minimum number of people:
    The browser applies [=k-anonymity=] requirements on the ad URLs.

The browser enforces these [=k-anonymity=] requirements by maintaining counts of how many times each
ad and ad component has been shown to users. These counts are maintained across users, so the counting must
be done on a central <dfn>k-anonymity server</dfn>. This specification relies on two operations to query and
increment the counts: [=query k-anonymity count=] and [=increment k-anonymity count=].

The details of how the [=k-anonymity server=] is operated and accessed are [=implementation-defined=]
but it should be done in a way that prevents the server operator from joining the identity of two
query or increment requests. One way to help prevent this is by making accesses to the server go
through an HTTP proxy that prevents the server from seeing the browsers' IP addresses.

The browser should choose a <dfn>k-anonymity threshold</dfn>, otherwise known as the value for "k",
and a <dfn>k-anonymity duration</dfn> depending
on the projected sizes of interest groups and the browser's privacy goals. For example an implementation
might choose to require a [=k-anonymity=] threshold of fifty users over a seven day period. The server
will maintain the count over the chosen duration and compare the count to the chosen [=k-anonymity=]
threshold when responding to [=query k-anonymity count=].

The [=user agent=] must maintain a <dfn>k-anonymity cache</dfn> as a [=map=] whose [=map/keys=] are
[=SHA-256=] hashes of the [=k-anonymity keys=] for all of the [=interest group/ads=] and [=interest group/ad components=]
in the [=user agent=]'s [=interest group set=] and whose [=map/values=] are [=k-anonymity records=].
This allows the browser to rerun portions of an auction without incurring the delay (and added side channels)
from querying the server during an auction.

<div algorithm>
  To <dfn>create a k-anon restricted deep copy of the interest group</dfn> given an [=interest group=] |ig|:
    1. Let |kAnonRestrictedIG| be a deep copy of |ig|.
    1. If |ig|'s [=interest group/ads=] is not null:
      1. Set |kAnonRestrictedIG|'s [=interest group/ads=] to an empty [=list=] of [=interest group ad=].
      1. [=list/For each=] |igAd| of |ig|'s [=interest group/ads=]:
        1. Let |adHashCode| be the result of running [=compute the key hash of ad=] given |ig| and |igAd|.
        1. If [=query k-anonymity cache=] for |adHashCode| returns true:
          1. If |igAd|'s [=interest group ad/selectable buyer and seller reporting IDs=] is not null:
            1. Let |kAnonRestrictedSelectableReportingIds| be a new empty [=list=] of [=string=]s.
            1. [=list/For each=] |selectableReportingId| in |igAd|'s
              [=interest group ad/selectable buyer and seller reporting IDs=]:
              1. Let |reportingHashCode| be the result of [=query reporting ID k-anonymity count=]
                given |ig|, |igAd|, and |selectableReportingId|.
              1. If [=query k-anonymity cache=] for |reportingHashCode| returns true, then
                [=list/append=] |selectableReportingId| to |kAnonRestrictedSelectableReportingIds|.
            1. Set |igAd|'s [=interest group ad/selectable buyer and seller reporting IDs=] to
              |kAnonRestrictedSelectableReportingIds|.
          1. [=list/Append=] |igAd| to |kAnonRestrictedIG|'s [=interest group/ads=].
    1. If |ig|'s [=interest group/ad components=] is not null:
      1. Set |kAnonRestrictedIG|'s [=interest group/ad components=] to an empty [=list=] of
        [=interest group ad=].
      1. [=list/For each=] |igAdComponent| of |ig|'s [=interest group/ad components=]:
        1. Let |adComponentHashCode| be the result of running [=compute the key hash of component ad=] given |ig| and
          |igAdComponent|.
        1. If [=query k-anonymity cache=] for |adComponentHashCode| returns true:
          1. [=list/Append=] |igAdComponent| to |kAnonRestrictedIG|'s [=interest group/ad components=].
    1. Return |kAnonRestrictedIG|.
</div>

<div algorithm>
  To <dfn>query k-anonymity count</dfn> given a [=SHA-256=] |hashCode|:
    1. If the [=k-anonymity server=] has recorded at least [=k-anonymity threshold=] users
        seeing |hashCode| over the last [=k-anonymity duration=], return true.
        Otherwise, return false.
    1. Return true if it is above the threshold, otherwise return false.
</div>

<div algorithm>
  To <dfn>query k-anonymity cache</dfn> given a [=SHA-256=] |hashCode|:
    1. If the [=user agent=]'s [=k-anonymity cache=] does not [=map/contain=] |hashCode|, then return false.
    1. Let |record| be the [=user agent=]'s [=k-anonymity cache=][|hashCode|].
    1. If the difference between [=current coarsened wall time=] and |record|'s [=k-anonymity
      record/timestamp=] is more than 7 days then return false.
    1. Return |record|'s [=k-anonymity record/is k-anonymous=].
</div>

<div algorithm>
  To <dfn>compute the key hash of ad</dfn> given an [=interest group=] |ig| and an [=interest group ad=] |igAd|:
    1. Let |keyString| be the [=k-anonymity key=] formed from the [=string/concatenation=] of the
      following strings separated with U+000A LF:
      * "AdBid"
      * the [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      * the [=URL serializer|serialization=] of |ig|'s [=interest group/bidding url=]
      * the [=URL serializer|serialization=] of |igAd|'s [=interest group ad/render url=].
    1. Return the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.
</div>

<div algorithm>
  To <dfn>compute the key part for one of multiple reporting ids</dfn> given [=string=]-or-null |reportingId|:
    1. If |reportingId| is null, then return the [=string/concatenation=] of the following:
      * U+0000 (NUL)
      * U+0000 (NUL)
      * U+0000 (NUL)
      * U+0000 (NUL)
      * U+0000 (NUL)
    1. Otherwise, return the [=string/concatenation=] of the following:
      * U+0001 (SOH)
      * The size of |reportingId|, interpreted as four 8-bit big-endian numbers, appended as bytes.
      * |reportingId|
</div>

<div algorithm>
  To <dfn>compute the key hash of reporting ID</dfn> given an [=interest group=] |ig| and an
  [=interest group ad=] |igAd|, and a [=string=]-or-null |selectedReportingId|:
    1. Let |middle| be the [=string/concatenation=] of the following strings separated with U+000A (LF):
      * the [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      * the [=URL serializer|serialization=] of |ig|'s [=interest group/bidding url=]
      * the [=URL serializer|serialization=] of |igAd|'s [=interest group ad/render url=]
    1. Let |keyString| be an empty [=string=].
    1. If |selectedReportingId| is not null, then set the |keyString| to be the [=string/concatenation=]
      of the following strings separated with U+000A (LF):
      * "SelectedBuyerAndSellerReportId"
      * |middle|
      * The result of [=compute the key part for one of multiple reporting ids=] given |selectedReportingId|
      * The result of [=compute the key part for one of multiple reporting ids=] given |igAd|'s
        [=interest group ad/buyer and seller reporting ID=]
      * The result of [=compute the key part for one of multiple reporting ids=] given |igAd|'s
        [=interest group ad/buyer reporting ID=]
    1. Otherwise:
      1. If |igAd|'s [=interest group ad/buyer and seller reporting ID=] is not null, set |keyString|
        to be the [=string/concatenation=] of the following strings separated with U+000A (LF):
        * "BuyerAndSellerReportId"
        * |middle|
        * |igAd|'s [=interest group ad/buyer and seller reporting ID=]
      1. Otherwise if |igAd|'s [=interest group ad/buyer reporting ID=] is not null, set |keyString|
        to be the [=string/concatenation=] of the following strings separated with U+000A (LF):
        * "BuyerReportId"
        * |middle|
        * |igAd|'s [=interest group ad/buyer reporting ID=]
      1. Otherwise set |keyString| to be the [=string/concatenation=] of the following strings separated
        with U+000A (LF):
        * "NameReport"
        * |middle|
        * |igAd|'s [=interest group/name=]
    1. Return the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.
</div>

<div algorithm>
 To <dfn>compute the key hash of component ad</dfn> given an [=interest group ad=] |igAd|:
   1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      * "ComponentBid"
      * the [=URL serializer|serialization=] of |igAd|.
   1. Return the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.
</div>

<div algorithm>
  To <dfn>query generated bid k-anonymity count</dfn> given a [=generated bid=] |bid|:
    1. Compute the |adHashCode| following [=compute the key hash of ad=] with the |bid|'s [=generated bid/interest group=]
      and |bid|'s [=generated bid/ad descriptor=].
    1. If [=query k-anonymity cache=] for |adHashCode| returns false, return false.
    1. If |bid|'s [=generated bid/ad component descriptors=] is not null:
      1. [=set/For each=] |adComponentDescriptor| in |bid|'s
        [=generated bid/ad component descriptors=]:
        1. Compute the |componentAdHashCode| by getting the result of [=compute the key hash of component ad=] with |adComponentDescriptor|'s
          [=ad descriptor/url=].
        1. If [=query k-anonymity cache=] for |componentAdHashCode| returns false, return false.
    1. If |bid|'s [=generated bid/selected buyer and seller reporting ID=] is not null:
      1. Let |isKAnon| the result of running [=query reporting ID k-anonymity count=] with |bid|'s
        [=generated bid/interest group=], |bid|'s [=generated bid/ad=], and |bid|'s
        [=generated bid/selected buyer and seller reporting ID=].
      1. If |isKAnon| is false, return false.
    1. Return true.
</div>

<div algorithm>
  To <dfn>query reporting ID k-anonymity count</dfn> given an [=interest group=]
  |ig|, an [=interest group ad=] |igAd|, and a [=string=]-or-null |selectedReportingId|:
    1. Let |keyHash| be the result of [=computing the key hash of reporting ID=] given |ig|, |igAd|, and |selectedReportingId|.
    1. Return the result of [=query k-anonymity cache=] given |keyHash|.
</div>

<div algorithm>
  To <dfn>update k-anonymity cache for key</dfn> given a [=SHA-256=] |hashCode|:
    1. [=Assert=] that these steps are running [=in parallel=].
    1. Let |record| be a new [=k-anonymity record=].
    1. Set |record|'s [=k-anonymity record/timestamp=] field to the [=current coarsened wall time=].
    1. Set |record|'s [=k-anonymity record/is k-anonymous=] field to the result of executing [=query k-anonymity count=] for |hashCode|.
    1. [=map/Set=] |record|[|hashCode|] to |record|.
</div>

<div algorithm>
  To <dfn>update k-anonymity cache for interest group</dfn> given an [=interest group=] |ig|:
    1. [=Assert=] that these steps are running [=in parallel=].
    1. [=list/For each=] |igAd| of |ig|'s [=interest group/ads=]:
      1. Let |adHashCode| be the result of running [=compute the key hash of ad=] given |ig| and |igAd|.
      1. Run [=update k-anonymity cache for key=] on |adHashCode|.
      1. Let |adReportingHashCode| be the result of [=computing the key hash of reporting ID=] given |ig|, |igAd|, and null.
      1. Run [=update k-anonymity cache for key=] on |adReportingHashCode|.
      1. If |igAd|'s [=interest group ad/selectable buyer and seller reporting IDs=] is not null:
        1. [=list/For each=] |selectableReportingId| in |igAd|'s [=interest group ad/selectable buyer and seller reporting IDs=]:
          1. Set |adReportingHashCode| be the result of [=computing the key hash of reporting ID=] given |ig|, |igAd|, and |selectableReportingId|.
          1. Run [=update k-anonymity cache for key=] on |adReportingHashCode|.
    1. [=list/For each=] |componentAd| of |ig|'s [=interest group/ad components=]:
      1. Let |componentAdHashCode| be the result of running [=compute the key hash of component ad=] given |componentAd|.
      1. Run [=update k-anonymity cache for key=] on |componentAdHashCode|.
</div>

<div algorithm>
  To <dfn>increment k-anonymity count</dfn> given a |hashCode|:
    1. Ask the [=k-anonymity server=] to record that this [=user agent=] has seen |hashCode|.
</div>

<div algorithm>
  To <dfn>increment ad k-anonymity count</dfn> given an [=interest group=] |ig| and a [=URL=] |ad|:
    1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      1. "AdBid"
      1. the [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      1. the [=URL serializer|serialization=] of |ig|'s [=interest group/bidding url=]
      1. the [=URL serializer|serialization=] of |ad|.
    1. Let |keyHash| be the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.
    1. [=Increment k-anonymity count=] given |keyHash|.
</div>

<div algorithm>
  To <dfn>increment component ad k-anonymity count</dfn> given a [=URL=] |ad|:
    1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      1. "ComponentBid"
      1. the [=URL serializer|serialization=] of |ad|.
    1. Let |keyHash| be the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.
    1. [=Increment k-anonymity count=] given |keyHash|.
</div>

<div algorithm>
  To <dfn>increment reporting ID k-anonymity count</dfn> given an [=interest group=] |ig| and a [=URL=]
  |ad|:
    1. Let |igAd| be the [=interest group ad=] from |ig|'s [=interest group/ads=] whose
      [=interest group ad/render url=] is |ad|.
    1. Let |keyHash| be the result of [=computing the key hash of reporting ID=] given |ig| and |igAd|.
    1. [=Increment k-anonymity count=] given |keyHash|.
</div>

<div algorithm>
  To <dfn local-lt="update k-anonymity counts">increment a winning bid's k-anonymity count</dfn> given a [=generated bid=] |winner|:
  1. [=Increment ad k-anonymity count=] given |winner|'s [=generated bid/interest group=] and
    |winner|'s [=generated bid/ad descriptor=]'s [=ad descriptor/url=].
  1. If |winner|'s [=generated bid/ad component descriptors=] is not null:
    1. [=list/For each=] |adComponentDescriptor| in |winner|'s [=generated bid/ad component descriptors=]:
      1. [=Increment component ad k-anonymity count=] given |adComponentDescriptor|'s
        [=ad descriptor/url=].
  1. [=Increment reporting ID k-anonymity count=] given |winner|'s
    [=generated bid/interest group=] and |winner|'s [=generated bid/ad descriptor=]'s
    [=ad descriptor/url=].
</div>

# Script Runners # {#script-runners}

*This introduction sub-section is non-normative*.

This specification defines a new type of script execution environment called a [=script runner=]. On
the surface, these are similar to <a href=https://html.spec.whatwg.org/C#worklets-intro>Worklets</a>
in that they too are used for running scripts independent of the *main* execution environment with a
flexible implementation model.

However, some key differences from traditional Worklets motivate us to create a new kind of script
execution environment. In particular, they:

 * Are not scoped to a particular {{Document}}, but are rather scoped to a [=user agent=], as they
   are spun up by [=interest groups=] in the [=user agent=]'s [=interest group set=].
 * Consequently have a different, more flexible [=ECMAScript/agent cluster=] allocation model —
   specifically, they need not execute in the same [=ECMAScript/agent cluster=] as any {{Document}},
   and for privacy reasons implementations may be motivated to enjoy this flexibility.
 * Do not have any other WebIDL interfaces exposed to their global besides the ones defined in this
   specification, unlike other Worklet types.
 * Have a restricted set of ECMAScript APIs exposed to them; for example {{Date}} is not exposed in
   these environments.
 * Are not [=module scripts=], and are instead evaluated as if they were [=classic scripts=].
 * Are not [=scripts=] in the [[HTML]] sense, and as such:
   * Their [=ECMAScript/agent=] does not have an [=event loop=]
   * Their [=ECMAScript/realm=] does not have a [=realm/settings object=], and therefore functions
     inside them are not run with the familiar [[WebIDL]] [=invoke|invocation=] mechanism.
   * They do not [=perform a microtask checkpoints=].

## Realm and agent ## {#realm-and-agent}

<div algorithm>
  To <dfn>create a new script runner agent</dfn>, run these steps:

    1. Let |signifier| be a new unique internal value.

    1. Let |candidateExecution| be a new [=ECMAScript/candidate execution=].

    1. Return a new [=ECMAScript/agent=] whose \[[CanBlock]] is false, \[[Signifier]] is
       |signifier|, \[[CandidateExecution]] is |candidateExecution|, and \[[IsLockFree1]],
       \[[IsLockFree2]], and \[[LittleEndian]] are set at the implementation's discretion.

  Note: This algorithm is almost identical to [[HTML]]'s [=create an agent=] algorithm, with the
  exception that we do not give the returned agent a new [=event loop=], since it does not process
  [=tasks=] within [=task sources=] in the usual way.
</div>

<div algorithm>
  To <dfn>obtain a script runner agent</dfn>, run these steps:

    1. Let |agentCluster| be a new [=ECMAScript/agent cluster=].

    1. Let |agent| be the result of [=creating a new script runner agent=].

    1. Add |agent| to |agentCluster|.

    1. Return |agent|.
</div>

<div algorithm>
  To <dfn>create a new script runner realm</dfn> with a global type |globalType|, run these steps:

    1. [=Assert=] that these steps are running [=in parallel=].

    1. Let |agent| be the result of [=obtaining a script runner agent=] given null, true, and false.
      Run the rest of these steps in |agent|.

       Issue: This exclusively creates a new [=ECMAScript/agent cluster=] for a given script to run
       in, but we should make this work with [=interest group/execution mode=] somehow.

    1. Let |realmExecutionContext| be the result of [=creating a new realm=] given |agent| and the
       following customizations:

        * For the global object, create a new object of type |globalType|.

    1. Let |realm| be |realmExecutionContext|'s Realm component.

    1. Let |global| be |realm|'s [=realm/global object=], and run these steps:

      1. Perform !|global|.\[[Delete]]("`Date`").

      1. If !|global|.\[[HasProperty]]("`Temporal`") is true, then perform
         !|global|.\[[Delete]]("`Temporal`").

      Advisement: This is not the best way to perform such API neutering (see
      <a href="https://github.com/tc39/ecma262/issues/1357#issuecomment-817560121">tc39/ecma262#1357</a>),
      but at the moment it's the way that host environments do this.

      Note: Removing time-referencing APIs from the |global| object is imperative for privacy, as a
      script might otherwise be able to more easily exfiltrate data by using more accurate time
      measurements.

    1. Return |realm|.
</div>

## Script evaluation ## {#script-evaluation}

Concretely, a <dfn>script runner</dfn> is a JavaScript execution environment instantiated with one
of the following global objects:

 * {{InterestGroupBiddingScriptRunnerGlobalScope}}
 * {{InterestGroupScoringScriptRunnerGlobalScope}}
 * {{InterestGroupReportingScriptRunnerGlobalScope}}

<div algorithm>
  To <dfn>evaluate a bidding script</dfn> given a [=string=] |script|, an {{unsigned short}}
  |multiBidLimit|, an [=interest group=] |ig|, a [=reporting context=] |reportingContext|,
  an [=execution metrics=] |executionMetrics|,
  a [=currency tag=] |expectedCurrency|, a {{GenerateBidInterestGroup}} |igGenerateBid|,
  a [=string=]-or-null |auctionSignals|, a [=string=]-or-null |perBuyerSignals|,
  an [=ordered map=]-or-null |sameOriginTrustedBiddingSignals|, an [=ordered map=]-or-null
  |crossOriginTrustedBiddingSignals|, a {{BiddingBrowserSignals}} |browserSignals|,
  a {{DirectFromSellerSignalsForBuyer}} |directFromSellerSignalsForBuyer|, and an integer
  millisecond [=duration=] |timeout|, perform the following steps. They return a [=tuple=] ([=list=]
  of [=generated bids=], [=bid debug reporting info=], [=list=] of [=real time reporting
  contributions=], [=Private Aggregation contributions=], [=execution metrics=]).

    1. Let |realm| be the result of [=creating a new script runner realm=] given
      {{InterestGroupBiddingScriptRunnerGlobalScope}}.
    1. Let |global| be |realm|'s [=realm/global object=].
    1. Let |settings| be |realm|'s [=realm/settings object=].

      Issue: <a href="https://github.com/WICG/turtledove/issues/676">WICG/turtledove#676</a> needs
      to be fixed in order to get |realm|'s [=realm/settings object=].
    1. Set |global|'s
      [=InterestGroupBiddingScriptRunnerGlobalScope/group has ad components=] to true if |ig|'s
      [=interest group/ad components=] is not null, or false otherwise.
    1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/expected currency=] to |expectedCurrency|.
    1. [=Prepare for private aggregation=] given |global|, [=worklet function/generate-bid=],
      |reportingContext|, |ig|'s [=interest group/owner=] and |ig|'s [=interest group/Private
      Aggregation coordinator=].
    1. Let |isComponentAuction| be true if |browserSignals|["{{BiddingBrowserSignals/topLevelSeller}}"] is not null, or
      false otherwise.
    1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/is component auction=] to
      |isComponentAuction|.
    1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/multi-bid limit=] to |multiBidLimit|.
    1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/interest group=] to |ig|.
    1. Let |igJS| be the result of [=converted to ECMAScript values|converting to ECMAScript values=]
      given |igGenerateBid|.
    1. Let |auctionSignalsJS| be the result of [=parsing a JSON string to a JavaScript value=] given
      |auctionSignals| if |auctionSignals| is not null, otherwise {{undefined}}.
    1. Let |perBuyerSignalsJS| be the result of [=parsing a JSON string to a JavaScript value=]
      given |perBuyerSignals| if |perBuyerSignals| is not null, otherwise {{undefined}}.
    1. Let |sameOriginTrustedBiddingSignalsJS| be |sameOriginTrustedBiddingSignals|
       [=converted to ECMAScript values=].
    1. Let |browserSignalsJS| be |browserSignals| [=converted to ECMAScript values=].
    1. Let |directFromSellerSignalsJS| be |directFromSellerSignalsForBuyer|
      [=converted to ECMAScript values=].
    1. Let |crossOriginTrustedBiddingSignalsJS| be |crossOriginTrustedBiddingSignals|
       [=converted to ECMAScript values=].
    1. Let |startTime| be |settings|'s [=environment settings object/current monotonic time=].
    1. Let (|result|, |executionMetrics|'s [=execution metrics/script timed out=]) be the
      result of [=evaluating a script=] with |realm|, |script|, "`generateBid`",
      « |igJS|, |auctionSignalsJS|, |perBuyerSignalsJS|, |sameOriginTrustedBiddingSignalsJS|,
        |browserSignalsJS|, |directFromSellerSignalsJS|, |crossOriginTrustedBiddingSignalsJS| »,
        and |timeout|.
    1. Let |duration| be |settings|'s [=environment settings object/current monotonic time=] minus
      |startTime| in milliseconds.
    1. If |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/priority=] is not null and not failure:
      1. Set |ig|'s [=interest group/priority=] to |global|'s
        [=InterestGroupBiddingScriptRunnerGlobalScope/priority=].
      1. [=list/Replace=] the [=interest group=] that has |ig|'s [=interest group/owner=] and
        [=interest group/name=] in the [=user agent=]'s [=interest group set=] with |ig|.
    1. If |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/priority signals=]
      [=map/is not empty=]:
      1. [=map/For each=] |k| → |v| of |global|'s
        [=InterestGroupBiddingScriptRunnerGlobalScope/priority signals=]:
        1. If |v| is null, [=map/remove=] |ig|'s [=interest group/priority signals overrides=][|k|].
        1. Otherwise, [=map/set=] |ig|'s [=interest group/priority signals overrides=][|k|] to |v|.
      1. [=list/Replace=] the [=interest group=] that has |ig|'s [=interest group/owner=] and
        [=interest group/name=] in the [=user agent=]'s [=interest group set=] with |ig|.
    1. Let |generatedBids| be |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/bids=].
    1. If |result| is a [=ECMAScript/normal completion=]:
      1. Let |generatedBidIDL| be the result of [=converted to an IDL value|converting=]
        |result|'s \[[Value]] to a ({{GenerateBidOutput}} or [=sequence=]<{{GenerateBidOutput}}>).
      1. If no exception was [=exception/thrown=] in the previous step, set |generatedBids| to the
          result of [=converting one or many GenerateBidOutputs to a list of generated bids=] with
          |generatedBidIDL|, |multiBidLimit|, |ig|, |expectedCurrency|, |isComponentAuction|,
          and |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/group has ad components=].
      1. Otherwise, set |generatedBids| to failure.
    1. If |generatedBids| is not a [=list=] of [=generated bids=], set |generatedBids|
       to a new [=list=] of [=generated bids=].
    1. Let |bidDebugReportInfo| be a new [=bid debug reporting info=].
    1. Set |bidDebugReportInfo|'s [=bid debug reporting info/interest group owner=] to
       |ig|'s [=interest group/owner=].
    1. Let |debugLossReportUrl| be |global|'s
      [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/debug loss report url=] if it's not
      failure, null otherwise.
    1. Set |bidDebugReportInfo|'s [=bid debug reporting info/bidder debug loss report url=] to |debugLossReportUrl|.
    1. If |generatedBids| [=list/is not empty=]:
      1. Let |debugWinReportUrl| be |global|'s
        [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/debug win report url=] if it's not
        failure, null otherwise.
      1. Set |bidDebugReportInfo|'s [=bid debug reporting info/bidder debug win report url=] to |debugWinReportUrl|.
      1. [=list/For each=] |generatedBid| in |generatedBids|:
        1. Set |generatedBid|'s [=generated bid/bid duration=] to |duration|,
          [=generated bid/interest group=] to |ig|.
    1. Let |realTimeContributions| be a new [=list=] of [=real time reporting contributions=].
    1. [=list/For each=] |contribution| of |global|'s
      [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/real time reporting contributions=]:
      1. If |contribution|'s [=real time reporting contribution/latency threshold=] is not null, and
        &ge; |duration|, then [=iteration/continue=].
      1. [=list/Append=] |contribution| to |realTimeContributions|.
    1. [=Finalize private aggregation debug info=] given |global|.
    1. Let |paContributions| be the result of [=extracting private aggregation contributions=] given
      |global|.
    1. Return a [=tuple=] (|generatedBids|, |bidDebugReportInfo|, |realTimeContributions|,
                           |paContributions|, |executionMetrics|).
</div>

<div algorithm>
  To <dfn>evaluate a scoring script</dfn> given a [=string=] |script|, a [=string=] |adMetadata|,
  a {{double}} |bidValue|, an [=auction config=] |auctionConfig|, a [=reporting context=]
  |reportingContext|, an [=ordered map=]-or-null |sameOriginTrustedScoringSignals|,
  an [=ordered map=]-or-null |crossOriginTrustedScoringSignals|,
  {{ScoringBrowserSignals}} |browserSignals|, a {{DirectFromSellerSignalsForSeller}}
  |directFromSellerSignalsForSeller|, and an integer millisecond [=duration=] |timeout|:

    1. Let |realm| be the result of [=creating a new script runner realm=] given
      {{InterestGroupScoringScriptRunnerGlobalScope}}.
    1. Let |global| be |realm|'s [=realm/global object=].
    1. Let |settings| be |realm|'s [=realm/settings object=].
    1. [=Prepare for private aggregation=] given |global|, [=worklet function/score-ad=],
      |reportingContext|, |auctionConfig|'s [=auction config/seller=] and |auctionConfig|'s
      [=auction config/seller Private Aggregation coordinator=].
    1. Let |browserSignalsJS| be |browserSignals| [=converted to ECMAScript values=].
    1. Let |auctionConfigJS| be |auctionConfig|'s [=auction config/config idl=] [=converted to
      ECMAScript values=].
    1. Let |sameOriginTrustedScoringSignalsJS| be |sameOriginTrustedScoringSignals|
       [=converted to ECMAScript values=].
    1. Let |crossOriginTrustedScoringSignalsJS| be |crossOriginTrustedScoringSignals|
       [=converted to ECMAScript values=].
    1. Let |directFromSellerSignalsJs| be |directFromSellerSignalsForSeller|
      [=converted to ECMAScript values=].
    1. Let |startTime| be |settings|'s [=environment settings object/current monotonic time=].
    1. Let |executionMetrics| be a new [=execution metrics=].
    1. Let (|scoreAdResult|, |executionMetrics|'s [=execution metrics/script timed out=]) be
      the result of [=evaluating a script=] with |realm|, |script|, "`scoreAd`",
      «|adMetadata|, |bidValue|, |auctionConfigJS|, |sameOriginTrustedScoringSignalsJS|,
      |browserSignalsJS|, |directFromSellerSignalsJs|, |crossOriginTrustedScoringSignalsJS|»,
      and |timeout|.
    1. Let |duration| be |settings|'s [=environment settings object/current monotonic time=] minus
      |startTime| in milliseconds.
    1. Let |debugWinReportUrl| be |global|'s
      [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/debug win report url=] if it's not
      failure, null otherwise.
    1. Let |debugLossReportUrl| be |global|'s
      [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/debug loss report url=] if it's not
      failure, null otherwise.
    1. Let |realTimeContributions| be a new [=list=] of [=real time reporting contributions=].
    1. [=list/For each=] |contribution| of |global|'s
      [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/real time reporting contributions=]:
      1. If |contribution|'s [=real time reporting contribution/latency threshold=] is not null, and
        &ge; |duration|, then [=iteration/continue=].
      1. [=list/Append=] |contribution| to |realTimeContributions|.
    1. [=Finalize private aggregation debug info=] given |global|.
    1. Let |paContributions| be the result of [=extracting private aggregation contributions=] given
      |global|.
    1. Return « |scoreAdResult|, |debugWinReportUrl|, |debugLossReportUrl|, |realTimeContributions|,
        |paContributions|, |executionMetrics| ».
</div>

<div algorithm>
  To <dfn>evaluate a reporting script</dfn> given a [=string=] |script|, a [=string=]
  |functionName|, a [=reporting context=] |reportingContext|, an [=origin=] |origin|, an
  [=origin=] |privateAggregationCoordinator|, an integer millisecond [=duration=] |timeout|,
  and a [=list=] of arguments |arguments|:

    1. Let |realm| be the result of [=creating a new script runner realm=] given
      {{InterestGroupReportingScriptRunnerGlobalScope}}.
    1. Let |global| be |realm|'s [=realm/global object=].
    1. Let |function| be [=worklet function/report-win=]
    1. If |functionName| is `"reportResult"`, set |function| to [=worklet function/report-result=].
    1. [=Prepare for private aggregation=] given |global|, |function|, |reportingContext|, |origin|,
      and |privateAggregationCoordinator|.
    1. Let |argumentsJS| be the result of [=converting a Web IDL arguments list to an ECMAScript
      arguments list|converting=] |arguments| to an ECMAScript arguments list. If this
      [=exception/throws=] an exception, return « "null", null, null, null, a new [=Private
      Aggregation Contributions=], |executionMetrics| ».
    1. Let |executionMetrics| be a new [=execution metrics=].
    1. Let (|result|, |executionMetrics|'s [=execution metrics/script timed out=]) be the
      result of [=evaluating a script=] with |realm|, |script|, |functionName|, |argumentsJS|,
      and |timeout|.
    1. If |result| is an [=ECMAScript/abrupt completion=], return « "null", null, null, null ».
    1. Let |resultJSON| be "null".
    1. If |functionName| is "`reportResult`", then set |resultJSON| to the result of
      [=serializing a JavaScript value to a JSON string=] given |result|.

      Note: Consider a return value that can't be converted to JSON a valid result, so if an
      exception was [=exception/thrown=] in the previous step, keep |resultJSON| as "null".
    1. Let |reportURL| be |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/report url=]
    1. If |reportURL| is failure, set |reportURL| to null.
    1. Let |macroMap| be |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/reporting macro map=]
      if |functionName| is "`reportWin`" or "`reportAdditionalBidWin`", null otherwise.
    1. [=Finalize private aggregation debug info=] given |global|.
    1. Let |paContributions| be the result of [=extracting private aggregation contributions=] given
      |global|.
    1. Return « |resultJSON|, |reportURL|,
      |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/reporting beacon map=], |macroMap|,
      |paContributions|, |executionMetrics| ».
</div>

<div algorithm>
  To <dfn>evaluate a script</dfn> with a [=ECMAScript/realm=] |realm|, [=string=] |script|, [=string=]
  |functionName|, a [=list=] |arguments|, and an integer millisecond [=duration=] |timeout|, run these steps.
  They return a tuple of a [=ECMAScript/Completion Record=], which is either an [=ECMAScript/abrupt
  completion=] (in the case of a parse failure or execution error), or a [=ECMAScript/normal
  completion=] populated with the [=ECMAScript/ECMAScript language value=] result of invoking
  |functionName|, and a [=boolean=] stating whether the script was interrupted due to reaching
  |timeout|.

    1. [=Assert=] that these steps are running [=in parallel=].

    1. If |timeout| &le; 0, return (new [=ECMAScript/throw completion=] given null, true).

    1. Let |timedOut| be false.

    1. Let |global| be |realm|'s [=realm/global object=], and run these steps in |realm|'s [=realm/agent=]:

    1. Let |result| be [$ParseScript$](|script|, |realm|, `empty`).

       Note: The resulting [=ECMAScript/Script Record=] will have no \[[HostDefined]] component,
       unlike traditional [=scripts=] on the web platform.

    1. If |result| is a list of errors, return
       (Completion { \[[Type]]: `throw`, \[[Value]]: |result|, \[[Target]]: `empty` }, false).

    1. [=Assert=]: |result| is a [=ECMAScript/Script Record=].

    1. *Prepare to run script*: Push |realmExecutionContext| onto the [=ECMAScript/execution context
       stack|JavaScript execution context stack=]; it is now the [=ECMAScript/running execution
       context|running JavaScript execution context=].

    1. Let |evaluationStatus| be the result of [$ScriptEvaluation$](result).

      In |timeout| milliseconds, if the invocation of [$ScriptEvaluation$] has not completed,
      [=immediately=] interrupt the execution, set |finalCompletion| to a new
      [=ECMAScript/throw completion=] given null, set |timedOut| to true, and jump to the step
      labeled <i><a href="#evaluate-script-return">return</a></i>.

    1. If |evaluationStatus| is an [=ECMAScript/abrupt completion=], jump to the step labeled <i>
       <a href="#evaluate-script-return">return</a></i>.

    1. Let |F| be [$Get$](|global|, |functionName|). If that returns a [=ECMAScript/throw completion=],
       set |finalCompletion| to |F| and jump to the step labeled <i>
       <a href="#evaluate-script-return">return</a></i>.

    1. Set |finalCompletion| be [=ECMAScript/Completion Record|Completion=]([$Call$](F, `undefined`,
       |arguments|)).

       In |timeout| milliseconds minus the execution time of [$ScriptEvaluation$], if the invocation
       of [$Call$] has not completed, [=immediately=] interrupt the execution, set |finalCompletion|
       to a new [=ECMAScript/throw completion=] given null, and set |timedOut| to true.

    1. <i id=evaluate-script-return>Return</i>: at this point |finalCompletion| will be set to a
       [=ECMAScript/Completion Record=].

      1. *Clean up after script*: [=Assert=] |realmExecutionContext| is the [=ECMAScript/running
         execution context|running JavaScript execution context=], and remove it from the
         [=ECMAScript/execution context stack|JavaScript execution context stack=].

      1. Return (|finalCompletion|, timedOut).
</div>

## Global scopes ## {#global-scopes}

An additional requirement to the interest group script runner globals defined in this specification
is that they must not expose any interfaces from other specifications whose own exposure set is the
special value "*". The only interfaces that can be exposed inside of the globals defined in this
specification are those that explicitly list the global names provided here.

<pre class="idl">
[Exposed=InterestGroupScriptRunnerGlobalScope]
interface InterestGroupScriptRunnerGlobalScope {
  readonly attribute PrivateAggregation? privateAggregation;
};

dictionary PASignalValue {
  required DOMString baseValue;
  double scale;
  (bigint or long) offset;
};

dictionary PAExtendedHistogramContribution {
  required (PASignalValue or bigint) bucket;
  required (PASignalValue or long) value;
  bigint filteringId = 0;
};

[Exposed=InterestGroupScriptRunnerGlobalScope]
partial interface PrivateAggregation {
  undefined contributeToHistogramOnEvent(
      DOMString event, PAExtendedHistogramContribution contribution);
};

</pre>

Each {{InterestGroupScriptRunnerGlobalScope}} has a
<dl dfn-for="InterestGroupScriptRunnerGlobalScope">
  : <dfn>private aggregation</dfn>
  :: Null, or a [=PrivateAggregation=]. Initially null.
  : <dfn>on event contribution map</dfn>
  :: A [=map=] from [=string=] to a [=list=] of [=on event contribution entries=].
  : <dfn>worklet function</dfn>
  :: A [=worklet function=]. Affects some
    [Private Aggregation API](https://github.com/patcg-individual-drafts/private-aggregation-api)
    functionality.
  : <dfn>origin</dfn>
  :: The [=origin=] of the script being executed.
</dl>

<div algorithm>
The <dfn attribute for=InterestGroupScriptRunnerGlobalScope>privateAggregation</dfn> [=getter
  steps=] are:

  1. Return [=this=]'s [=relevant global object=]'s
    [=InterestGroupScriptRunnerGlobalScope/private aggregation=].
</div>

<div algorithm>
The <dfn method for="PrivateAggregation">contributeToHistogramOnEvent(DOMString
event, PAExtendedHistogramContribution contribution)</dfn> method steps are:
1. Let |global| be [=this=]'s [=relevant global object=].
1. Let |function| be |global|'s [=InterestGroupScriptRunnerGlobalScope/worklet function=].
1. Let |origin| be |global|'s [=InterestGroupScriptRunnerGlobalScope/origin=].
1. If [=this=]'s <a spec="private-aggregation-api" for="PrivateAggregation">
  allowed to use</a> is false, [=exception/throw=] a {{TypeError}}.
1. Let |scopingDetails| be [=this=]'s <a spec="private-aggregation-api" for="PrivateAggregation">
  scoping details</a>
1. If |event| [=string/starts with=] "`reserved.`" and « "`reserved.always`",
    "`reserved.loss`", "`reserved.win`", "`reserved.once`" » does not [=list/contain=] |event|,
    return.

    Note: No error is thrown to allow forward compatibility if additional
        reserved event types are added later.
1. If |event| is "`reserved.once`" and |function| is [=worklet function/report-result=] or
  [=worklet function/report-win=], [=exception/throw=] a {{TypeError}}.
1. Let |bucket| be |contribution|["{{PAExtendedHistogramContribution/bucket}}"].
1. If |bucket| is a {{PASignalValue}}:
    1. If |bucket|["{{PASignalValue/baseValue}}"] is not a valid [=signal base
        value=], [=exception/throw=] a {{TypeError}}.
    1. If |bucket|["{{PASignalValue/offset}}"] is not a {{bigint}}, [=exception/
        throw=] a {{TypeError}}.
1. Otherwise, if |contribution|["{{PAExtendedHistogramContribution/bucket}}"] is
    not [=set/contained=] in [=the exclusive range|the range=] 0 to
    2<sup>128</sup>, exclusive, [=exception/throw=] a {{TypeError}}.

    Issue: Make the error type consistent with
        {{PrivateAggregation/contributeToHistogram(contribution)}}.
1. Let |value| be |contribution|["{{PAExtendedHistogramContribution/value}}"].
1. If |value| is a {{PASignalValue}}:
    1. If |value|["{{PASignalValue/baseValue}}"] is not a valid [=signal base
        value=], [=exception/throw=] a {{TypeError}}.
    1. If |value|["{{PASignalValue/offset}}"] is a {{bigint}}, [=exception/
        throw=] a {{TypeError}}.
1. Otherwise, if |contribution|["{{PAExtendedHistogramContribution/value}}"] is
    negative, [=exception/throw=] a {{TypeError}}.
1. If |contribution|["{{PAExtendedHistogramContribution/filteringId}}"] is
    not [=set/contained=] in [=the exclusive range|the range=] 0 to
    256<sup>[=default filtering ID max bytes=]</sup>, exclusive, [=exception/
    throw=] a {{TypeError}}.

    Issue: Make the error types on validation issues here and above consistent
        with {{PrivateAggregation/contributeToHistogram(contribution)}}.

    Note: It is not currently possible to set a non-default filtering ID max
        bytes for Protected Audience.
1. If |event| does not [=string/start with=] "`reserved.`", and |function| is
  [=worklet function/score-ad=] or [=worklet function/report-result=], return.
1. Let |batchingScope| be null.
1. If |event| [=string/starts with=] "`reserved.`", set |batchingScope| to the
    result of running |scopingDetails|' <a spec="private-aggregation-api" for="scoping details">
    get batching scope steps</a>.

    Note: Each non-reserved |event| will have a different [=batching scope=]
        that is created later.
1. Let |entry| be a new [=on event contribution entry=] with the items:
    : [=on event contribution entry/contribution=]
    :: |contribution|
    : [=on event contribution entry/batching scope=]
    :: |batchingScope|
    : [=on event contribution entry/debug scope=]
    :: The result of running |scopingDetails|' <a spec="private-aggregation-api"
      for="scoping details">get debug scope steps</a>.
    : [=on event contribution entry/worklet function=]
    :: |function|
    : [=on event contribution entry/origin=]
    :: |origin|
1. Let |onEventContributionMap| be |global|'s
    [=InterestGroupScriptRunnerGlobalScope/on event contribution map=].
1. If |onEventContributionMap|[|event|] does not [=map/exist=], set
    |onEventContributionMap|[|event|] to a new [=list=].
1. [=list/Append=] |entry| to |onEventContributionMap|[|event|].

</div>

<pre class="idl">
[Exposed=InterestGroupBiddingAndScoringScriptRunnerGlobalScope]
interface ForDebuggingOnly {
  undefined reportAdAuctionWin(USVString url);
  undefined reportAdAuctionLoss(USVString url);
};

[Exposed=InterestGroupBiddingAndScoringScriptRunnerGlobalScope]
interface RealTimeReporting {
  undefined contributeToHistogram(RealTimeContribution contribution);
};

dictionary RealTimeContribution {
  required long bucket;
  required double priorityWeight;
  long latencyThreshold;
};

[Exposed=InterestGroupBiddingAndScoringScriptRunnerGlobalScope,
 Global=InterestGroupBiddingAndScoringScriptRunnerGlobalScope]
interface InterestGroupBiddingAndScoringScriptRunnerGlobalScope : InterestGroupScriptRunnerGlobalScope {
  readonly attribute ForDebuggingOnly forDebuggingOnly;
  readonly attribute RealTimeReporting realTimeReporting;
};

</pre>

Each {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope}} has an associated {{ForDebuggingOnly}}
instance <dfn for=InterestGroupBiddingAndScoringScriptRunnerGlobalScope>forDebuggingOnly</dfn>, and
an associated {{RealTimeReporting}} instance
<dfn for=InterestGroupBiddingAndScoringScriptRunnerGlobalScope>realTimeReporting</dfn>, which are
created alongside the {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope}}.


<div algorithm>
The <dfn attribute for=InterestGroupBiddingAndScoringScriptRunnerGlobalScope>forDebuggingOnly</dfn>
getter steps are:

  1. Return [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly=].
</div>

Each {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope}} has a
<dl dfn-for="InterestGroupBiddingAndScoringScriptRunnerGlobalScope">
  : <dfn>debug win report url</dfn>
  :: Null, failure, or a [=URL=] whose [=url/scheme=] is "`https`". Initially null.
  : <dfn>debug loss report url</dfn>
  :: Null, failure, or a [=URL=] whose [=url/scheme=] is "`https`". Initially null.
</dl>

<div algorithm>
The <dfn method for="ForDebuggingOnly">reportAdAuctionWin(|url|)</dfn> method steps are:

  1. Let |global| be [=this=]'s [=relevant global object=].
  1. Let |parsedUrl| be the result of running the [=URL parser=] on |url|.
  1. If |parsedUrl| is failure, or |parsedUrl|'s [=url/scheme=] is not "`https`", then set |global|'s
      [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/debug win report url=] to failure.
  1. Optionally, return.

    Note: This [=implementation-defined=] condition is intended to allow [=user agents=] to decline
        for a number of reasons, for example the |parsedUrl|'s [=site=] not being
        <a href="https://github.com/privacysandbox/attestation">enrolled</a>.

  1. Set |global|'s
    [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/debug win report url=] to |parsedUrl|.
</div>

<div algorithm>
The <dfn method for="ForDebuggingOnly">reportAdAuctionLoss(|url|)</dfn> method steps are:

  1. Let |global| be [=this=]'s [=relevant global object=].
  1. Let |parsedUrl| be the result of running the [=URL parser=] on |url|.
  1. If |parsedUrl| is failure, or |parsedUrl|'s [=url/scheme=] is not "`https`", then set |global|'s
      [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/debug loss report url=] to failure.
  1. Optionally, return.

    Note: This [=implementation-defined=] condition is intended to allow [=user agents=] to decline
        for a number of reasons, for example the |parsedUrl|'s [=site=] not being
        <a href="https://github.com/privacysandbox/attestation">enrolled</a>.

  1. Set |global|'s
    [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/debug loss report url=] to |parsedUrl|.
</div>


<div algorithm>
The <dfn attribute for=InterestGroupBiddingAndScoringScriptRunnerGlobalScope>realTimeReporting</dfn>
getter steps are:

  1. Return [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/realTimeReporting=].
</div>

Each {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope}} has a
<dl dfn-for="InterestGroupBiddingAndScoringScriptRunnerGlobalScope">
  : <dfn>real time reporting contributions</dfn>
  :: A [=list=] of [=real time reporting contributions=].
</dl>

<div algorithm>
The <dfn method for="RealTimeReporting">contributeToHistogram({{RealTimeContribution}} |contribution|)</dfn>
method steps are:

  1. Let |global| be [=this=]'s [=relevant global object=].
  1. If |contribution|["{{RealTimeContribution/bucket}}"] &ge; [=number of user buckets=] or is
    negative, then return;

    Note: For forward compatibility with new values, don't [=exception/throw=].

  1. If |contribution|["{{RealTimeContribution/priorityWeight}}"] &le; 0, then [=exception/throw=] a
    {{TypeError}}.
  1. Let |contributionEntry| be a new [=real time reporting contribution=] with the following
    [=struct/items=]:
    : [=real time reporting contribution/bucket=]
    :: |contribution|["{{RealTimeContribution/bucket}}"]
    : [=real time reporting contribution/priority weight=]
    :: |contribution|["{{RealTimeContribution/priorityWeight}}"]
    : [=real time reporting contribution/latency threshold=]
    :: |contribution|["{{RealTimeContribution/latencyThreshold}}"] if it [=map/exists=], null otherwise
  1. [=list/Append=] |contributionEntry| to |global|'s
    [=InterestGroupBiddingAndScoringScriptRunnerGlobalScope/real time reporting contributions=].
</div>

### InterestGroupBiddingScriptRunnerGlobalScope ### {#bidding-global-scope}

<pre class="idl">
[Exposed=InterestGroupBiddingScriptRunnerGlobalScope,
 Global=(InterestGroupScriptRunnerGlobalScope,
         InterestGroupBiddingScriptRunnerGlobalScope)]
interface InterestGroupBiddingScriptRunnerGlobalScope
        : InterestGroupBiddingAndScoringScriptRunnerGlobalScope {
  boolean setBid(optional (GenerateBidOutput or sequence&lt;GenerateBidOutput&gt;) oneOrManyBids = []);
  undefined setPriority(double priority);
  undefined setPrioritySignalsOverride(DOMString key, optional double? priority);
};

dictionary AdRender {
  required DOMString url;
  DOMString width;
  DOMString height;
};

dictionary GenerateBidOutput {
  double bid = -1;
  DOMString bidCurrency;
  (DOMString or AdRender) render;
  any ad;
  USVString selectedBuyerAndSellerReportingId;
  sequence<(DOMString or AdRender)> adComponents;
  double adCost;
  unrestricted double modelingSignals;
  boolean allowComponentAuction = false;
  unsigned long targetNumAdComponents;
  unsigned long numMandatoryAdComponents = 0;
};

</pre>

Each {{InterestGroupBiddingScriptRunnerGlobalScope}} has a
<dl dfn-for="InterestGroupBiddingScriptRunnerGlobalScope">
: <dfn>bids</dfn>
:: A [=list=] of [=generated bids=], initially empty.
: <dfn>priority</dfn>
:: Null, failure, or a {{double}}, initially null.
: <dfn>priority signals</dfn>
:: An [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are {{double}} or null.
: <dfn>interest group</dfn>
:: An [=interest group=]
: <dfn>expected currency</dfn>
:: A [=currency tag=]
: <dfn>is component auction</dfn>
:: A [=boolean=]
: <dfn>group has ad components</dfn>
:: A [=boolean=]
: <dfn>multi-bid limit</dfn>
:: An {{unsigned short}}.

</dl>

<div algorithm>
To <dfn>convert one or many GenerateBidOutputs to a list of generated bids</dfn> given a
({{GenerateBidOutput}} or [=sequence=]<{{GenerateBidOutput}}>) |oneOrManyBids|, an {{unsigned short}}
|multiBidLimit|, an [=interest group=] |ig|, a [=currency tag=] |expectedCurrency|, a [=boolean=]
|isComponentAuction| and a [=boolean=] |groupHasAdComponents|:

  1. Let |bidSequence| be [=sequence=]<{{GenerateBidOutput}}>.
  1. If the [=specific type=] of |oneOrManyBids| is {{GenerateBidOutput}}, then set |bidSequence| to « |oneOrManyBids| ».
  1. Otherwise, set |bidSequence| to |oneOrManyBids|.
  1. If |bidSequence|'s [=list/size=] &gt; |multiBidLimit|, then return failure.
  1. Let |bids| be a new [=list=] of [=generated bids=].
  1. [=list/for each=] |bidOutput| of |bidSequence|:
    1. Let |bid| be the result of [=converting GenerateBidOutput to generated bid=] given |bidOutput|, |ig|, |expectedCurrency|, |isComponentAuction|, |groupHasAdComponents|.
    1. If |bid| is failure, return failure.
    1. If |bid| is null, [=iteration/continue=].
    1. [=list/Append=] |bid| to |bids|.
  1. Return |bids|.
</div>

<div algorithm>

To <dfn>convert GenerateBidOutput to generated bid</dfn> given a {{GenerateBidOutput}}
|generateBidOutput|, an [=interest group=] |ig|, a [=currency tag=] |expectedCurrency|, a [=boolean=]
|isComponentAuction| and a [=boolean=] |groupHasAdComponents|:
  1. If |generateBidOutput|["{{GenerateBidOutput/bid}}"] &le; 0, then return null.
  1. Let |bid| be a new [=generated bid=].
  1. If |generateBidOutput|["{{GenerateBidOutput/render}}"] does not [=map/exist=], return failure.
  1. If |isComponentAuction| is true, and
    |generateBidOutput|["{{GenerateBidOutput/allowComponentAuction}}"] is false, then return failure.
  1. Let |bidCurrency| be null.
  1. If |generateBidOutput|["{{GenerateBidOutput/bidCurrency}}"] is specified:
     1. If the result of [=checking whether a string is a valid currency tag=] on
      |generateBidOutput|["{{GenerateBidOutput/bidCurrency}}"] is true, then set |bidCurrency| to
      |generateBidOutput|["{{GenerateBidOutput/bidCurrency}}"], otherwise return failure.
  1. If the result of [=checking a currency tag=] with |expectedCurrency| and |bidCurrency| is
    false, return failure.
  1. Set |bid|'s [=generated bid/bid=] to a [=bid with currency=] with [=bid with currency/value=]
    |generateBidOutput|["{{GenerateBidOutput/bid}}"] and [=bid with currency/currency=] |bidCurrency|.
  1. If |generateBidOutput|["{{GenerateBidOutput/ad}}"] [=map/exists=]:
    1. Let |adJSON| be the result of [=serializing a JavaScript value to a JSON string=], given
      |generateBidOutput|["{{GenerateBidOutput/ad}}"].
    1. If |adJSON| is failure, return failure.
    1. Set |bid|'s [=generated bid/ad=] to |adJSON|.
  1. Let |adDescriptor| be a new [=ad descriptor=].
  1. If |generateBidOutput|["{{GenerateBidOutput/render}}"] is a {{DOMString}}:
    1. Let |adUrl| be the result of running the [=URL parser=] on
      |generateBidOutput|["{{GenerateBidOutput/render}}"].
    1. If |adUrl| is failure, return failure.
    1. Set |adDescriptor|'s [=ad descriptor/url=] to |adUrl|.
  1. Otherwise:
    1. Set |adDescriptor| to the result of [=converting an ad render=] given
      |generateBidOutput|["{{GenerateBidOutput/render}}"].
    1. If |adDescriptor| is failure, return failure.
  1. Let |bidAd| be the result of [=finding matching ad=] given |adDescriptor|, |ig|, and false.
  1. If |bidAd| is null, return failure.
  1. Set |bid|'s [=generated bid/ad descriptor=] to |adDescriptor|.
  1. Set |bid|'s [=generated bid/bid ad=] to |bidAd|.
  1. If |generateBidOutput|["{{GenerateBidOutput/selectedBuyerAndSellerReportingId}}"] [=map/exists=]:
    1. If |bidAd|'s [=interest group ad/selectable buyer and seller reporting IDs=] is null, or does not
      [=list/contain=] |generateBidOutput|["{{GenerateBidOutput/selectedBuyerAndSellerReportingId}}"],
      return failure.
    1. Set |bid|'s [=generated bid/selected buyer and seller reporting ID=] to
      |generateBidOutput|["{{GenerateBidOutput/selectedBuyerAndSellerReportingId}}"].
  1. If |generateBidOutput|["{{GenerateBidOutput/adComponents}}"] [=map/exists=]:
    1. Let |adComponents| be |generateBidOutput|["{{GenerateBidOutput/adComponents}}"].
    1. Return failure if any of the following conditions hold:
      * |groupHasAdComponents| is false;
      * |adComponents|'s size is greater than 40 and |generateBidOutput|["{{GenerateBidOutput/targetNumAdComponents}}"] does not [=map/exist=].
    1. Let |adComponentDescriptors| be a new [=list=] of [=ad descriptors=].
    1. For |component| in |adComponents|:
      1. Let |componentDescriptor| be a new [=ad descriptor=].
      1. If |component| is {{DOMString}}:
        1. Let |componentUrl| be the result of running the [=URL parser=] on |component|.
        1. If |componentUrl| is failure, return failure.
        1. Set |componentDescriptor|'s [=ad descriptor/url=] to |componentUrl|.
      1. Otherwise:
        1. Set |componentDescriptor| to the result of [=converting an ad render=] given |component|.
        1. If |componentDescriptor| is failure, return failure.
      1. Let |bidComponentAd| be result of [=finding matching ad=] given |componentUrl|, |ig|, and
        true.
      1. If |bidComponentAd| is null, return failure.
      1. [=list/Append=] |bidComponentAd| to |bid|'s [=generated bid/bid ad components=].
      1. [=list/Append=] |componentDescriptor| to |adComponentDescriptors|.
    1. Set |bid|'s [=generated bid/ad component descriptors=] to |adComponentDescriptors|.
  1. If |generateBidOutput|["{{GenerateBidOutput/targetNumAdComponents}}"] [=map/exists=]:
    1. If |generateBidOutput|["{{GenerateBidOutput/targetNumAdComponents}}"] is equal to 0 or
       greater than 40, then return failure.
    1. If |bid|'s [=generated bid/ad component descriptors=] is null, or
          |bid|'s [=generated bid/ad component descriptors=]'s [=list/size=] &lt;
          |generateBidOutput|["{{GenerateBidOutput/targetNumAdComponents}}"], return failure.
    1. If |generateBidOutput|["{{GenerateBidOutput/targetNumAdComponents}}"] &lt;
          |generateBidOutput|["{{GenerateBidOutput/numMandatoryAdComponents}}"], return failure.
    1. Set |bid|'s [=generated bid/target number of ad components=] to
       |generateBidOutput|["{{GenerateBidOutput/targetNumAdComponents}}"].
    1. Set |bid|'s [=generated bid/number of mandatory ad components=] to
       |generateBidOutput|["{{GenerateBidOutput/numMandatoryAdComponents}}"].
  1. If |generateBidOutput|["{{GenerateBidOutput/adCost}}"] [=map/exists=], then set |bid|'s
    [=generated bid/ad cost=] to |generateBidOutput|["{{GenerateBidOutput/adCost}}"].
  1. If |generateBidOutput|["{{GenerateBidOutput/modelingSignals}}"] [=map/exists=]:
    1. Let |modelingSignals| be |generateBidOutput|["{{GenerateBidOutput/modelingSignals}}"].
    1. If |modelingSignals| &ge; 0 and |modelingSignals| &lt; 4096, then set |bid|'s
      [=generated bid/modeling signals=] to the result of [=converted to an IDL value|converting=]
      the ECMAScript value represented by |modelingSignals| to an {{unsigned short}}.
  1. Return |bid|.

</div>

<div algorithm>
  To <dfn>parse an AdRender dimension value</dfn> given a [=string=] |input|:

  1. Let |position| be a [=string/position variable=], initially pointing at the start of |input|.
  1. [=Strip leading and trailing ASCII whitespace=] from |input|.
  1. If |input| [=string/starts with=] "`0`" but [=string/is=] not "`0`" and does not
    [=string/start with=] "`0.`", then return null as the dimension and the empty string as the
    dimension unit.
  1. [=Collect a sequence of code points=] that are [=ASCII digits=] or U+002E (.), given |position|.
    Let that be |dimensionString|.
  1. If |dimensionString| is the empty string, then return null as the dimension and the empty
    string as the dimension unit.
  1. Let |dimension| be the result of parsing |dimensionString| using the
    [=rules for parsing floating-point number values=].
  1. If |dimension| is an error, then return null as the dimension and the empty string as the dimension unit.
  1. If |dimension| is less than 0, then return null as the dimension and the empty string as the
     dimension unit.
  1. [=Collect a sequence of code points=] that are [=ASCII lower alpha=], given |position|. Let
    that be |dimensionUnit|.
  1. If |position| is not past the end of |input|, then return null as the dimension and the empty
    string as the dimension unit.
  1. If |dimensionUnit| [=string/is=] the empty string, then set |dimensionUnit| to "px".
  1. If |dimensionUnit| [=string/is=] not "px", "sh", or "sw", then return null as the dimension and
    the empty string as the dimension unit.
  1. Return |dimension| as the dimension and |dimensionUnit| as the dimension unit.
</div>

<div algorithm>
  To <dfn>convert an ad render</dfn> given an {{AdRender}} |adRender|:

  1. Let |adUrl| be the result of running the [=URL parser=] on |adRender|["{{AdRender/url}}"].
  1. If |adUrl| is failure, return failure.
  1. Let |adDescriptor| be a new [=ad descriptor=].
  1. Set |adDescriptor|'s [=ad descriptor/url=] to |adUrl|.
  1. If |adRender|["{{AdRender/width}}"] [=map/exists=]:
    1. If |adRender|["{{AdRender/height}}"] does not [=map/exist=], return failure.
    1. Let |width| and |widthUnit| be the dimension and dimension unit that results from running
      [=parse an AdRender dimension value=] with |adRender|["{{AdRender/width}}"], respectively.
    1. If |width| is null, return failure.
    1. Let |height| and |heightUnit| be the dimension and dimension unit that results from running
      [=parse an AdRender dimension value=] with |adRender|["{{AdRender/height}}"], respectively.
    1. If |height| is null, return failure.
    1. Let |adSize| be a new [=ad size=].
    1. Set |adSize|'s [=ad size/width=] to |width|, [=ad size/width units=] to |widthUnit|,
      [=ad size/height=] to |height|, [=ad size/height units=] to |heightUnit|.
    1. Set |adDescriptor|'s [=ad descriptor/size=] to |adSize|.
  1. Return |adDescriptor|.
</div>

<div algorithm>
  To <dfn>find matching ad</dfn> given an [=ad descriptor=] |adDescriptor|, an [=interest group=]
  |ig|, and a [=boolean=] |isComponent|:

  1. Let |adUrl| be |adDescriptor|'s [=ad descriptor/url=].
  1. If |adUrl|'s [=url/scheme=] is not "`https`", return null.
  1. Let |maybeMatchingAd| be an [=interest group ad=]-or null, set to null.
  1. Let |adSize| be |adDescriptor|'s [=ad descriptor/size=].
  1. Let |adList| be |ig|'s [=interest group/ad components=] if |isComponent|, otherwise |ig|'s
     [=interest group/ads=].
  1. [=list/For each=] |ad| in |adList|:
    1. If |ad|'s [=interest group ad/render url=] does not equal |adUrl|, [=iteration/continue=].
    1. If |ad|'s [=interest group ad/size group=] is null and |adSize| is null, set |maybeMatchingAd|
      to |ad|, and [=iteration/break=].
    1. If one of |ad|'s [=interest group ad/size group=] OR |adSize| is null, set |maybeMatchingAd|
      to |ad|, and [=iteration/break=].

      Note: When only one of the two ads has a size specification, they are considered matching. The
        caller is responsible for discarding the extraneous size information.
    1. [=list/For each=] |igSize| in (|ig|'s [=interest group/size groups=])[|ad|'s
       [=interest group ad/size group=]]:
      1. If |igSize| equals |adSize|, set |maybeMatchingAd| to |ad|, and [=iteration/break=].
  1. Return null.
</div>

<div algorithm>
  The <dfn method for="InterestGroupBiddingScriptRunnerGlobalScope">setBid(|oneOrManyBids|)</dfn>
  method steps are:

  1. Let |global| be [=this=]'s [=relevant global object=].
  1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/bids=] to an empty [=list=].
  1. Let |ig| be |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/interest group=].
  1. Let |expectedCurrency| be |global|'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/expected currency=].
  1. Let |bidsToSet| be the result of [=converting one or many GenerateBidOutputs to a list of generated bids=] with
    |oneOrManyBids|, |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/multi-bid limit=],
    |ig|, |expectedCurrency|, |global|'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/is component auction=], and |global|'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/group has ad components=].
  1. If |bidsToSet| is failure, [=exception/throw=] a {{TypeError}}.
  1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/bids=] to |bidsToSet|.
</div>

<div algorithm>
  The <dfn method for="InterestGroupBiddingScriptRunnerGlobalScope">setPriority(|priority|)</dfn>
  method steps are:

  1. Let |global| be [=this=]'s [=relevant global object=].
  1. If |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/priority=] is not null, then set
    |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/priority=] to failure, and
    [=exception/throw=] a {{TypeError}}.
  1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/priority=] to |priority|.
</div>

<div algorithm>
  The <dfn method for="InterestGroupBiddingScriptRunnerGlobalScope">setPrioritySignalsOverride(|key|, |priority|)</dfn>
  method steps are:

  1. [=map/Set=] [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/priority signals=][|key|] to |priority|.
</div>

### InterestGroupScoringScriptRunnerGlobalScope ### {#scoring-global-scope}

<pre class="idl">
[Exposed=InterestGroupScoringScriptRunnerGlobalScope,
 Global=(InterestGroupScriptRunnerGlobalScope,
         InterestGroupScoringScriptRunnerGlobalScope)]
interface InterestGroupScoringScriptRunnerGlobalScope
        : InterestGroupBiddingAndScoringScriptRunnerGlobalScope {
};

</pre>

### InterestGroupReportingScriptRunnerGlobalScope ### {#reporting-global-scope}

<pre class="idl">
[Exposed=InterestGroupReportingScriptRunnerGlobalScope,
 Global=(InterestGroupScriptRunnerGlobalScope,
         InterestGroupReportingScriptRunnerGlobalScope)]
interface InterestGroupReportingScriptRunnerGlobalScope
        : InterestGroupScriptRunnerGlobalScope {
  undefined sendReportTo(DOMString url);
  undefined registerAdBeacon(record&lt;DOMString, USVString&gt; map);
  undefined registerAdMacro(DOMString name, USVString value);
};

</pre>

Note: {{InterestGroupReportingScriptRunnerGlobalScope/registerAdMacro(name, value)}} is only
available in [=report win=], but not [=report result=].

Each {{InterestGroupReportingScriptRunnerGlobalScope}} has a
<dl dfn-for="InterestGroupReportingScriptRunnerGlobalScope">
: <dfn>report url</dfn>
:: Null, failure, or a [=URL=] whose [=url/scheme=] is "`https`". Initially null.
: <dfn>reporting beacon map</dfn>
:: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
  [=URLs=] whose [=url/schemes=] are "`https`". Initially null.
: <dfn>reporting macro map</dfn>
:: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
  [=strings=]. Initially null.

</dl>

<div algorithm>
  The <dfn method for="InterestGroupReportingScriptRunnerGlobalScope">sendReportTo(|url|)</dfn>
  method steps are:

  1. Let |global| be [=this=]'s [=relevant global object=].
  1. If |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/report url=] is not null, then
    set |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/report url=] to failure, and
    [=exception/throw=] a {{TypeError}}.
  1. Let |parsedUrl| be the result of running the [=URL parser=] on |url|.
  1. If |parsedUrl| is failure, or |parsedUrl|'s [=url/scheme=] is not "`https`", set |global|'s
    [=InterestGroupReportingScriptRunnerGlobalScope/report url=] to failure, and [=exception/throw=]
    a {{TypeError}}.
  1. Optionally, return.

    Note: This [=implementation-defined=] condition is intended to allow [=user agents=] to decline
        for a number of reasons, for example the |parsedUrl|'s [=site=] not being
        <a href="https://github.com/privacysandbox/attestation">enrolled</a>.
  1. Set |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/report url=] to |parsedUrl|.
</div>

<div algorithm>
  The <dfn method for="InterestGroupReportingScriptRunnerGlobalScope">registerAdBeacon(|map|)</dfn>
  method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=InterestGroupReportingScriptRunnerGlobalScope/
     reporting beacon map=] is not null, then [=exception/Throw=] a {{TypeError}}.

  1. [=map/For each=] |type| → |url| of |map|:

     1. If |type| [=string/starts with=] "`reserved.`" and |type| does not match one of the
        [=fencedframetype/automatic beacon event type=] values, [=exception/throw=] a {{TypeError}}.

     1. Let |parsedURL| be the result of running [=URL parser=] on |url|.

     1. [=exception/Throw=] a {{TypeError}} if any of the following conditions hold:
        * |parsedURL| is failure;
        * |parsedURL|'s [=url/scheme=] is not "`https`".

  1. Set [=this=]'s [=relevant global object=]'s [=InterestGroupReportingScriptRunnerGlobalScope/
     reporting beacon map=] to |map|.
</div>

<div algorithm>
  The <dfn method for="InterestGroupReportingScriptRunnerGlobalScope">registerAdMacro(|name|,
  |value|)</dfn> method steps are:
  1. [=list/For each=] [=code unit=] |c| in |name|:
     1. [=exception/Throw=] a {{TypeError}} if both of the following conditions hold:
        * |c| is not an [=unreserved percent encoding character=];
        * |c| is not "`%`".

  1. [=list/For each=] [=code unit=] |c| in |value|:
     1. [=exception/Throw=] a {{TypeError}} if both of the following conditions hold:
        * |c| is not an [=unreserved percent encoding character=];
        * |c| is not "`%`".

  1. [=map/Set=] [=this=]'s [=relevant global object=]'s
    [=InterestGroupReportingScriptRunnerGlobalScope/reporting macro map=][|name|] to |value|.
</div>

# Interest Group Updates # {#interest-group-updates}

*This first introductory paragraph is non-normative.*

[=Interest groups=] have an [=interest group/update url=] field that allows updating the
interest group definition stored on disk with information periodically retrieved from the
[=interest group/update url=].  The [=interest group update=] steps are triggered during
{{Navigator/runAdAuction()}} and by calls to {{Navigator/updateAdInterestGroups()}} API:

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  undefined updateAdInterestGroups();
};
</xmp>

<div algorithm>

The <dfn for=Navigator method>updateAdInterestGroups()</dfn> method steps are:

1. Let |settings| be [=this=]'s [=relevant settings object=].
1. [=In parallel=], run [=interest group update=] with « |settings|'s [=environment/top-level origin=] »,
  and |settings|'s [=environment settings object/policy container=].

</div>
<div algorithm>
  To <dfn lt="interest group update">update interest groups</dfn> given a [=list=] of [=origins=]
  |owners|, and a [=policy container=] |policyContainer|:

Implementations can consider aborting all updating if updating has been running for too long. This
can avoid continuing to reveal coarse IP location information to update servers long after
navigating to another page. Some implementations, such as Chromium, have chosen a 10 minute limit.

1. [=list/For each=] |owner| of |owners|:
  1. [=list/For each=] |originalInterestGroup| of the [=user agent=]'s [=interest group set=] whose
    [=interest group/owner=] is |owner| and [=interest group/next update after=] is before
    the [=current coarsened wall time=] and whose [=interest group/update url=] is not null:

    Note: Implementations can consider loading only a portion of these interest groups
    at a time to avoid issuing too many requests at once.
    1. Let |ig| be a deep copy of |originalInterestGroup|.
    1. Run [=update k-anonymity cache for interest group=] for |ig|.
    1. Let |request| be a new [=request=] with the following properties:
      :   [=request/URL=]
      ::  |ig|'s [=interest group/update url=]
      :   [=request/header list=]
      ::  «`Accept`: `application/json`»
      :   [=request/client=]
      ::  `null`
      :   [=request/origin=]
      ::  |owner|
      :   [=request/mode=]
      ::  "`no-cors`"
      :   [=request/referrer=]
      ::  "`no-referrer`"
      :   [=request/credentials mode=]
      ::  "`omit`"
      :   [=request/redirect mode=]
      ::  "`error`"
      :   [=request/service-workers mode=]
      ::  "`none`"
      :   [=request/policy container=]
      ::  A new [=policy container=] whose [=policy container/IP address space=] is |policyContainer|'s
        [=policy container/IP address space=]

      Issue: Stop using "`no-cors`" mode where possible
      (<a href="https://github.com/WICG/turtledove/issues/667">WICG/turtledove#667</a>).
    1. Let |update| be null.
    1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true, and
      [=fetch/processResponseConsumeBody=] set to the following steps given a [=response=] |response|
      and null, failure, or a [=byte sequence=] |responseBody|:
      1. If [=validate fetching response=] with |response|, |responseBody| and "`application/json`"
        returns false, set |update| to failure and return.
      1. Set |update| to |responseBody|.
    1. Wait for |update| to be set.
    1. If |update| is failure, [=iteration/continue=].
    1. Let |parsedUpdate| be the result of [=parsing JSON bytes to an Infra value=], given |update|.
    1. If |parsedUpdate| is failure, [=iteration/continue=].
    1. If |parsedUpdate| is not an [=ordered map=], [=iteration/continue=].
    1. If |parsedUpdate|["`name`"] exists and doesn't match |ig|'s [=interest group/name=],
      [=iteration/continue=].
    1. If |parsedUpdate|["`owner`"] exists and doesn't match |ig|'s [=interest group/owner=],
      [=iteration/continue=].
    1. [=map/For each=] |key| → |value| of |parsedUpdate|:
      1. Switch on |key|:
        <dl class=switch>
        <dt>"`priority`"
        <dd>
        1. If |value| is a {{double}}, set |ig|'s [=interest group/priority=]
          to |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`enableBiddingSignalsPrioritization`"
        <dd>
        1. If |value| is a {{boolean}}, set |ig|'s
          [=interest group/enable bidding signals prioritization=] to |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`priorityVector`"
        <dd>
        1. If |value| is null or an [=ordered map=] whose [=map/keys=] are [=strings=] and
          whose [=map/values=] are {{double}}, set |ig|'s [=interest group/priority vector=] to
          |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`prioritySignalsOverrides`"
        <dd>
        1. If |value| is an [=ordered map=] whose [=map/keys=] are
          [=strings=] and whose [=map/values=] are {{double}} or null:
          1. [=map/For each=] |pvKey| → |pvValue| of |value|:
            1. If |pvValue| is null, [=map/remove=] |ig|'s [=interest group/priority signals overrides=][|pvKey|].
            1. Otherwise, [=map/set=] |ig|'s [=interest group/priority signals overrides=][|pvKey|] to |pvValue|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`privateAggregationConfig`"
        <dd>
        1. If |value| is not a [=map=] whose [=map/keys=] are [=strings=], jump to the step labeled
          <i><a href=#abort-update>Abort update</a></i>.
        1. If |value|["`aggregationCoordinatorOrigin`"] [=map/exists=]:
          1. If |value|["`aggregationCoordinatorOrigin`"] is not a [=string=], jump to the step
            labeled <i><a href=#abort-update>Abort update</a></i>.
          1. Let |aggregationCoordinator| be the result of [=obtaining the Private Aggregation
            coordinator=] given |value|["`aggregationCoordinatorOrigin`"].
          1. If |aggregationCoordinator| is a {{DOMException}}, jump to the step
            labeled <i><a href=#abort-update>Abort update</a></i>.
          1. Otherwise, set |ig|'s [=interest group/Private Aggregation coordinator=] to
            |aggregationCoordinator|.

        <dt>"`sellerCapabilities`"
        <dd>
        1.  If |value| is an [=ordered map=] whose [=map/keys=] are [=strings=] and whose
          [=map/values=] are [=lists=] of [=strings=], [=map/for each=]
          |sellerString| → |capabilities| of |value|:
          1. Let |sellerCapabilities| be a new [=set=] of [=seller capabilities=].
          1. [=list/For each=] |capabilityString| of |capabilities|:
            1. If |capabilityString| is "`interest-group-counts`" or "`latency-stats`", then
              [=set/append=] |capabilityString| to |sellerCapabilities|.

              Note: For forward compatibility with new values, don't [=exception/throw=].

          1. If |sellerString| is "`*`", then set |ig|'s [=interest group/all sellers capabilities=]
            to |sellerCapabilities|.
          1. Otherwise:
            1. If |ig|'s [=interest group/seller capabilities=] is null, then set |ig|'s
              [=interest group/seller capabilities=] to a new [=ordered map=] whose [=map/keys=] are
              [=origins=] and whose [=map/values=] are [=sets=] of [=seller capabilities=].
            1. Let |sellerUrl| be the result of running the [=URL parser=] on |sellerString|.
            1. If |sellerUrl| is not failure:
              1. Let |seller| be |sellerUrl|'s [=url/origin=].
              1. If |ig|'s [=interest group/seller capabilities=] does not [=map/contain=] |seller|,
                then [=map/set=] |ig|'s [=interest group/seller capabilities=][|seller|] to
                |sellerCapabilities|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`executionMode`"
        <dd>
        1. If |value| is "`compatibility`", "`frozen-context`", or "`group-by-origin`", then set
          |ig|'s [=interest group/execution mode=] to |value|.
        1. Otherwise, set |ig|'s [=interest group/execution mode=] to "`compatibility`".

        <dt>"`biddingLogicURL`"
        <dt>"`biddingWasmHelperURL`"
        <dt>"`updateURL`"
        <dd>
        1. For each |groupMember| and |interestGroupField|, in the following table
          <table class="data">
            <thead><tr><th>Group member</th><th>Interest group field</th></tr></thead>
            <tr>
              <td>"`biddingLogicURL`"</td>
              <td>[=interest group/bidding url=]</td>
            </tr>
            <tr>
              <td>"`biddingWasmHelperURL`"</td>
              <td>[=interest group/bidding wasm helper url=]</td>
            </tr>
            <tr>
              <td>"`updateURL`"</td>
              <td>[=interest group/update url=]</td>
            </tr>
          </table>
          1. If |key| is not |groupMember|, [=iteration/continue=].
          1. If |value| is a [=string=]:
            1. Let |parsedURL| be the result of [=parse and verify a bidding code or update URL=]
              on |value| and |ig|'s [=interest group/owner=].
            1. If |parsedURL| is failure, jump to the step labeled <i><a href=#abort-update>
              Abort update</a></i>
            1. Set |ig|'s |interestGroupField| to |parsedURL|.

        <dt>"`trustedBiddingSignalsURL`"</dt>
        <dd>
          1. If |value| is a [=string=]:
            1. Let |parsedURL| be the result of [=parse and verify a trusted signals URL=] on |value|.
            1. If |parsedURL| is failure, jump to the step labeled <i><a href=#abort-update>
              Abort update</a></i>
            1. Set |ig|'s [=interest group/trusted bidding signals url=] to |parsedURL|.

        <dt>"`trustedBiddingSignalsKeys`"
        <dd>
        1. If |value| is a [=list=] of [=strings=],
          set |ig|'s [=interest group/trusted bidding signals keys=] to |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`trustedBiddingSignalsSlotSizeMode`"
        <dd>
        1. If |value| is one of "none", "slot-size", or "all-slots-requested-sizes", set |ig|'s
           [=interest group/trusted bidding signals slot size mode=] to |value|.
        1. Otherwise, set [=interest group/trusted bidding signals slot size mode=] to "none".

        <dt>"`maxTrustedBiddingSignalsURLLength`"
        <dd>
        1. If |value| is a Number:
          1. Let |convertedValue| be the result of [=converted to an IDL value|converting=] |value|
            to a {{long}}.
          1. If |convertedValue| &ge; 0, then set |ig|'s
            [=interest group/max trusted bidding signals url length=] to |convertedValue|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`trustedBiddingSignalsCoordinator`"
        <dd>
        1. If |value| is null:
          1. Set |ig|'s [=interest group/trusted bidding signals coordinator=] to null.
        1. If |value| is a [=string=]:
          1. Let |parsedCoordinator| be the result of [=parsing an https origin=] on |value|.
          1. If |parsedCoordinator| is a failure, jump to the step labeled <i><a href=#abort-update>
            Abort update</a></i>.
          1. Set |ig|'s [=interest group/trusted bidding signals coordinator=] to |parsedCoordinator|.

        <dt>"`userBiddingSignals`"
        <dd>
        1. Set |ig|'s [=interest group/user bidding signals=] to the result of [=serialize an Infra
          value to JSON bytes=] given |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        Issue:  Serializing an Infra value to JSON bytes expects to be called within a valid ES realm. See
        <a href="https://github.com/whatwg/infra/issues/625">infra/625</a>

        <dt>"`adSizes`"
        <dd>
        1. Let |adSizes| be a new [=map=] whose [=map/keys=] are [=strings=] and [=map/values=] are
           [=ad sizes=].
        1. [=map/For each=] |sizeName| → |size| of |value|:
          1. If |sizeName| is "", jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.
          1. Let |adSize| be the result from running [=parse an AdRender ad size=] with |size|.
          1. If |adSize| is null, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.
          1. [=map/Set=] |adSizes|[|sizeName|] to |adSize|.
        1. Set |ig|'s [=interest group/ad sizes=] to |adSizes|.

        <dt>"`sizeGroups`"
        <dd>
        1. Let |adSizes| be |ig|'s [=interest group/ad sizes=].
        1. Let |sizeGroups| be a new [=map=] whose [=map/keys=] are [=strings=] and [=map/values=]
           are [=strings=].
        1. [=map/For each=] |sizeGroupName| → |sizeList| of |value|:
          1. If |sizeGroupName| is "", jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.
          1. [=list/For each=] |sizeName| of |sizeList|:
            1. If |sizeName| is "" or |adSizes|[|sizeName|] does not [=map/exist=],
               jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.
          1. [=map/Set=] |sizeGroups|[|sizeGroupName|] to |sizeList|.
        1. Set |ig|'s [=interest group/size groups=] to |sizeGroups|.

        <dt>"`ads`"
        <dt>"`adComponents`"
        <dd>
        1. For each |groupMember| and |interestGroupField| in the following table
          <table class="data">
            <thead><tr><th>Group member</th><th>Interest group field</th></tr></thead>
            <tr>
              <td>"`ads`"</td>
              <td>[=interest group/ads=]</td>
            </tr>
            <tr>
              <td>"`adComponents`"</td>
              <td>[=interest group/ad components=]</td>
            </tr>
          </table>
          1. If |key| is not |groupMember|, [=iteration/continue=].
          1. If |value| is not a [=list=] of {{AuctionAd}}, jump to the step
            labeled <i><a href=#abort-update>Abort update</a></i>.
          1. Let |igAds| be a new [=list=] of [=interest group ads=].
          1. [=list/For each=] |ad| of |value|:
            1. Let |igAd| be a new [=interest group ad=].
            1. Let |renderURL| be the result of running the [=URL parser=] on
              |ad|["{{AuctionAd/renderURL}}"].
            1. Jump to the step labeled <i><a href=#abort-update>Abort update</a></i>
              if any of the following conditions hold:
              * |renderURL| is failure;
              * |renderURL| [=url/scheme=] is not "`https`";
              * |renderURL| [=includes credentials=].
            1. Set |igAd|'s [=interest group ad/render url=] to |renderURL|.
            1. If |ad|["{{AuctionAd/sizeGroup}}"] [=map/exists=]:
              1. Let |sizeGroup| be |ad|["{{AuctionAd/sizeGroup}}}].
              1. Jump to the step labeled <i><a href=#abort-update>Abort update</a></i> if none of
                 the following conditions hold:
                * |adSizes|[|sizeGroup|] [=map/exists=].
                * |sizeGroups|[|sizeGroup|] [=map/exists=].
              1. Set |igAd|'s [=interest group ad/size group=] to |sizeGroup|.
            1. If |ad|["{{AuctionAd/metadata}}"] [=map/exists=], then let
              |igAd|'s [=interest group ad/metadata=] be the result of
              [=serializing a JavaScript value to a JSON string=], given |ad|["{{AuctionAd/metadata}}"].
              If this [=exception/throws=], jump to the step
              labeled <i><a href=#abort-update>Abort update</a></i>.
            1. If |ad|["{{AuctionAd/creativeScanningMetadata}}"] [=map/exists=], then
              set |igAd|'s [=interest group ad/creative scanning metadata=] to it.
            1. If |groupMember| is "`ads`":
              1. If |ad|["{{AuctionAd/buyerReportingId}}"] [=map/exists=] then set
                  |igAd|'s [=interest group ad/buyer reporting ID=] to it.
              1. If |ad|["{{AuctionAd/buyerAndSellerReportingId}}"] [=map/exists=]
                  then set |igAd|'s [=interest group ad/buyer and seller reporting ID=] to it.
              1. If |ad|["{{AuctionAd/selectableBuyerAndSellerReportingIds}}"] [=map/exists=]
                  then set |igAd|'s [=interest group ad/selectable buyer and seller reporting IDs=] to it.
            1. [=list/Append=] |igAd| to |igAds|.
          1. If |igAds| is not [=list/is empty=]:
            1. Set |ig|'s |interestGroupField| to |igAds|.

        <dt>"`additionalBidKey`"
        <dd>
        1. Let |decodedKey| be the result of running [=forgiving-base64 decode=] with |value|.
        1. Jump to the step labeled <i><a href=#abort-update>Abort update</a></i> if any of the
          following conditions hold:
            * |decodedKey| is a failure;
            * |decodedKey|'s [=byte sequence/length=] is not 32;
        1. Set |ig|'s [=interest group/additional bid key=] to |decodedKey|.

        </dl>
    1. Jump to the step labeled <i><a href=#abort-update>Abort update</a></i> if any of the
      following conditions hold:
      * |ig|'s [=interest group/ads=] is not null, and |ig|'s [=interest group/additional bid key=]
        is not null;
      * |ig|'s [=interest group/estimated size=] is greater than 1048576 bytes.
    1. Set |ig|'s [=interest group/next update after=] to the [=current coarsened wall time=] plus
      24 hours.
    1. Set |ig|'s [=interest group/last updated=] to the [=current coarsened wall time=].
    1. [=list/Replace=] the [=interest group=] that has |ig|'s [=interest group/owner=] and
      [=interest group/name=] in the [=user agent=]'s [=interest group set=] with |ig|.
    1. <i id=abort-update>Abort update</i>: We jump here if some part of the
      [=interest group=] update failed. [=iteration/Continue=] to the next [=interest group=] update.

</div>

<div algorithm>

To <dfn>process updateIfOlderThanMs</dfn> given an [=origin=] |buyer|, and an [=ordered map=]
|perInterestGroupData| whose [=map/keys=] are [=interest group/name=] [=strings=] and whose
[=map/values=] are [=bidding signals per interest group data=]:

1. [=map/For each=] |igName| → |perIgData| of |perInterestGroupData|, the following steps should be
  done:
  1. If |perIgData|'s [=bidding signals per interest group data/update if older than ms=] is null,
    [=iteration/continue=].
  1. Let |updateIfOlderThan| be a [=duration=] of |perIgData|'s
    [=bidding signals per interest group data/update if older than ms=] milliseconds.
  1. Let |ig| be the [=interest group=] of the [=user agent=]'s [=interest group set=] whose
    [=interest group/owner=] is |buyer| and whose [=interest group/name=] is |igName|, or null if
    [=interest group set=] does not have such an interest group.
  1. If |ig| is not null and the [=current coarsened wall time=] &minus; |ig|'s
     [=interest group/last updated=] ≥ |updateIfOlderThan|:
    1. Set |ig|'s [=interest group/next update after=] to
      [=current coarsened wall time=] + |updateIfOlderThan|.
    1. [=list/Replace=] the [=interest group=] that has |ig|'s [=interest group/owner=] and
      [=interest group/name=] in the [=user agent=]'s [=interest group set=] with |ig|.

</div>

# Feature Detection # {#feature-detection}

The {{ProtectedAudience/queryFeatureSupport()}} method permits checking what functionality is
available in the current implementation, in order to help deploy new features. The return values
specified in this specification are for an implementation that fully implements it.

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  [SameObject] readonly attribute ProtectedAudience protectedAudience;
};

[SecureContext, Exposed=Window]
interface ProtectedAudience {
  any queryFeatureSupport(DOMString feature);
};
</xmp>

<div algorithm>

The <dfn for=ProtectedAudience method>queryFeatureSupport(feature)</dfn> method steps are:
1. Let |featuresTable| be an [=ordered map=] whose [=map/keys=] are {{DOMString}}s and whose [=map/values=] are
   {{boolean}}s or {{long}}s, with the following entries:
    :   "adComponentsLimit"
    ::  40
    :   "deprecatedRenderURLReplacements"
    ::  true
    :   "permitCrossOriginTrustedSignals"
    ::  true
    :   "realTimeReporting"
    ::  true
    :   "reportingTimeout"
    ::  true
    :   "trustedSignalsKVv2"
    ::  true
1. If |feature| is "*", then return |featuresTable|.
1. If |featuresTable|[|feature|] [=map/exists=], then return |featuresTable|[|feature|].
1. Return `undefined`.

</div>

# Common Algorithms # {#common-algorithms}

The following algorithms are some helper algorithms used in this specification.

<div algorithm>

The <dfn for="interest group">estimated size</dfn> of an [=interest group=] |ig| is the sum of:
1. The [=string/length=] of the [=serialization of an origin|serialization=] of |ig|'s
  [=interest group/owner=].
1. The [=string/length=] of |ig|'s [=interest group/name=].
1. 8, which is the size of |ig|'s [=interest group/priority=].
1. 4, which is the size of |ig|'s [=interest group/execution mode=].

  Note: Each of [=interest group/execution mode=]'s value represents a {{long}} integer, so 4 bytes.
1. 2, which is the size of |ig|'s [=interest group/enable bidding signals prioritization=].
1. If |ig|'s [=interest group/priority vector=] is not null, [=map/for each=] |key| → |value| of
  [=interest group/priority vector=]:
  1. The [=string/length=] of |key|.
  1. 8, which is the size of |value|.
1. If |ig|'s [=interest group/priority signals overrides=] is not null, [=map/for each=] |key| → |value| of
  [=interest group/priority signals overrides=]:
  1. The [=string/length=] of |key|.
  1. 8, which is the size of |value|.
1. The [=string/length=] of the [=serialization of an origin|serialization=] of |ig|'s [=interest
  group/Private Aggregation coordinator=] if the field is not null.
1. If |ig|'s [=interest group/seller capabilities=] is not null, then [=map/for each=]
  |seller| → |capabilities| of |ig|'s [=interest group/seller capabilities=]:
  1. The [=string/length=] of the [=serialization of an origin|serialization=] of |seller|.
  1. 4, which is |capabilities|'s underlying number of enum bytes.
1. The [=string/length=] of the [=URL serializer|serialization=] of |ig|'s
  [=interest group/bidding url=], if the field is not null.
1. The [=string/length=] of the [=URL serializer|serialization=] of |ig|'s
  [=interest group/bidding wasm helper url=], if the field is not null.
1. The [=string/length=] of the [=URL serializer|serialization=] of |ig|'s
  [=interest group/update url=], if the field is not null.
1. The [=string/length=] of the [=URL serializer|serialization=] of |ig|'s
  [=interest group/trusted bidding signals url=], if the field is not null.
1. 4, which is the size of |ig|'s [=interest group/trusted bidding signals slot size mode=].

    Note: Each of [=interest group/trusted bidding signals slot size mode=]'s value represents a
    {{long}} integer, so 4 bytes.
1. If |ig|'s [=interest group/trusted bidding signals keys=] is not null,
   [=list/for each=] |key| of it:
  1. The [=string/length=] of |key|.
1. If |ig|'s [=interest group/max trusted bidding signals url length=] is not null:
  1. 4, which is the size of |ig|'s [=interest group/max trusted bidding signals url length=].
1. If |ig|'s [=interest group/trusted bidding signals coordinator=] is not null:
  1. The [=string/length=] of the [=serialization of an origin|serialization=] of |ig|'s [=interest group/trusted bidding signals coordinator=].
1. The [=string/length=] of |ig|'s [=interest group/user bidding signals=].
1. If |ig|'s [=interest group/ads=] is not null, [=list/for each=] |ad| of it:
  1. The [=string/length=] of the [=URL serializer|serialization=] of |ad|'s
    [=interest group ad/render url=].
  1. The [=string/length=] of |ad|'s [=interest group ad/size group=] if the field is not null.
  1. The [=string/length=] of |ad|'s [=interest group ad/metadata=] if the field is not null.
  1. The [=string/length=] of |ad|'s [=interest group ad/buyer reporting ID=] if the field is not null.
  1. The [=string/length=] of |ad|'s [=interest group ad/buyer and seller reporting ID=] if the
    field is not null.
  1. If |ad|'s [=interest group ad/selectable buyer and seller reporting IDs=] is not null,
    [=list/for each=] |id| of it:
    1. The [=string/length=] of |id|.
  1. If |ad|'s [=interest group ad/allowed reporting origins=] is not null, [=list/for each=]
    |origin| of it:
    1. The [=string/length=] of the [=serialization of an origin|serialization=] of |origin|.
  1. The [=string/length=] of |ad|'s [=interest group ad/creative scanning metadata=] if the field
    is not null.
1. If |ig|'s [=interest group/ad components=] is not null, [=list/for each=] |ad| of it:
  1. The [=string/length=] of the [=URL serializer|serialization=] of |ad|'s
    [=interest group ad/render url=].
  1. The [=string/length=] of |ad|'s [=interest group ad/size group=] if the field is not null.
  1. The [=string/length=] of |ad|'s [=interest group ad/metadata=] if the field is not null.
  1. The [=string/length=] of |ad|'s [=interest group ad/creative scanning metadata=] if the field
    is not null.
1. If |ig|'s [=interest group/ad sizes=] is not null, [=map/for each=] |sizeName| → |size| of it:
  1. The sum of the [=string/length=] of |sizeName| and 18 (representing the fixed length of |size|).

  Note: 10 represents the size of 2 doubles for [=ad size/width=] and [=ad size/height=] (each 8
  bytes), and 2 bytes for enums for [=ad size/width units=] and [=ad size/height units=] (each 1 byte).
1. If |ig|'s [=interest group/size groups=] is not null, [=map/for each=] |sizeGroupName| → |sizeList|
   of it:
  1. The sum of the [=string/length=] of |sizeGroupName| and the following:
  1. [=list/For each=] |sizeName| of |sizeList|:
    1. The [=string/length=] of |sizeName|.
1. If |ig|'s [=interest group/additional bid key=] is not null:
  1. 32, which is its size (number of bytes).

</div>

<div algorithm>
  To <dfn>parse an https origin</dfn> given a [=string=] |input|:

    1. Let |url| be the result of running the [=URL parser=] on |input|.
    1. If |url| is failure, or its [=origin/scheme=] is not "`https`", then return failure.
    1. Return |url|'s [=url/origin=].
</div>

<div algorithm>
  To <dfn>serialize a URL</dfn> given a [=URL=]-or-null |url|:

    1. If |url| is null, then return {{undefined}}.
    1. Return the [=URL serializer|serialization=] of |url|.
</div>

<div algorithm>
  To <dfn>parse and verify a bidding code or update URL</dfn> given a [=string=] |input| and an
    [=origin=] |igOwner|:

  1. Let |parsedUrl| be the result of running the [=URL parser=] on |input|.
  1. Return failure if any of the following conditions hold:
      * |parsedUrl| is failure;
      * |parsedUrl|'s [=url/origin=] is not [=same origin=] with |igOwner|;
      * |parsedUrl| [=includes credentials=];
      * |parsedUrl|'s [=url/fragment=] is not null.
  1. [=Assert=]: |parsedUrl|'s [=url/scheme=] is "`https`".
  1. Return |parsedUrl|.
</div>

<div algorithm>
  To <dfn>parse and verify a trusted signals URL</dfn> given a [=string=] |input|:

  1. Let |parsedUrl| be the result of running the [=URL parser=] on |input|.
  1. Return failure if any of the following conditions hold:
      * |parsedUrl| is failure;
      * |parsedUrl|'s [=url/scheme=] is not "`https`";
      * |parsedUrl| [=includes credentials=];
      * |parsedUrl|'s [=url/fragment=] is not null;
      * |parsedUrl|'s [=url/query=] is not null.
  1. Return |parsedUrl|.
</div>

<div algorithm>
  To <dfn>round a value</dfn> given a {{double}} |value|:

    1. If |value| is not a [=valid floating-point number=], return |value|.
    1. Let |valueExp| be |value|'s IEEE 754 biased exponent field minus 1023.
    1. Let |normValue| be |value| multiplied by 2<sup>(&minus;1 &times; |valueExp|)</sup>.
    1. If |valueExp| &lt; &minus;128:
      1. If |value| &lt; 0, return &minus;0.
      1. Otherwise, return 0.
    1. If |valueExp| &gt; 127:
      1. If |value| &lt; 0, return &minus;&infin;.
      1. Otherwise, return &infin;.
    1. Let |precisionScaledValue| be |normValue| multiplied by 256.
    1. Let |noisyScaledValue| be |precisionScaledValue| plus a random {{double}} value greater than
      or equal to 0 but less than 1.
    1. Let |truncatedScaledValue| be the largest integer not greater than |noisyScaledValue|.
    1. Return |truncatedScaledValue| multiplied by 2<sup>(|valueExp| &minus; 8)</sup>.
</div>

<div algorithm>
To <dfn>serialize an integer</dfn>, represent it as a string of the shortest possible decimal
number.

Issue: This would ideally be replaced by a more descriptive algorithm in Infra. See
<a href="https://github.com/whatwg/infra/issues/201">infra/201</a>

</div>

<div algorithm>
  To <dfn>get uuid from string</dfn> given a [=string=] |input|:

    1. If |input|'s [=string/length=] is not 36, return an empty [=string=].
    1. Let |uuidStr| be an empty [=string=].
    1. [=list/For each=] |i| in [=the range=] from 1 to 36, inclusive:
      1. Let |unit| be |input|'s |i|th [=code unit=].
      1. If « 8, 13, 18, 23 » [=list/contains=] |i|:
        1. If |unit| is not 0x002D (-), then return an empty [=string=].
      1. Otherwise:
        1. If |unit| is not an [=ASCII lower hex digit=], then return an empty [=string=].
        1. Append |unit| to the end of |uuidStr|.
    1. Return [=ASCII encoded=] |uuidStr|.
</div>

<div algorithm>
  To <dfn>insert entries to map</dfn> given an [=ordered map=] |map|, a |key| which is in same type
  as |map|'s [=map/key=], and a [=list=] |entries| which is in same type as |map|'s [=map/value=]:

  1. If |map|[|key|] [=map/exists=], then [=list/extend=] |map|[|key|] with |entries|.
  1. Otherwise, [=map/set=] |map|[|key|] to |entries|.
</div>


# Permissions Policy Integration # {#permissions-policy-integration}

This specification defines two [=policy-controlled features=] identified by the strings
"<code><dfn noexport>join-ad-interest-group</dfn></code>", and
"<code><dfn noexport>run-ad-auction</dfn></code>". Their
[=policy-controlled feature/default allowlists=] are "`*`".

Issue: Move from "`*`" to "`self`"
(<a href="https://github.com/WICG/turtledove/issues/522">WICG/turtledove#522</a>).

<div algorithm>

To <dfn>check interest group permissions</dfn> given an [=origin=] |ownerOrigin|, an
[=environment settings object=] |settings|, and an enum |joinOrLeave| which is "`join`" or "`leave`":
1. If |ownerOrigin| is [=same origin=] with |frameOrigin|, then return true.
1. Let |encodedFrameOrigin| be the result of [=string/UTF-8 percent-encoding=] the
  [=serialization of an origin|serialized=] |frameOrigin| using [=component percent-encode set=].
1. Let |permissionsUrl| be a new [=URL=] with the following [=struct/items=]:
  :   [=url/scheme=]
  ::  |ownerOrigin|'s [=origin/scheme=]
  :   [=url/host=]
  ::  |ownerOrigin|'s [=origin/host=]
  :   [=url/port=]
  ::  |ownerOrigin|'s [=origin/port=]
  :   [=url/path=]
  ::  « ".well-known", "interest-group", "permissions" »
  :   [=url/query=]
  ::  The result of [=string/concatenating=] « "origin=", |encodedFrameOrigin| »
1. Let |request| be a new [=request=] with the following properties:
  :   [=request/URL=]
  ::  |permissionsUrl|
  :   [=request/header list=]
  ::  «`Accept`: `application/json`»
  :   [=request/client=]
  ::  |settings|
  :   [=request/origin=]
  ::  "`client`"
  :   [=request/mode=]
  ::  "`cors`"
  :   [=request/referrer=]
  ::  "`no-referrer`"
  :   [=request/credentials mode=]
  ::  "`omit`"
  :   [=request/redirect mode=]
  ::  "`error`"
  :   [=request/service-workers mode=]
  ::  `none`
  :   [=request/policy container=]
  ::  "`client`"

1. Let |resource| be null.
1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true, and
  [=fetch/processResponseConsumeBody=] set to the following steps given a [=response=] |response|
  and null, failure, or a [=byte sequence=] |responseBody|:
  1. If |responseBody| is null or failure, set |resource| to failure and return.
  1. Let |headers| be |response|'s [=response/header list=].
  1. Let |mimeType| be the result of [=header list/extracting a MIME type=] from |headers|.
  1. If |mimeType| is failure or is not a [=JSON MIME Type=], set |resource| to failure and return.
  1. Set |resource| to |responseBody|.
1. Wait for |resource| to be set.
1. If |resource| is failure, then return false.
1. Let |permissions| be the result of [=parsing JSON bytes to an Infra value=] with |resource|,
  returning false on failure.
1. If |permissions| is not an [=ordered map=], then return false.
1. If |joinOrLeave| is "`join`" and |permissions|["`joinAdInterestGroup`"] [=map/exists=], then
  return |permissions|["`joinAdInterestGroup`"].
1. If |joinOrLeave| is "`leave`" and |permissions|["`leaveAdInterestGroup`"] [=map/exists=], then
  return |permissions|["`leaveAdInterestGroup`"].
1. Return false.

The browser may cache requests for |permissionsUrl| within a network partition.

In order to prevent leaking data, the browser must request |permissionsUrl|
regardless of whether the user is a member of the ad interest group. This
prevents a leak of the user's ad interest group membership to the server.

</div>


# Fetch Patch for Auction Headers # {#fetch-patch-for-auction-headers}

This section specifies a manner by which some data, including [=additional bids=] and
[=direct from seller signals=], may be provided to auctions such that the data is only used within
their intended auction.

Any {{Document}} in a [=traversable navigable=] may run a Protected Audience auction (with
{{Window/navigator}}.{{Navigator/runAdAuction()}}) whose [=script runners=] functions receive signal
objects derived from JSON from an [:Ad-Auction-Signals:] header, or [=additional bids=] derived from
an [:Ad-Auction-Additional-Bid:] header, or response blob's [=base64url=] encoded [=SHA-256=] hash
derived from an [:Ad-Auction-Result:] header, captured by a {{WindowOrWorkerGlobalScope/fetch()}} call
(using the {{RequestInit/adAuctionHeaders}} option) initiated by any *other* {{Document}} in the
*same* [=traversable navigable=], or from an
<a spec="html" lt="navigate an iframe or frame">iframe navigation</a>
request (using the <{iframe/adauctionheaders}>
<a spec=html>content attribute</a> on the <{iframe}> element).

<div algorithm="fetch per traversable navigable structures patch">
Modify [[FETCH]]'s [[FETCH#infrastructure]] to add a new section called "Per Traversable Navigable
Structures", with the following content:

Each [=traversable navigable=] has a <dfn for="traversable navigable">captured ad auction signals
headers</dfn>, which is a [=map=] whose [=map/keys=] are [=direct from seller signals keys=] and
whose [=map/values=] are [=direct from seller signals=].

NOTE: This is only captured during a [=request=] whose [=request/initiator type=] is `"fetch"`, made
with the {{RequestInit/adAuctionHeaders}} option set to `true`, or during an
<a spec="html" lt="navigate an iframe or frame">iframe navigation</a>
request with the <{iframe/adauctionheaders}>
<a spec=html>content attribute</a> set to `true`, as described in the
[:Ad-Auction-Signals:] header description.

Each [=traversable navigable=] has a <dfn for="traversable navigable">captured ad auction additional
bids headers</dfn>, which is a [=map=] whose [=map/keys=] are [=auction nonces=] and whose
[=map/values=] are [=lists=] of [=signed additional bid with metadata=].

NOTE: This is only captured during a [=request=] whose [=request/initiator type=] is `"fetch"`, made
with the {{RequestInit/adAuctionHeaders}} option set to `true`, or during an
<a spec="html" lt="navigate an iframe or frame">iframe navigation</a>
request with the <{iframe/adauctionheaders}> <a spec=html>content attribute</a>
set to `true`, as described in the [:Ad-Auction-Additional-Bid:] header description.

Each [=traversable navigable=] has a <dfn for="traversable navigable">saved Bidding
and Auction request context</dfn>, which is a [=map=]. The [=map=]'s [=map/keys=] are
[=tuples=] consisting of the seller ([=origin=]) and the request ID
([=string representation=] of a [=version 4 UUID=]). The [=map=]'s [=map/values=]
are [=server auction request contexts=].

Each [=traversable navigable=] has a <dfn for="traversable navigable">captured ad auction result
headers</dfn>, which is a [=map=] whose [=map/keys=] are [=origins=] and [=map/values=] are
[=strings=].

Each [=traversable navigable=] has a <dfn for="traversable navigable">captured ad auction result nonce
headers</dfn>, which is a [=map=] whose [=map/keys=] are [=origins=] and [=map/values=] are
[=strings=].
</div>

<div algorithm="fetch capture adAuctionHeaders boolean patch">
Modify the definition of a [=request=]:

A [=request=] has an associated boolean <dfn for=request>capture-ad-auction-headers</dfn>.
Unless stated otherwise it is false.
</div>

<div algorithm="fetch capture adAuctionHeaders RequestInit patch">
Modify [[FETCH]]'s {{RequestInit}} dictionary to add an adAuctionHeaders attribute:

<pre class=idl>
partial dictionary RequestInit {
  boolean adAuctionHeaders;
};
</pre>
</div>

<div algorithm="fetch new request patch">
The following step will be added to the <code><a constructor for="Request" lt="Request()">
new Request (<var ignore>input</var>, <var ignore>init</var>)</a></code> constructor steps, before
step "Set [=this=]'s [=Request/request=] to |request|":

1. If <var ignore>init</var>["{{RequestInit/adAuctionHeaders}}"] [=map/exists=], then set
  |request|'s [=request/capture-ad-auction-headers=] to it.

</div>

<div algorithm="iframe navigation capture adAuctionHeaders attribute patch">
Modify the <{iframe}> element to add a
<dfn element-attr for="iframe">adauctionheaders</dfn> <a spec=html>content attribute</a>.
The IDL attribute {{HTMLIFrameElement/adAuctionHeaders}} [=reflects=]
the <{iframe/adauctionheaders}> <a spec=html>content attribute</a>.

<pre class=idl>
partial interface HTMLIFrameElement {
  [CEReactions] attribute boolean adAuctionHeaders;
};
</pre>
</div>

<div algorithm="iframe navigation patch">
The following step will be added to the
<a spec="html">create navigation params by fetching</a> steps
after step "Let |request| be a new [=request=], with ...":

1. If <var ignore>navigable</var>'s [=navigable/container=] is an <{iframe}> element,
  and if it has a <{iframe/adauctionheaders}> <a spec=html>content attribute</a>,
  then set |request|'s [=request/capture-ad-auction-headers=] to true.

</div>

<div algorithm="fetch Sec-Ad-Auction-Fetch patch">
The following step will be added to the [=HTTP-network-or-cache fetch=] algorithm, before step
"Modify |httpRequest|'s [=request/header list=] per HTTP. ...":

1. If [=request=]'s [=request/capture-ad-auction-headers=] is true, then [=header list/set a
  structured field value=] given «[:Sec-Ad-Auction-Fetch:], the [=structured header/boolean=] `?1`»
  in |httpRequest|'s [=header list=].

</div>

<div algorithm="fetch auction headers patch">
The following will be added to [[Fetch#http-extensions]]:

<h3 id=sec-ad-auction-fetch-header>The \`<a http-header><code>Sec-Ad-Auction-Fetch</code></a>\` HTTP
request header</h3>

The \`<dfn http-header><code>Sec-Ad-Auction-Fetch</code></dfn>\` request header is an optional
[=structured header=] with of type [=structured header/boolean=]. [:Sec-Ad-Auction-Fetch:] will only
be set on a [=request=] whose [=request/initiator type=] is `"fetch"`, made with the
{{RequestInit/adAuctionHeaders}} option set to `true`, or on an
<a spec="html" lt="navigate an iframe or frame">iframe navigation</a>
request with the <{iframe/adauctionheaders}> <a spec=html>content attribute</a>
set to `true`. If [:Sec-Ad-Auction-Fetch:] is equal to `?1`,
the user agent will remove any [:Ad-Auction-Signals:] or [:Ad-Auction-Additional-Bid:] from the
returned [=response=] -- the [:Ad-Auction-Signals:] or [:Ad-Auction-Additional-Bid:] value will
instead only be used in Protected Audiences auctions.

<h3 id=ad-auction-signals-header>The \`<a http-header><code>Ad-Auction-Signals</code></a>\` HTTP
response header</h3>

The \`<dfn http-header><code>Ad-Auction-Signals</code></dfn>\` response header provides value
of a JSON array of dictionaries, each with an `adSlot` key. Protected Audience non-component,
component, and top-level auctions may specify which signals to load by the `adSlot` key.

<h3 id=ad-auction-additional-bid-header>The \`<a http-header><code>Ad-Auction-Additional-Bid</code></a>\`
HTTP response header.</h3>

The \`<dfn http-header><code>Ad-Auction-Additional-Bid</code></dfn>\` response header provides value
of a string in the format of `<auction nonce>:<seller nonce>:<base64-encoding of the signed
additional bid>`, or the legacy format of `<auction nonce>:<base64-encoding of the signed additional
bid>`, either of which corresponds to a single [=additional bid=]. In the format that provides a
seller nonce, the seller nonce must be as described in [=signed additional bid with metadata/seller
nonce=]. The response may include more than one [=additional bid=] by specifying multiple instances
of the [:Ad-Auction-Additional-Bid:] response header.
</div>

<h3 id=ad-auction-result-header>The \`<a http-header><code>Ad-Auction-Result</code></a>\`
HTTP response header.</h3>

The \`<dfn http-header><code>Ad-Auction-Result</code></dfn>\` response header provides the
[=base64url=] encoded [=SHA-256=] hash of the response blob. Multiple hashes can be included in a
response by either repeating the header or by specifying multiple hashes separated by a "`,`" character.

<div id="ad-auction-result-example" class=example>
  <pre highlight="js">
    Ad-Auction-Result: ungWv48Bz-pBQUDeXa4iI7ADYaOWF3qctBD_YfIAFa0=,9UTB-u-WshX66Xqz5DNCpEK9z-x5oCS5SXvgyeoRB1k=
  </pre>
  is equivalent to
  <pre highlight="js">
    Ad-Auction-Result: ungWv48Bz-pBQUDeXa4iI7ADYaOWF3qctBD_YfIAFa0=
    Ad-Auction-Result: 9UTB-u-WshX66Xqz5DNCpEK9z-x5oCS5SXvgyeoRB1k=
  </pre>
</div>

<h3 id=ad-auction-result-nonce-header>The \`<a http-header><code>Ad-Auction-Result-Nonce</code></a>\`
HTTP response header.</h3>

The \`<dfn http-header><code>Ad-Auction-Result-Nonce</code></dfn>\` response header provides the
canonical [=string=] representation of a [=version 4 UUID=] serving as a nonce. Multiple nonces
can be included in a response by either repeating the header or by specifying multiple
nonces separated by a "`,`" character.

<div id="ad-auction-result-nonce-example" class=example>
  <pre highlight="js">
    Ad-Auction-Result-Nonce: 7d444840-9dc0-11d1-b245-5ffdce74fad2,e902893a-9d22-3c7e-a7b8-d6e313b71d9f
  </pre>
  is equivalent to
  <pre highlight="js">
    Ad-Auction-Result-Nonce: 7d444840-9dc0-11d1-b245-5ffdce74fad2
    Ad-Auction-Result-Nonce: e902893a-9d22-3c7e-a7b8-d6e313b71d9f
  </pre>
</div>

<div algorithm="ad auction fetch redirect patch">
The following steps will be added to the [=HTTP fetch=] algorithm, immediately under the step "If
<var ignore>internalResponse</var>'s [=status=] is a [=redirect status=]:"

1. [=header list/Delete=] "[:Ad-Auction-Signals:]" from |response|'s
  [=response/header list=].
1. [=header list/Delete=] "[:Ad-Auction-Additional-Bid:]" from |response|'s
  [=response/header list=].

</div>

<div algorithm="fetch auction signals response patch">
The following step will be added to the [=HTTP fetch=] algorithm, before step
"Return |response|.":

1. If |response| is not null, |response|'s [=status=] is not a [=redirect status=], |fetchParams|'s
  [=fetch params/task destination=] is a [=global object=] that's a {{Window}} object, and
  |request|'s [=request/capture-ad-auction-headers=] is `true`:
  1. Let |navigable| be |fetchParams|'s [=fetch params/task destination=]'s [=associated Document=]'s
    [=node navigable=]'s [=traversable navigable=].
  1. Run [=update captured headers=] with |navigable|'s
    [=traversable navigable/captured ad auction signals headers=], |navigable|'s
    [=traversable navigable/captured ad auction additional bids headers=], |navigable|'s
    [=traversable navigable/captured ad auction result headers=],
    |navigable|'s
    [=traversable navigable/captured ad auction result nonce headers=], |response|'s
    [=response/header list=], and |request|'s [=request/URL=]'s [=url/origin=].

</div>

<div algorithm="fetch update captured headers patch">
The following algorithm will be added to the [[FETCH#fetching]] section:

  To <dfn id=concept-update-captured-headers>update captured headers</dfn> with a [=traversable
  navigable/captured ad auction signals headers=] |storedSignalsHeaders|,
  [=traversable navigable/captured ad auction additional bids headers=] |storedAdditionalBidsHeaders|,
  [=traversable navigable/captured ad auction result headers=] |storedAuctionResultHeaders|,
  [=traversable navigable/captured ad auction result nonce headers=] |storedAuctionResultNonceHeaders|,
  [=header list=] |responseHeaders|, and [=origin=] |requestOrigin|:
  1. Let |adAuctionSignals| be the result of [=header list/getting=] [:Ad-Auction-Signals:] from
    |responseHeaders|.
  1. If |adAuctionSignals| is not null:
    1. [=header list/Delete=] "[:Ad-Auction-Signals:]" from |responseHeaders|.

      NOTE: This step prevents the header value from being used outside the intended auctions --
      that is, scripts making the {{WindowOrWorkerGlobalScope/fetch()}} request aren't able to load
      the header value.
    1. [=Handle ad auction signals header value=] given |adAuctionSignals|, |storedSignalsHeaders| and
      |requestOrigin|.

  1. Let |additionalBids| be the result of [=header list/getting, decoding, and splitting=]
    [:Ad-Auction-Additional-Bid:] from |responseHeaders|.
  1. If |additionalBids| is not null:
    1. [=header list/Delete=] "[:Ad-Auction-Additional-Bid:]" from |responseHeaders|.

      NOTE: This step prevents the header value from being used outside the intended auctions --
      that is, scripts making the {{WindowOrWorkerGlobalScope/fetch()}} request aren't able to load
      the header value.
    1. [=list/For each=] |bid| of |additionalBids|:
      1. Let |parts| be the result of [=strictly splitting=] |bid| on U+003A (:).
      1. Let |bidWithMetadata| be a new [=signed additional bid with metadata=].
      1. If |parts|'s [=list/size=] is 3:
        1. Let |auctionNonce| be |parts|[0].
        1. If |auctionNonce|'s [=string/length=] is not 36, then [=iteration/continue=].
        1. Let |sellerNonce| be |parts|[1].
        1. If |sellerNonce|'s [=string/length=] is not 36, then [=iteration/continue=].
        1. Let |bidWithMetadata|'s [=signed additional bid with metadata/seller nonce=] be
          |sellerNonce|.
        1. Let |bidWithMetadata|'s [=signed additional bid with metadata/signed additional bid=] be
          |parts|[2].
        1. [=list/Append=] |bidWithMetadata| to |storedAdditionalBidsHeaders|[|auctionNonce|].
      1. Otherwise, if |parts|'s [=list/size=] is 2:
        1. Let |auctionNonce| be |parts|[0].
        1. If |auctionNonce|'s [=string/length=] is not 36, then [=iteration/continue=].
        1. Let |bidWithMetadata|'s [=signed additional bid with metadata/signed additional bid=] be
          |parts|[1].
        1. [=list/Append=] |bidWithMetadata| to |storedAdditionalBidsHeaders|[|auctionNonce|].

  1. Let |adAuctionResults| be the result of [=header list/getting, decoding, and splitting=]
    [:Ad-Auction-Result:] from |responseHeaders|.
  1. If |adAuctionResults| is not null, [=list/for each=] |result| of |adAuctionResults|:
    1. [=Strip leading and trailing ASCII whitespace=] from |result|.
    1. If |result| is "", or contains [=code points=] U+002B (`+`) or U+002F (`/`), then
      [=iteration/continue=].
    1. Replace every U+2212 (`-`) [=code point=] in |result| with U+002B (`+`).
    1. Replace every U+005F(`_`) [=code point=] in |result| with U+002F (`/`).
    1. Let |hash| be the result of running [=forgiving-base64 decode=] with |result|.
    1. If |hash| is not failure, and |hash|'s [=string/length=] is 32:
      1. If |storedAuctionResultHeaders|[|requestOrigin|] [=map/exists=], then [=list/append=] |hash|
        to |storedAuctionResultHeaders|.
      1. Otherwise, [=map/set=] |storedAuctionResultHeaders|[|requestOrigin|] to « |hash| ».
  1. Let |adAuctionResultNonces| be the result of [=header list/getting, decoding, and splitting=]
    [:Ad-Auction-Result-Nonce:] from |responseHeaders|.
  1. [=header list/Delete=] "[:Ad-Auction-Result-Nonce:]" from |responseHeaders|.

      NOTE: This step prevents the header value from being used outside the intended auctions --
      that is, scripts making the {{WindowOrWorkerGlobalScope/fetch()}} request aren't able to load
      the header value.
  1. If |adAuctionResultNonces| is not null, [=list/for each=] |result| of |adAuctionResultNonces|:
    1. [=Strip leading and trailing ASCII whitespace=] from |result|.
    1. Let |nonce| be the result of [=getting uuid from string=] on |result|.
    1. If |nonce| is "", then [=iteration/continue=].
    1. Let |nonceString| be the [=string representation=] of |nonce|.
    1. If |storedAuctionResultNonceHeaders|[|requestOrigin|] [=map/exists=],
       then [=list/append=] |nonceString| to |storedAuctionResultNonceHeaders|.
    1. Otherwise, [=map/set=] |storedAuctionResultNonceHeaders|[|requestOrigin|] to « |nonceString| ».

</div>

<div algorithm>
To <dfn>handle ad auction signals header value</dfn> given a [=byte sequence=] |adAuctionSignals|,
[=traversable navigable/captured ad auction signals headers=] |storedSignalsHeaders|, and [=origin=]
|requestOrigin|:

  1. Let |parsedSignals| be the result of [=parsing JSON bytes to an Infra value=], given
    |adAuctionSignals|.
  1. If |parsedSignals| is failure or not a [=list=], return.
  1. Let |headerAdSlots| be a new [=ordered set=].
  1. [=list/For each=] |signal| of |parsedSignals|:
    1. If |signal| is not an [=ordered map=], [=iteration/continue=].
    1. If |signal|["`adSlot`"] doesn't exist, [=iteration/continue=].
    1. If |headerAdSlots| [=set/contains=] |signal|["`adSlot`"], [=iteration/continue=]. Optionally,
      [=report a warning to the console=] with a diagnostic error message indicating that a
      duplicate [:Ad-Auction-Signals:] `adSlot` dictionary was ignored.
    1. [=set/Append=] |signal|["`adSlot`"] to |headerAdSlots|.
    1. Let |signalsKey| be a new [=direct from seller signals key=], with its
      [=direct from seller signals key/seller=] set to |requestOrigin| and its
      [=direct from seller signals key/ad slot=] set to |signal|["`adSlot`"].
    1. Let |processedSignals| be a new [=direct from seller signals=].
    1. [=map/Remove=] |signal|["`adSlot`"].
    1. [=map/For each=] |key| → |value| of |signal|:
      1. Switch on |key|:
        <dl class=switch>
          <dt>"`sellerSignals`"
          <dd>
          1. Set |processedSignals|'s [=direct from seller signals/seller signals=] to the result
            of [=serializing an Infra value to a JSON string=], given |value|.

          <dt>"`auctionSignals`"
          <dd>
          1. Set |processedSignals|'s [=direct from seller signals/auction signals=] to the result
            of [=serializing an Infra value to a JSON string=], given |value|.

          <dt>"`perBuyerSignals`"
          <dd>
          1. If |value| is not an [=ordered map=], [=iteration/continue=].
          1. For each |buyer| → |buyerSignals| of |value|:
            1. Let |buyerOrigin| be the result of [=parsing an https origin=] on |buyer|.
            1. If |buyerOrigin| is failure, [=iteration/continue=].
            1. Let |buyerSignalsString| be the result of
              [=serializing an Infra value to a JSON string=], given |buyerSignals|.
            1. Set |processedSignals|'s
              [=direct from seller signals/per buyer signals=][|buyerOrigin|] to |buyerSignalsString|.
        </dl>

    1. Set |storedSignalsHeaders|[|signalsKey|] to |processedSignals|.
</div>


# Structures # {#structures}

<xmp class="idl">
typedef (long long or AuctionAd) PreviousWinElement;
typedef sequence<PreviousWinElement> PreviousWin;

dictionary BiddingBrowserSignals {
  required DOMString topWindowHostname;
  required USVString seller;
  required long joinCount;
  required long bidCount;
  required long recency;
  required long adComponentsLimit;
  required unsigned short multiBidLimit;

  record<DOMString, DOMString> requestedSize;
  USVString topLevelSeller;
  sequence<PreviousWin> prevWinsMs;
  object wasmHelper;
  unsigned long dataVersion;
  unsigned long crossOriginDataVersion;
  boolean forDebuggingOnlyInCooldownOrLockout = false;
};

dictionary ScoringBrowserSignals {
  required DOMString topWindowHostname;
  required USVString interestGroupOwner;
  required USVString renderURL;
  required unsigned long biddingDurationMsec;
  required DOMString bidCurrency;

  record<DOMString, DOMString> renderSize;
  unsigned long dataVersion;
  unsigned long crossOriginDataVersion;
  sequence<USVString> adComponents;
  boolean forDebuggingOnlyInCooldownOrLockout = false;
  USVString creativeScanningMetadata;
  sequence<USVString?> adComponentsCreativeScanningMetadata;
};
</xmp>

<div algorithm>
  To <dfn>convert an ad size to a map</dfn> given an [=ad size=] |adSize|:

  1. Let |dict| be a new empty [=map=].
  1. Let |jsWidth| be |adSize|'s [=ad size/width=], [=converted to an ECMAScript value=].
  1. [=map/Set=] |dict|["width"] to the result of [=string/concatenating=] « [$ToString$](|jsWidth|),
     |adSize|'s [=ad size/width units=] ».
  1. Let |jsHeight| be |adSize|'s [=ad size/height=], [=converted to an ECMAScript value=].
  1. [=map/Set=] |dict|["height"] to the result of [=string/concatenating=] « [$ToString$](|jsHeight|),
     |adSize|'s [=ad size/height units=] ».
  1. Return |dict|.

</div>

Note: {{ScoringBrowserSignals}}'s {{ScoringBrowserSignals/adComponents}} is {{undefined}} when
[=generated bid/ad component descriptors=] is null or [=list/is empty|an empty list=]. It cannot be
an [=list/is empty|empty list=].

<xmp class="idl">
dictionary ReportingBrowserSignals {
  required DOMString topWindowHostname;
  required USVString interestGroupOwner;
  required USVString renderURL;
  required double bid;
  required double highestScoringOtherBid;

  DOMString bidCurrency;
  DOMString highestScoringOtherBidCurrency;
  USVString topLevelSeller;
  USVString componentSeller;

  USVString buyerAndSellerReportingId;
  USVString selectedBuyerAndSellerReportingId;
};
</xmp>

{{ReportingBrowserSignals}} includes browser signals both `reportResult()` and `reportWin()` get.
<dl class=domintro>
  <dt>{{ReportingBrowserSignals/topWindowHostname}}
  <dd>[=environment/Top-level origin=]'s [=origin/host=]
  <dt>{{ReportingBrowserSignals/interestGroupOwner}}
  <dd>The winning [=interest group=]'s [=interest group/owner=].
  <dt>{{ReportingBrowserSignals/renderURL}}
  <dd>The render URL returned by "`generateBid()`". It is
    [=query reporting ID k-anonymity count|k-anonymous=]
  <dt>{{ReportingBrowserSignals/bid}}
  <dd>[=round a value|Stochastically rounded=] winning bid. This is always in the bidder's own
    currency
  <dt>{{ReportingBrowserSignals/highestScoringOtherBid}}
  <dd>The [=round a value|stochastically rounded value=] of the bid that got the second highest
    score, or 0 if it's not available. 0 for top-level auctions with components
  <dt>{{ReportingBrowserSignals/bidCurrency}}
  <dd>The currency the {{ReportingBrowserSignals/bid}} is in
  <dt>{{ReportingBrowserSignals/highestScoringOtherBidCurrency}}
  <dd>The currency the {{ReportingBrowserSignals/highestScoringOtherBid}} is in
  <dt>{{ReportingBrowserSignals/topLevelSeller}}
  <dd>Copied from [=leading bid info/top level seller=]
  <dt>{{ReportingBrowserSignals/componentSeller}}
  <dd>Copied from [=leading bid info/component seller=]
  <dt>{{ReportingBrowserSignals/buyerAndSellerReportingId}}
  <dd>There are two scenerios in which this can be set:
    * Set if the winning ad had a [=interest group ad/buyer and seller reporting ID=] and
      the winning bid did not have [=generated bid/selected buyer and seller reporting ID=] set,
      and that value was [=query reporting ID k-anonymity count|jointly k-anonymous=] combined with
      interest group owner, bidding script URL, [=ad creative=] URL, and null.
    * Set if the wining bid had a [=generated bid/selected buyer and seller reporting ID=] and the
      winning ad had a [=interest group ad/buyer and seller reporting ID=] set in its listing in the
      interest group, and that value was [=query reporting ID k-anonymity count|jointly k-anonymous=]
      combined with interest group owner, bidding script URL, [=ad creative=] URL, the and winning bid's
      [=generated bid/selected buyer and seller reporting ID=].
  <dt>{{ReportingBrowserSignals/selectedBuyerAndSellerReportingId}}
  <dd>A selected reporting id returned by "`generateBid()`".
    Set if the winning bid had a [=generated bid/selected buyer and seller reporting ID=] set,
    and that value was [=query reporting ID k-anonymity count|jointly k-anonymous=] combined with
    [=interest group ad/buyer and seller reporting ID=], interest group owner,
    bidding script URL, and [=ad creative=] URL.
</dl>

<xmp class="idl">
dictionary ReportResultBrowserSignals : ReportingBrowserSignals {
  required double desirability;

  DOMString topLevelSellerSignals;
  double modifiedBid;
  unsigned long dataVersion;
};
</xmp>

<dl class=domintro>
  <dt>{{ReportResultBrowserSignals/desirability}}
  <dd>The [=round a value|stochastically rounded value=] of the score returned by "`scoreAd()`" for
    the winning bid
  <dt>{{ReportResultBrowserSignals/topLevelSellerSignals}}
  <dd>Metadata returned by the top-level seller's "`reportResult()`", as JSON
  <dt>{{ReportResultBrowserSignals/modifiedBid}}
  <dd>The [=round a value|stochastically rounded value=] of the bid value returned by the component
    seller's "`scoreAd()`" method
  <dt>{{ReportResultBrowserSignals/dataVersion}}
  <dd>Set to the value of the [:Data-Version:] header from the trusted
    scoring signals server, if any.
</dl>

<xmp class="idl">
dictionary ReportWinBrowserSignals : ReportingBrowserSignals {
  double adCost;
  USVString seller;
  boolean madeHighestScoringOtherBid;
  DOMString interestGroupName;
  DOMString buyerReportingId;
  unsigned short modelingSignals;
  unsigned long dataVersion;
  KAnonStatus kAnonStatus;
};

enum KAnonStatus { "passedAndEnforced", "passedNotEnforced", "belowThreshold", "notCalculated" };
</xmp>

<dl class=domintro>
  <dt>{{ReportWinBrowserSignals/adCost}}
  <dd>[=round a value|Stochastically rounded=] winner's [=generated bid/ad cost=].
  <dt>{{ReportWinBrowserSignals/seller}}
  <dd>The origin of the seller running the ad auction
  <dt>{{ReportWinBrowserSignals/madeHighestScoringOtherBid}}
  <dd>True if the interest group owner was the only bidder that made bids with the second highest
    score
  <dt>{{ReportWinBrowserSignals/interestGroupName}}
  <dd>Only set if all of the following are true:
      * The combination of the [=interest group/owner=], [=interest group/name=], [=interest group/bidding url=],
        [=ad creative=] URL, and null are [=query reporting ID k-anonymity count|jointly k-anonymous=].
      * The winning ad's [=interest group ad/buyer and seller reporting ID=] and
        [=interest group ad/buyer reporting ID=] are null.
      * The winning bid's [=generated bid/selected buyer and seller reporting ID=] is null.
  <dt>{{ReportWinBrowserSignals/buyerReportingId}}
  <dd>There are two scenerios in which this can be set:
    * Set if the winning ad had a [=interest group ad/buyer reporting ID=] but not a
      [=interest group ad/buyer and seller reporting ID=] set in its listing in the interest group,
      and the winning bid did not have [=generated bid/selected buyer and seller reporting ID=] set,
      and that value was [=query reporting ID k-anonymity count|jointly k-anonymous=] combined with
      interest group owner, bidding script URL, [=ad creative=] URL, and null.
    * Set if the wining bid had a [=generated bid/selected buyer and seller reporting ID=] and the
      winning ad had a [=interest group ad/buyer reporting ID=] set in its listing in the
      interest group, and that value was [=query reporting ID k-anonymity count|jointly k-anonymous=]
      combined with interest group owner, bidding script URL, [=ad creative=] URL,
      [=interest group ad/buyer and seller reporting ID=], and
      [=generated bid/selected buyer and seller reporting ID=].
  <dt>{{ReportWinBrowserSignals/modelingSignals}}
  <dd>A 0-4095 integer (12-bits) passed to `reportWin()`, with noising
  <dt>{{ReportWinBrowserSignals/dataVersion}}
  <dd>Only set if the Data-Version header was provided in the response headers from the trusted
    bidding signals server
  <dt>{{ReportWinBrowserSignals/kAnonStatus}}
  <dd>Indicate the k-anonymity status of the ad with the following {{KAnonStatus}} enums:
      * {{KAnonStatus/passedAndEnforced}}: The ad was k-anonymous and k-anonymity was required to win the auction.
      * {{KAnonStatus/passedNotEnforced}}: The ad was k-anonymous though k-anonymity was not required to win the auction.
      * {{KAnonStatus/belowThreshold}}: The ad was not k-anonymous but k-anonymity was not required to win the auction.
      * {{KAnonStatus/notCalculated}}: The browser did not calculate the k-anonymity status of the ad, and k-anonymity was not required to win the auction.

    From a long-term perspective, the status will always be set to `passedAndEnforced` after
    k-anonymity is enforced. However, as a temporary solution, current implementations may set
    `kAnonStatus` to one of the other three statuses to allow API users to assess the future
    impact of enforcing that ads are k-anonymous.
</dl>

<xmp class="idl">
dictionary DirectFromSellerSignalsForBuyer {
  any auctionSignals = null;
  any perBuyerSignals = null;
};
</xmp>

<xmp class="idl">
dictionary DirectFromSellerSignalsForSeller {
  any auctionSignals = null;
  any sellerSignals = null;
};
</xmp>

<h3 id=interest-group-header>Interest group</h3>

An <dfn export>interest group</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="interest group">
  : <dfn>expiry</dfn>
  :: A [=moment=] at which the browser will forget about this interest group.
  : <dfn>owner</dfn>
  :: An [=origin=]. Frames that join interest groups owned by [=interest group/owner=] must either be
    served from [=interest group/owner=], or another origin delegated by [=interest group/owner=] (See
    [=checking interest group permissions=] for details). The [=origin/scheme=] must be "`https`".
  : <dfn>name</dfn>
  :: A [=string=]. The ([=interest group/owner=], [=interest group/name=]) tuple is a key that
    uniquely defines each interest group.
  : <dfn>priority</dfn>
  :: A {{double}}, initially 0.0. Used to select which interest groups participate in an auction
    when the number of interest groups are limited by {{AuctionAdConfig/perBuyerGroupLimits}}.
    See [=applying interest groups limits to prioritized list=].
  : <dfn>enable bidding signals prioritization</dfn>
  :: A [=boolean=], initially false. Being true if the interest group's priority should be
    calculated using vectors from bidding signals fetch.
  : <dfn>priority vector</dfn>
  :: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
    {{double}}. Its dot product with the {{AuctionAdConfig/perBuyerPrioritySignals}} will be used
    in place of [=interest group/priority=], if set.
  : <dfn>priority signals overrides</dfn>
  :: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
    {{double}}. Overrides the {{AuctionAdConfig}}'s corresponding priority signals.
  : <dfn>seller capabilities</dfn>
  :: Null or an [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are
    [=sets=] of [=seller capabilities=].
    The [=seller capabilities=] this [=interest group=] grants to each seller.
  : <dfn>all sellers capabilities</dfn>
  :: Null or a [=set=] of [=seller capabilities=].
    The default [=seller capabilities=] granted to sellers not listed in
    [=interest group/seller capabilities=].
  : <dfn>Private Aggregation coordinator</dfn>
  :: An [=aggregation coordinator=] or null; where null specifies the [=default aggregation
    coordinator=].
  : <dfn>execution mode</dfn>
  :: One of three possible values: "`compatibility`", "`frozen-context`", or "`group-by-origin`".
    Initially "`compatibility`". Each value reprensents a {{long}} integer.
    TODO: Define spec for these execution modes, link to it from here and explain these modes.
  : <dfn>bidding url</dfn>
  :: Null or a [=URL=]. The URL to fetch the buyer's JavaScript from.
    <p class="note">
      When non-null, the [=interest group/bidding url=]'s [=origin=] will always be [=same origin=]
      with [=interest group/owner=].
    </p>
  : <dfn>bidding wasm helper url</dfn>
  :: Null or a [=URL=]. Lets the bidder provide computationally-expensive subroutines in WebAssembly,
    in addition to JavaScript, to be driven from the JavaScript function provided by
    [=interest group/bidding url=].
    <p class="note">
      When non-null, the [=interest group/bidding wasm helper url=]'s [=origin=] will always be
      [=same origin=] with [=interest group/owner=].
    </p>
  : <dfn>update url</dfn>
  :: Null or a [=URL=]. Provides a mechanism for the group's owner to periodically update the
    attributes of the interest group. See [[#interest-group-updates]]. Must be null if
    [=interest group/additional bid key=] is not null.
    <p class="note">
      When non-null, the [=interest group/update url=]'s [=origin=] will always be [=same origin=]
      with [=interest group/owner=].
    </p>
  : <dfn>trusted bidding signals url</dfn>
  :: Null or a [=URL=]. Provide a mechanism for making real-time data available for use at bidding
    time. See [=building trusted bidding signals url=].
  : <dfn>trusted bidding signals keys</dfn>
  :: Null or a [=list=] of [=strings=]. See [=building trusted bidding signals url=].
  : <dfn>trusted bidding signals slot size mode</dfn>
  :: "`none`", "`slot-size`" or "`all-slots-requested-sizes`". Initially "`none`". Each value
    reprensents a {{long}} integer. See [=calculate the ad slot size query param=].
  : <dfn>max trusted bidding signals url length</dfn>
  :: A {{long}} integer, initially 0. Indicates the maximum trusted bidding signals fetch url length
    for the interest group. 0 means no limit.
  : <dfn>trusted bidding signals coordinator</dfn>
  :: Null or an [=origin=], initially null. This is used to specify where to obtain the public key
    used for encryption and decryption in communication with a trusted bidding signal server running
    in a Trust Execution Environment (TEE). When this field is specified, the request will be sent to
    a trusted bidding signals server running in a TEE, and the value of
    [=interest group/max trusted bidding signals url length=] is ignored.
  : <dfn>user bidding signals</dfn>
  :: Null or a [=string=]. Additional metadata that the owner can use during on-device bidding.
  : <dfn>ads</dfn>
  :: Null or a [=list=] of [=interest group ad=]. Contains various ads that the interest group might
    show. Must be null if [=interest group/additional bid key=] is not null.
  : <dfn>ad components</dfn>
  :: Null or a [=list=] of [=interest group ad=]. Contains various ad components (or "products") that
    can be used to construct ads composed of multiple pieces — a top-level ad template "container"
    which includes some slots that can be filled in with specific "products".
  : <dfn>ad sizes</dfn>
  :: Null or a [=map=] whose [=map/keys=] are [=strings=] and [=map/values=] are [=ad sizes=].
     Contains named sizes (width and height) that can be bound to ads to specify their render size.
  : <dfn>size groups</dfn>
  :: Null or a [=map=] whose [=map/keys=] are [=strings=] and [=map/values=] are [=lists=] of
     [=strings=]. Contains named collections of ad sizes that can be used to declare a bundle of
     possible sizes which all apply to one ad url.
  : <dfn>additional bid key</dfn>
  :: Null or a [=byte sequence=] of length 32. Must be null if [=interest group/ads=] or
    [=interest group/update url=] is not null. The Ed25519 public key (a 256-bit EdDSA public key)
    used to guarantee that this [=interest group=], if used by an additional bid for a negative
    targeting, can only be used by its [=interest group/owner=].
  : <dfn>joining origin</dfn>
  :: An [=origin=]. The top level page origin from where the interest group was joined.
  : <dfn>join counts</dfn>
  :: A [=list=] containing [=tuples=] of the day and per day join count. The day
    is calculated based on UTC time. The join count is a count of the number of
    times {{Navigator/joinAdInterestGroup()}} was called for this interest group on the
    corresponding day.
  : <dfn>join time</dfn>
  :: A [=moment=] at which the browser joined this interest group, updated upon each join and
    re-join.
  : <dfn>bid counts</dfn>
  :: A [=list=] containing [=tuples=] of the day and per day bid count. The day
    is calculated based on UTC time. The bid count is a count of the number of
    times the bid calculated during {{Navigator/runAdAuction()}} was greater than 0.
  : <dfn>previous wins</dfn>
  :: A [=list=] of [=previous wins=].
  : <dfn>last updated</dfn>
  :: A [=moment=] when the interest group was last joined or successfully updated, whichever came
    later.
  : <dfn>next update after</dfn>
  :: A [=moment=] at which the browser will permit updating this interest group. See
    [interest group updates](#interest-group-updates).
</dl>

A <dfn>regular interest group</dfn> is an [=interest group=] whose
[=interest group/additional bid key=] is null.

A <dfn>negative interest group</dfn> is an [=interest group=] whose
[=interest group/additional bid key=] is not null.

An <dfn>interest group ad</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="interest group ad">
  : <dfn>render url</dfn>
  :: A [=URL=]. If this ad wins the auction, this URL (or a [=urn uuid=] that maps to this URL) will
    be returned by {{Navigator/runAdAuction()}}. This URL is intended to be loaded into an ad
    <{iframe}> (or a <{fencedframe}>).
  : <dfn>size group</dfn>
  :: Null or a [=string=], initially null. The name of the size group (collection of render sizes) bound to this ad.
  : <dfn>metadata</dfn>
  :: Null or a [=string=]. Extra arbitary information about this ad, passed to `generateBid()`.
  : <dfn>buyer reporting ID</dfn>
  :: Null or a [=string=]. Will be passed in place of interest group name to [=report win=],
    or alongside the [=generated bid/selected buyer and seller reporting ID=], subject
    to [=k-anonymity=] checks. Only meaningful in [=interest group/ads=], but ignored in
    [=interest group/ad components=].
  : <dfn>buyer and seller reporting ID</dfn>
  :: Null or a [=string=]. Will be passed in place of interest group name or
    [=interest group ad/buyer reporting ID=], or alongside the
    [=generated bid/selected buyer and seller reporting ID=], to [=report win=] and
    [=report result=], subject to [=k-anonymity=] checks. Also passed alongside
    [=generated bid/selected buyer and seller reporting ID=] to `scoreAd()` if
    [=generated bid/selected buyer and seller reporting ID=] is present. Only meaningful in
    [=interest group/ads=], but ignored in [=interest group/ad components=].
  : <dfn>selectable buyer and seller reporting IDs</dfn>
  :: Null or a [=list=] of [=strings=]. A list of reporting ids which will be sent to `generateBid()`,
    in order to allow `generateBid()` to return a [=generated bid/selected buyer and seller reporting ID=].
    Only meaningful in [=interest group/ads=], but ignored in [=interest group/ad components=].
  : <dfn>allowed reporting origins</dfn>
  :: Null or a [=list=] of [=origins=]. A list of up to 10 reporting origins that can receive reports
    with registered macros. Each origin's [=origin/scheme=] must be "`https`" and each origin must be
    <a href="https://github.com/privacysandbox/attestation">enrolled</a>. Only meaningful in
    [=interest group/ads=], but ignored in [=interest group/ad components=].
  : <dfn>ad render ID</dfn>
  :: A [=string=] containing up to 12 [=ASCII bytes=] uniquely identifying this ad. Sent instead
    of the full [=interest group ad=] for auctions executed on a server.
  : <dfn>creative scanning metadata</dfn>
  :: Null or a [=string=], initially null. Sent with trusted scoring signals requests if
    [=auction config/send creative scanning metadata=] is true, and the basic HTTP GET
    based protocol, rather than encrypted one for TEE, is used.
</dl>

A <dfn>previous win</dfn> is the [=interest group=]'s auction win history, to allow on-device
frequency capping. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="previous win">
  : <dfn>time</dfn>
  :: A [=moment=]. Approximate time the [=interest group=] won an auction.
  : <dfn>ad</dfn>
  :: An [=interest group ad=]. The ad that won the auction.
    [=struct/Items=] except [=interest group ad/render url=], [=interest group ad/metadata=] and [=interest group ad/ad render ID=] are excluded.
</dl>

A <dfn>seller capability</dfn> is a permission granted by an [=interest group=] to sellers. It's
"`interest-group-counts`" or "`latency-stats`". Each value represents a single bit in a 4-byte
[=byte sequence=]. The 4-byte [=byte sequence=] can store no more than 32 capabilities.

Note: More than 2 values, but probably not more than 32 values are planned, at least for a while.
This way, there is not need to reserve more space for a while.

<h3 dfn-type=dfn>Currency tag</h3>
A currency tag is a [=string=] containing exactly 3 upper-case ASCII letters, or null. The null
value is used to denote that the currency is unspecified.

<div algorithm>
  To <dfn>serialize a currency tag</dfn> given a [=currency tag=] |currency|:
  1. If |currency| is null, return "???".
  1. Return |currency|.
</div>

<div algorithm>
  To <dfn>check whether a string is a valid currency tag</dfn> given [=string=] |currencyString|:
  1. If [=string/length=] of |currencyString| is not 3, return false.
  1. If |currencyString|[0] is not a [=ASCII upper alpha=] code point, return false.
  1. If |currencyString|[1] is not a [=ASCII upper alpha=] code point, return false.
  1. If |currencyString|[2] is not a [=ASCII upper alpha=] code point, return false.
  1. Return true.
</div>

<div algorithm>
  To <dfn>check a currency tag</dfn> given the [=currency tags=] |expected| and |actual|:

  1. If |expected| is null, return true.
  1. If |actual| is null, return true.
  1. If |actual| is equal to |expected|, return true.
  1. Return false.
</div>

<h3 id=auction-config-header>Auction config</h3>

An <dfn export>auction config</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="auction config">
  : <dfn>seller</dfn>
  :: An [=origin=].
    The origin of the seller running the ad auction. The [=origin/scheme=] must be "`https`".
  : <dfn>decision logic url</dfn>
  :: Null or a [=URL=].
    The URL to fetch the seller's JavaScript from. May be null when a
    [=auction config/server response=] is specified, otherwise is required.
    <p class="note">
      The [=auction config/decision logic url=]'s [=origin=] will always be [=same origin=] with
      [=auction config/seller=].
    </p>
  : <dfn>trusted scoring signals url</dfn>
  :: Null or a [=URL=].
    Provide a mechanism for making real-time data (information about a specific [=ad creative=])
    available for use at [=evaluate a scoring script|scoring=] time, e.g. the results of some ad
    scanning system.
  : <dfn>max trusted scoring signals url length</dfn>
  :: A {{long}} integer, initially 0. Indicates the maximum trusted scoring signals fetch url length
    for the auction config. 0 means no limit.
  : <dfn>trusted scoring signals coordinator</dfn>
  :: Null or an [=origin=], initially null. This is used to specify where to obtain the public key
    used for encryption and decryption in communication with a trusted scoring signal server running
    in a Trust Execution Environment (TEE). When this field is specified, the request will be sent to
    a trusted scoring signals server running in a TEE, and the value of
    [=auction config/max trusted scoring signals url length=] is ignored.
  : <dfn>send creative scanning metadata</dfn>
  :: A [=boolean=], initially false. This controls whether additional fields used for creative
    scanning are passed with trusted scoring signals requests as query parameters (when the basic
    HTTP GET based protocol, rather than encrypted one for TEE, is used)
  : <dfn>interest group buyers</dfn>
  :: Null or a [=list=] of [=origins=].
    Owners of interest groups allowed to participate in the auction. Each [=origin's=]
    [=origin/scheme=] must be "`https`".
  : <dfn>auction signals</dfn>
  :: Null, a [=string=], a {{Promise}}, or failure.
    Opaque JSON data passed to both sellers' and buyers' [=script runners=].
  : <dfn>requested size</dfn>
  :: Null or an [=ad size=], initially null.
    The size of the frame for the ad being selected by the auction.
  : <dfn>all slots requested sizes</dfn>
  :: Null or a non-[=set/empty=] [=ordered set=] of [=ad sizes=], initially null.
    The sizes of all frames for ads being selected by any auction in the frame.
  : <dfn>seller signals</dfn>
  :: Null, a [=string=], a {{Promise}}, or failure.
    Opaque JSON data passed to the seller's [=script runner=].
  : <dfn>seller timeout</dfn>
  :: A [=duration=] in milliseconds, initially 50 milliseconds.
    Restricts the runtime of the seller's `scoreAd()` script. If scoring does not complete before
    the timeout, the bid being scored is not considered further.
  : <dfn>per buyer signals</dfn>
  :: Null, a {{Promise}}, failure, or an [=ordered map=] whose [=map/keys=] are [=origins=] and
    whose [=map/values=] are [=strings=].
    [=map/Keys=] are buyers whose [=origin/schemes=] must be "`https`". [=map/Values=] are
    opaque JSON data passed to corresponding buyer's [=script runner=].
  : <dfn>per buyer timeouts</dfn>
  :: Null, a {{Promise}}, failure, or an [=ordered map=] whose [=map/keys=] are [=origins=] and
    whose [=map/values=] are [=durations=] in milliseconds.
    [=map/Keys=] are buyers whose [=origin/schemes=] must be "`https`". [=map/Values=] restrict the
    runtime of corresponding buyer's `generateBid()` script. If the timeout expires, only the bid
    submitted via `setBid()` is considered.
  : <dfn>all buyers timeout</dfn>
  :: A [=duration=] in milliseconds, initially 50 milliseconds.
    Restricts the `generateBid()` script's runtime for all buyers without a timeout specified in
    [=auction config/per buyer timeouts=]. If the timeout expires, only the bid submitted via
    `setBid()` is considered.
  : <dfn>per buyer cumulative timeouts</dfn>
  :: Null, a {{Promise}}, failure, or an [=ordered map=] whose [=map/keys=] are [=origins=] and
    whose [=map/values=] are [=durations=] in milliseconds.
    [=map/Keys=] are buyers whose [=origin/schemes=] must be "`https`". [=map/Values=] are collective
    timeouts for all interest groups of the buyer represented by the [=map/key=]. Includes the time of
    loading scripts and signals, and running the `generateBid()` functions. Once the timer expires,
    the affected buyer's interest groups may no longer generate any bids. All bids generated before
    the timeout will continue to participate in the auction.
    Implementations should attempt, on a best-effort basis, to generate bids for each buyer in
    priority order, so lower priority [=interest groups=] are the ones more likely to be timed out. If
    {{Promise}}s are passed in to the [=auction config=] for fields that support them,
    [=wait until configuration input promises resolve=] before starting the timer.
  : <dfn>all buyers cumulative timeout</dfn>
  :: Null or a [=duration=] in milliseconds, initially null.
    Restricts a buyer's cumulative timeout for all buyers without one specified in
    [=auction config/per buyer cumulative timeouts=].
  : <dfn>per buyer group limits</dfn>
  :: Null or an [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are
    {{unsigned short}}s.
    [=map/Keys=] are buyers whose [=origin/schemes=] must be "`https`". [=map/Values=] restrict the
    number of bidding interest groups for a particular buyer that can participate in an auction.
  : <dfn>all buyers group limit</dfn>
  :: An {{unsigned short}}, initially 65535.
    Limit on the number of bidding interest groups for all buyers without a limit specified in
    [=auction config/per buyer group limits=].
  : <dfn>per buyer priority signals</dfn>
  :: Null or an [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are
    [=ordered maps=], whose [=map/keys=] are [=strings=] and whose [=map/values=] are {{double}}.
    Per-buyer sparse vector whose dot product with [=interest group/priority vector=] is used to
    calculate interest group priorities. No signal's key starts with "browserSignals.", which is
    reserved for values coming from the browser.
  : <dfn>all buyers priority signals</dfn>
  :: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
    {{double}}.
    Merged with [=auction config/per buyer priority signals=] before calculating per-interest group
    priorities. In the case both have entries with the same key, the entry in
    `per_buyer_priority_signals` takes precedence. No signals key start with "browserSignals.", which
    is reserved for values coming from the browser.
  : <dfn>seller Private Aggregation coordinator</dfn>
  :: An [=aggregation coordinator=], initially the [=default aggregation coordinator=].
  : <dfn>required seller capabilities</dfn>
  :: A [=set=] of [=seller capabilities=].
    The [=seller capabilities=] that each [=interest group=] must declare to participate in the
    auction. Interest groups that don't declare all these capabilities will not participate in the
    auction.
  : <dfn>auction report buyer keys</dfn>
  :: A [=map=] from buyer [=origins=] to {{bigint}}s. For buyer metrics delegated to be reported to
    the seller via the [Private Aggregation API](https://github.com/patcg-individual-drafts/private-aggregation-api),
    this determines the base bucket number used for a particular buyer's information.
  : <dfn>auction report buyers</dfn>
  :: A [=map=] from [=strings=] to {{AuctionReportBuyersConfig}}s. For buyer metrics delegated to be
    reported to the seller via the [Private Aggregation API](https://github.com/patcg-individual-drafts/private-aggregation-api),
    this determines how each metric bucket is chosen inside the buyer's space, and how to scale it.
    <!-- TODO: this should probably use enums instead -->
  : <dfn>auction report buyer debug details</dfn>
  :: A [=debug details=], initially a new one. Configures
    [Private Aggregation](https://github.com/patcg-individual-drafts/private-aggregation-api)
    debugging functionality for buyer metrics delegated to be reported to the seller.
  : <dfn>component auctions</dfn>
  :: A [=list=] of [=auction config=]s.
    Nested auctions whose results will also participate in a top level auction. Only the top level
    [=auction config=] can have component auctions.

  : <dfn>deprecated render url replacements</dfn>
  :: Null, a {{Promise}}, failure, or a [=list=] of [=ad keyword replacement=]s, each containing a
    single [=ad keyword replacement/match=] and [=ad keyword replacement/replacement=]. Render url
    replacements can only happen within a single seller [=auction config=] or
    within the component [=auction config=]s.

  : <dfn>seller experiment group id</dfn>
  :: Null or an {{unsigned short}}, initially null.
    Optional identifier for an experiment group to support coordinated experiments with the seller's
    trusted server.
  : <dfn>per buyer experiment group ids</dfn>
  :: An [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are
    {{unsigned short}}s.
    [=map/Keys=] are buyers whose [=origin/schemes=] must be "`https`". [=map/Values=] are
    identifiers for experiment groups, to support coordinated experiments with buyers' trusted servers.
  : <dfn>all buyer experiment group id</dfn>
  :: Null or an {{unsigned short}}, initially null.
    Optional identifier for an experiment group to support coordinated experiments with buyers'
    trusted servers for buyers without a specified experiment group.
  : <dfn>pending promise count</dfn>
  :: An integer, initially 0. The number of things that are pending that are needed to score
    everything. It includes waiting for {{Promise}}s [=auction config/auction signals=],
    [=auction config/per buyer signals=], [=auction config/per buyer currencies=],
    [=auction config/per buyer timeouts=], [=auction config/direct from seller signals header ad slot=],
    [=auction config/seller signals=], or {{AuctionAdConfig/additionalBids}} whose {{Promise}}s are
    not yet resolved.
  : <dfn>config idl</dfn>
  :: {{AuctionAdConfig}}.
  : <dfn>resolve to config</dfn>
  :: A [=boolean=] or a {{Promise}}, initially false.
    Whether the ad should be returned as a {{FencedFrameConfig}}, or otherwise as a [=urn uuid=].
  : <dfn>seller currency</dfn>
  :: A [=currency tag=]. Specifies the currency bids returned by `scoreAd()` are expected to use, and
    which reporting for this auction will agree on.
  : <dfn>per buyer currencies</dfn>
  :: A {{Promise}} or failure or an [=ordered map=] whose [=map/keys=] are [=origins=] and whose
    [=map/values=] are [=currency tags=]. Specifies the currency bids returned by `generateBid()` or
    `scoreAd()` in component auctions are expected to use. The initial value is an empty map.
  : <dfn>all buyers currency</dfn>
  :: A [=currency tag=]. Specifies the currency bids returned by `generateBid()` or `scoreAd()` in
    component auctions are expected to use if [=auction config/per buyer currencies=] does not
    specify a particular value.
  : <dfn>per buyer multi-bid limits</dfn>
  :: An [=ordered map=] who keys [=map/keys=] are [=origins=] and whose [=map/values=] are {{unsigned short}}s.

     Specifies how many bids `generateBid()` is permitted to return at once for a particular buyer
     origin. The initial value is an empty [=map=].
  : <dfn>all buyers multi-bid limit</dfn>
  :: An {{unsigned short}}. Initially 1. Specifies how many bids `generateBid()` is permitted
    to return at once for buyers without a value in [=auction config/per buyer multi-bid limits=].
  : <dfn>direct from seller signals header ad slot</dfn>
  :: Null, a [=string=], a {{Promise}}, or failure. Initially null.
  : <dfn>auction nonce</dfn>
  :: Null or a [=version 4 UUID=], initially null.
    A unique identifier associated with this and only this invocation of
    {{Window/navigator}}.{{Navigator/runAdAuction()}}. For multi-seller auctions, this ID is
    uniquely associated with all {{AuctionAdConfig/componentAuctions}}.
    This must come from a prior call to {{Window/navigator}}.{{Navigator/createAuctionNonce()}}.
    This is only required for auctions that provide [=additional bids=], and each of those
    [=additional bids=] must include the bid nonce derived from that auction nonce as computed by
    [=calculate expected bid nonce=] to ensure that each [=additional bid=] was intended for this
    and only this auction. For backwards compatibility, an [=additional bid=] may include the
    [=auction nonce=] directly in place of a bid nonce.
  : <dfn>expects additional bids</dfn>
  :: A [=boolean=] or failure, initially false.
    Specifies whether some bids will be provided as signed exchanges. Sets to failure if the
    {{AuctionAdConfig/additionalBids}} {{Promise}} is [=rejected=].
  : <dfn>seller real time reporting config</dfn>
  :: Null, or a [=string=], initially null. Seller's real time reporting type. Currently the only
    supported type is "default-local-reporting" indicating local differential privacy. If not null,
    the seller opted in to receive real time reports.
  : <dfn>per buyer real time reporting config</dfn>
  :: An [=ordered map=], whose [=map/keys=] are [=origins=], and whose [=map/values=] are [=strings=].
    Each buyer's real time reporting type. Currently the only supported type is
    "default-local-reporting" indicating local differential privacy. All buyers in the map opted in
    to receive real time reports.
  : <dfn>server response</dfn>
  :: Null or a {{Promise}} or a {{Uint8Array}} containing an encrypted response from the trusted auction server.
  : <dfn>server response id</dfn>
  :: Null or a [=version 4 UUID=]
    A UUID used to match a request from
    {{Window/navigator}}.{{Navigator/getInterestGroupAdAuctionData()}} to the
    encrypted response stored in [=auction config=]'s [=auction config/server response=] field.
    Must be null when [=auction config=]'s [=auction config/server response=] is null,
    and non-null otherwise.
  : <dfn>aborted</dfn>
  :: A [=boolean=] indicating whether the auction has been aborted, initially false.
  : <dfn>abort reason</dfn>
  :: {{any}}.
</dl>

<div algorithm>
To <dfn>wait until configuration input promises resolve</dfn> given an [=auction config=]
|auctionConfig|:

  1. Wait until either |auctionConfig|'s [=auction config/pending promise count=] is 0
     or |auctionConfig|'s [=auction config/aborted=] is true.
  1. If |auctionConfig|'s [=auction config/aborted=] is true, return failure.
  1. [=Assert=] |auctionConfig|'s [=auction config/auction signals=], [=auction config/seller signals=],
    [=auction config/per buyer signals=], [=auction config/per buyer currencies=],
    [=auction config/per buyer timeouts=], [=auction config/per buyer cumulative timeouts=],
    [=auction config/deprecated render url replacements=], and
    [=auction config/direct from seller signals header ad slot=] are not {{Promise}}s, and
    [=auction config/expects additional bids=] is false.
  1. If |auctionConfig|'s [=auction config/auction signals=], [=auction config/seller signals=],
    [=auction config/per buyer signals=], [=auction config/per buyer currencies=],
    [=auction config/per buyer timeouts=], [=auction config/per buyer cumulative timeouts=],
    [=auction config/deprecated render url replacements=], or
    [=auction config/direct from seller signals header ad slot=] is failure, return failure.
  1. Return.
</div>

<div algorithm>
To <dfn>recursively wait until configuration input promises resolve</dfn> given an [=auction config=]
|auctionConfig|:

  1. [=list/For each=] |componentAuctionConfig| in |auctionConfig|'s
    [=auction config/component auctions=]:
    1. If the result of [=waiting until configuration input promises resolve=] given
      |componentAuctionConfig| is failure, return failure.
  1. Return the result of [=waiting until configuration input promises resolve=] given |auctionConfig|.
</div>

<div algorithm>
To <dfn>handle an input promise in configuration</dfn> given an [=auction config=] |auctionConfig|,
a {{Promise}} |p|, and two sequences of steps, covering the parsing of the value and error-handling:

  1. Increment |auctionConfig|'s [=auction config/pending promise count=].
  1. Let |resolvedAndTypeChecked| be the promise representing performing the following steps
    [=upon fulfillment=] of |p| with |result|:
    1. Execute the steps to be run for parsing of the value given |result|.
    1. If no exception was [=exception/thrown=] in the previous step, then decrement
      |auctionConfig|'s [=auction config/pending promise count=].
  1. [=Upon rejection=] of |resolvedAndTypeChecked|:
    1. Execute the steps for error-handling.
    1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
</div>

<div algorithm>
To <dfn>wait until server response promise resolves</dfn> given an [=auction config=] |auctionConfig|:

  1. Wait until either |auctionConfig|'s [=auction config/server response=] is not a {{Promise}},
     or |auctionConfig|'s [=auction config/aborted=] is true.
  1. If |auctionConfig|'s [=auction config/aborted=] is true, return failure.
  1. If |auctionConfig|'s [=auction config/server response=] is failure, return failure.
  1. Return.
</div>

<div algorithm>
To <dfn>look up per-buyer currency</dfn> given an [=auction config=] |auctionConfig|, and an
[=origin=] |buyer|:

  1. Let |perBuyerCurrency| be |auctionConfig|'s [=auction config/all buyers currency=]
  1. [=Assert=] that |auctionConfig|'s [=auction config/per buyer currencies=] is an [=ordered map=].
  1. If |auctionConfig|'s [=auction config/per buyer currencies=][|buyer|] [=map/exists=], then set
    |perBuyerCurrency| to |auctionConfig|'s [=auction config/per buyer currencies=][|buyer|].
  1. Return |perBuyerCurrency|
</div>

<div algorithm>
To <dfn>look up per-buyer multi-bid limit</dfn> given an [=auction config=] |auctionConfig|, and an
[=origin=] |buyer|:

  1. Let |multiBidLimit| be |auctionConfig|'s [=auction config/all buyers multi-bid limit=].
  1. If |auctionConfig|'s [=auction config/per buyer multi-bid limits=][|buyer|] [=map/exists=], then set
    |multiBidLimit| to |auctionConfig|'s [=auction config/per buyer multi-bid limits=][|buyer|].
  1. If |multiBidLimit| &lt; 1, set |multiBidLimit| to 1.
  1. Return |multiBidLimit|.
</div>

<h3 id=bid-generators>Bid generator</h3>

A <dfn>per buyer bid generator</dfn> is an [=ordered map=] whose [=map/keys=] are [=URLs=]
or null representing [=interest group/trusted bidding signals urls=], and whose [=map/values=] are
[=per signals url bid generators=]. The key of null is used for [=interest groups=] that do not
specify a [=interest group/trusted bidding signals url=].

A <dfn>per signals url bid generator</dfn> is an [=ordered map=] whose [=map/keys=] are [=origins=]
representing [=interest group/joining origins=], and whose [=map/values=] are [=lists=] of
[=interest groups=].

<h3 id="script-fetcher-section">Script fetcher</h3>

A <dfn>script fetcher</dfn> helps manage asynchronous fetching of scripts and handling of their
headers. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="script fetcher">
  : <dfn>script body</dfn>
  :: A [=byte sequence=], null, or failure. Initially null. The body of the script.
  : <dfn>origins authorized for cross origin trusted signals</dfn>
  :: A [=list=] of [=origins=] or null. Initially null. Parsed value of
     [:Ad-Auction-Allow-Trusted-Scoring-Signals-From:].
  : <dfn>fetch duration</dfn>
  :: A [=duration=] in milliseconds, denoting how long it took the fetch to complete.
</dl>

<div algorithm>
To <dfn>create a new script fetcher</dfn> given a [=URL=] |url| and an [=environment settings object=]
|settings|:

  1. Let |fetcher| be a new [=script fetcher=].
  1. Let |queue| be the result of [=starting a new parallel queue=].
  1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |queue|:
    1. [=Fetch script=] given |url|, |settings| and |fetcher|.
  1. Return |fetcher|.
</div>

<div algorithm>
To <dfn>wait for script body from a fetcher</dfn> given a [=script fetcher=] |fetcher|:

  1. Wait until |fetcher|'s [=script fetcher/script body=] is not null.
  1. Return |fetcher|'s [=script fetcher/script body=].
</div>

<div algorithm>
To <dfn>wait for cross origin trusted scoring signals authorization from a fetcher</dfn> given a
[=script fetcher=] |fetcher|:

  1. Wait until |fetcher|'s [=script fetcher/origins authorized for cross origin trusted signals=]
    is not null.
  1. Return |fetcher|'s [=script fetcher/origins authorized for cross origin trusted signals=].
</div>

The <dfn http-header><code>Ad-Auction-Allow-Trusted-Scoring-Signals-From</code></dfn> HTTP response
header is a [=structured header=] whose value must be a [=structured header/list=] of [=structured
header/strings=].

<div algorithm>
To <dfn>parse allowed trusted scoring signals origins</dfn> given a [=header list=] |headerList|:

  1. Let |parsedHeader| be the result of [=header list/getting a structured field value=]
    given [:Ad-Auction-Allow-Trusted-Scoring-Signals-From:] and "`list`" from |headerList|.
  1. If |parsedHeader| is null, return an empty [=list=].
  1. Let |result| be a new [=list=] of [=origins=].
  1. [=list/For each=] |entry| in |parsedHeader|:
    1. If |entry| is not a [=string=], return an empty [=list=].
    1. Let |parsedEntry| be the result of [=parsing an https origin=] on |entry|.
    1. If |parsedEntry| is failure, return an empty [=list=].
    1. [=list/Append=] |parsedEntry| to |result|.
  1. Return |result|.
</div>

<div algorithm>
To <dfn>fetch script</dfn> given a [=URL=] |url|, an [=environment settings object=] |settings|, and
a [=script fetcher=] |fetcher|:
  1. Let |request| be a new [=request=] with the following properties:
    :   [=request/URL=]
    ::  |url|
    :   [=request/header list=]
    ::  «`Accept`: `text/javascript`»
    :   [=request/client=]
    ::  `null`
    :   [=request/origin=]
    ::  |settings|'s [=environment settings object/origin=]
    :   [=request/mode=]
    ::  "`no-cors`"
    :   [=request/referrer=]
    ::  "`no-referrer`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/redirect mode=]
    ::  "`error`"
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/policy container=]
    ::  A new [=policy container=] whose [=policy container/IP address space=] is |settings|'s
      [=environment settings object/policy container=]'s [=policy container/IP address space=]

    Issue: Stop using "`no-cors`" mode where possible
    (<a href="https://github.com/WICG/turtledove/issues/667">WICG/turtledove#667</a>).

  1. Let |fetchStart| be |settings|'s [=environment settings object/current monotonic time=].
  1. Let |fetchController| be the result of [=fetching=] |request| with [=fetch/useParallelQueue=]
    set to true, and [=fetch/processResponse=] set to the following steps given
    a [=response=] |response|:
    1. If the result of [=validating fetching response headers=] given |response| is false:
      1. [=fetch controller/Abort=] |fetchController|.
      1. Set |fetcher|'s [=script fetcher/origins authorized for cross origin trusted signals=] to
        an empty [=list=] of [=origins=].
      1. Set |fetcher|'s [=script fetcher/fetch duration=] to the [=duration from=] |fetchStart| to
        |settings|'s [=environment settings object/current monotonic time=], in milliseconds.
      1. Set |fetcher|'s [=script fetcher/script body=] to failure.
      1. Return.
    1. Set |fetcher|'s [=script fetcher/origins authorized for cross origin trusted signals=] to the
      result of [=parsing allowed trusted scoring signals origins=] given |response|'s [=response/
      header list=].
    1. Let |bodyStream| be |response|'s [=response/body=]'s [=body/stream=].
    1. Let |bodyReader| be result of [=ReadableStream/getting a reader=] from |bodyStream|.
    1. Let |successSteps| be a set of steps that take a [=byte sequence=] |responseBody|, and
      perform the following:
      1. Set |fetcher|'s [=script fetcher/fetch duration=] to the [=duration from=] |fetchStart| to
        |settings|'s [=environment settings object/current monotonic time=], in milliseconds.
      1. If [=validate fetching response mime and body=] with |response|, |responseBody| and
        "`text/javascript`" returns false, set |fetcher|'s [=script fetcher/script body=] to
        failure.
      1. Otherwise, set |fetcher|'s [=script fetcher/script body=] to |responseBody|.
    1. Let |failureSteps| be a set of steps that take an [=exception=] <var ignore>e</var>, and
      perform the following:
      1. Set |fetcher|'s [=script fetcher/script body=] to failure.
    1. [=ReadableStreamDefaultReader/Read all bytes=] from |bodyReader|, given |successSteps|
      and |failureSteps|.
</div>

<h3 id=trusted-bidder-signals-batcher>Trusted bidding signals batcher</h3>

A <dfn>trusted bidding signals batcher</dfn> helps manage merging multiple trusted bidding signals
into smaller number of fetches. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="trusted bidding signals batcher">
  : <dfn>all trusted bidding signals</dfn>
  :: An [=ordered map=] whose [=map/keys=] are [=strings=], and [=map/values=] are [=strings=].
     Contains all trusted bidding signals collected thus far.
  : <dfn>all per interest group data</dfn>
  :: An [=ordered map=] whose [=map/keys=] are [=interest group/name=] [=strings=] and whose
     [=map/values=] are [=bidding signals per interest group data=].
  : <dfn>no signals flags</dfn>
  :: An [=ordered map=] whose [=map/keys=] are [=interest group/name=] [=strings=] and whose
     [=map/values=] are enums "no-fetch" or "fetch-failed". This is set to "not-fetched" if given
     interest group did not request any trusted bidding signals keys, or "fetch-failed" if its
     trusted signals fetch failed.
  : <dfn>data versions</dfn>
  :: An [=ordered map=] who [=map/keys=] are [=interest group/name=] [=strings=] and [=map/values=]
    are {{unsigned long}} or null. This contains data version returned by a fetch that provided the
    values for a given interest group name.
  : <dfn>keys</dfn>
  :: An [=ordered set=] of [=strings=]. Describes the keys collected to be fetched in the current
     batch thus far.
  : <dfn>ig names</dfn>
  :: An [=ordered set=] of [=strings=]. Describes the interest group names to be fetched in the
     current batch thus far.
  : <dfn>length limit</dfn>
  :: A {{long}}, initially 2147483647 (the maximum value that it can hold). Describes the URL length
     limit the current batch is limited to, the smallest of the limits of the interest groups included.
  : <dfn>key value interest groups</dfn>
  :: An [=ordered map=] whose [=map/keys=] are [=tuples=] of (an [=origin=] for
    [=interest group/joining origin=], an [=origin=] for [=interest group/owner=]) and whose
    [=map/values=] are [=sets=] of [=interest groups=].
</dl>

A <dfn>bidding signals per interest group data</dfn> is a [=struct=] with the following
[=struct/items=]:

<dl dfn-for="bidding signals per interest group data">
  : <dfn>update if older than ms</dfn>
  :: Null or a {{double}}. If non-null, it is the [=duration=] in milliseconds after which the
    [=interest group=] is eligible for an [update](#interest-group-update), if it hasn't been joined
    or updated within that duration. When eligible, the update is performed either following a call
    to {{Navigator/runAdAuction()}}, for each of the passed {{AuctionAdConfig/interestGroupBuyers}},
    or explicitly by the {{Navigator/updateAdInterestGroups()}} method.
</dl>

A <dfn>bidding compression group</dfn> is a collection of [=bidding partitions=] that can be compressed
together in the signals response. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="bidding compression group">
  : <dfn>compression group id</dfn>
  :: An integer indicates the index of this compression group.
  : <dfn>partitions</dfn>
  :: A [=list=] of [=bidding partition=]. Contains all the [=bidding partitions=] belong to this compression
    group.
</dl>

A <dfn>bidding partition</dfn> is a collection of [=trusted bidding signals batcher/keys=] and
[=trusted bidding signals batcher/ig names=] that can be processed together by the service without
any potential privacy leakage. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="bidding partition">
  : <dfn>id</dfn>
  :: An integer indicates the index of this partition.
  : <dfn>namespace</dfn>
  :: A [=map=], whose [=map/keys=] are [=strings=] and [=map/values=] are [=list=] of
    [=strings=]. A namespace contains all [=interest group/names=] and
    [=interest group/trusted bidding signals keys=] in the partition.
  : <dfn>metadata</dfn>
  :: A [=map=], whose [=map/keys=] and [=map/values=] are [=strings=].
</dl>

<div algorithm>

To <dfn>append to a bidding signals per-interest group data map</dfn> given an [=ordered map=]
|sourceMap|, an [=ordered set=] |igNames|, and an [=ordered map=] |destinationMap|:
1. [=map/For each=] |sourceKey| → |sourceValue| of |sourceMap|:
  1. If |igNames| does not [=set/contain=] |sourceKey|, [=iteration/continue=].
  1. Let |perGroupData| be a new [=bidding signals per interest group data=].
  1. Issue: handle priority vector
     (<a href="https://github.com/WICG/turtledove/issues/1144">WICG/turtledove#1144</a>).
  1. If |sourceValue| is not an [=ordered map=], [=iteration/continue=].
  1. If |sourceValue|["`updateIfOlderThanMs`"] is a {{double}}:
    1. Let |updateIfOlderThanMs| be |sourceValue|["`updateIfOlderThanMs`"].
    1. If |updateIfOlderThanMs| &lt; 600,000, set |updateIfOlderThanMs| to 600,000.

      Note: 600,000 milliseconds is 10 minutes.
    1. Set |perGroupData|'s [=bidding signals per interest group data/update if older than ms=] to
      |updateIfOlderThanMs|.
  1. If |perGroupData|'s [=bidding signals per interest group data/update if older than ms=] is not
    null, then [=map/set=] |destinationMap|[|sourceKey|] to |perGroupData|.

</div>

<div algorithm>

To <dfn>build trusted bidding signals url</dfn> given a [=URL=] |signalsUrl|, an [=ordered set=] of
[=strings=] |keys|, an [=ordered set=] of [=strings=] |igNames|, an {{unsigned short}}-or-null
|experimentGroupId|, an [=origin=] |topLevelOrigin|, and a [=string=] |slotSizeQueryParam|:
1. Let |queryParamsList| be a new empty [=list=].

  Note: These steps create a [=url/query=] of the form "`&<name>=<values in comma-delimited list>`".
  E.g., "`hostname=publisher1.com&keys=key1,key2&interestGroupNames=ad+platform,name2&experimentGroupId=1234`".
    <br><br>These steps don't use the [=urlencoded serializer|application/x-www-form-urlencoded
    serializer=] to construct the query string because it repeats a key if it has multiple values
    instead of a comma-demilited list (e.g., "`keys=key1&keys=key2`", instead of
    "`keys=key1,key2`"), and it also uses a different percent encode set from the Chrome
    implementation.

1. [=list/Append=] "hostname=" to |queryParamsList|.
1. [=list/Append=] the result of [=string/UTF-8 percent-encoding=] the
  [=serialization of an origin|serialized=] |topLevelOrigin| using [=component percent-encode set=]
  to |queryParamsList|.
1. If |keys| is not [=set/is empty|empty=]:
  1. [=list/Append=] "`&keys=`" to |queryParamsList|.
  1. [=list/Append=] to |queryParamsList| the result of [=encode trusted signals keys=] with
    |keys|.
1. If |igNames| is not [=set/is empty|empty=]:
  1. [=list/Append=] "`&interestGroupNames=`" to |queryParamsList|.
  1. [=list/Append=] to |queryParamsList| the result of [=encode trusted signals keys=] with
    |igNames|.
1. If |experimentGroupId| is not null:
  1. [=list/Append=] "`&experimentGroupId=`" to |queryParamsList|.
  1. [=list/Append=] [=serialize an integer|serialized=] |experimentGroupId| to |queryParamsList|.
1. [=list/Append=] |slotSizeQueryParam| to |queryParamsList|.
1. Let |fullSignalsUrl| be |signalsUrl|.
1. Set |fullSignalsUrl|'s [=url/query=] to the result of [=string/concatenating=] |queryParamsList|.
1. Return |fullSignalsUrl|.

</div>

<div algorithm>
To <dfn>fetch the current outstanding trusted signals batch</dfn> given a
[=trusted bidding signals batcher=] |trustedBiddingSignalsBatcher|, a [=URL=] |signalsUrl|,
an [=origin=] |scriptOrigin|, an {{unsigned short}}-or-null |experimentGroupId|, an [=origin=]
|topLevelOrigin|, a [=string=] |slotSizeQueryParam|, and a [=policy container=] |policyContainer|:

  1. If |signalsUrl| is null, return.
  1. Let |biddingSignalsUrl| be the result of [=building trusted bidding signals url=] with
     |signalsUrl|, |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/keys=],
     |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/ig names=],
     |experimentGroupId|, |topLevelOrigin|, and |slotSizeQueryParam|.
  1. Let « |partialTrustedBiddingSignals|, |partialPerInterestGroupData|, |dataVersion| » be the
     result of [=fetching trusted signals=] with |biddingSignalsUrl|, |scriptOrigin|,
     |policyContainer| and true.
  1. If |partialTrustedBiddingSignals| is not null:
    1. [=map/For each=] |key| → |value| in |partialTrustedBiddingSignals|, [=map/set=]
      |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/all trusted bidding
      signals=][|key|] to |value|.
    1. [=set/For each=] |igName| of |trustedBiddingSignalsBatcher|'s [=trusted bidding signals
      batcher/ig names=], [=map/set=] |trustedBiddingSignalsBatcher|'s [=trusted bidding signals
      batcher/data versions=][|igName|] to |dataVersion|.
    1. [=Append to a bidding signals per-interest group data map=] with
       |partialPerInterestGroupData|, |trustedBiddingSignalsBatcher|'s
       [=trusted bidding signals batcher/ig names=], and |trustedBiddingSignalsBatcher|'s
       [=trusted bidding signals batcher/all per interest group data=].
  1. Otherwise, [=set/for each=] |igName| of |trustedBiddingSignalsBatcher|'s
    [=trusted bidding signals batcher/ig names=]:
    1. [=map/Set=] |trustedBiddingSignalsBatcher|'s
       [=trusted bidding signals batcher/no signals flags=][|igName|] to "fetch-failed".

</div>

<div algorithm>
To <dfn>batch or fetch trusted bidding signals</dfn> given a [=trusted bidding signals batcher=]
|trustedBiddingSignalsBatcher|, [=interest group=] |ig|, a [=URL=] |signalsUrl|, an [=origin=]
|scriptOrigin|, an {{unsigned short}}-or-null |experimentGroupId|, an [=origin=] |topLevelOrigin|, a
[=string=] |slotSizeQueryParam|, and a [=policy container=] |policyContainer|:

  1. Let |igName| be |ig|'s [=interest group/name=].
  1. If |signalsUrl| is null:
    1. [=map/Set=] |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/no signals flags=]
      [|igName|] to "no-fetch".
    1. Return.
  1. [=map/Set=] |trustedBiddingSignalsBatcher|'s
     [=trusted bidding signals batcher/no signals flags=][|igName|] to "no-fetch"
     if |ig|'s [=interest group/trusted bidding signals keys=] is null or [=map/is empty=].

     Note: An interest group with no trusted signals keys requests would still fetch and process
     per-interest group data like priorityVector and
     [=bidding signals per interest group data/update if older than ms=], but it will get null passed in
     to its bidding function.

  1. If |ig|'s [=interest group/trusted bidding signals coordinator=] is null:
    1. Let |putativeKeys| be a [=set/clone=] of |trustedBiddingSignalsBatcher|'s
      [=trusted bidding signals batcher/keys=].
    1. Let |putativeIgNames| be a [=set/clone=] of |trustedBiddingSignalsBatcher|'s
      [=trusted bidding signals batcher/ig names=].
    1. Let |putativeLengthLimit| be  |ig|'s [=interest group/max trusted bidding signals url length=].
    1. If |ig|'s [=interest group/max trusted bidding signals url length=] is 0 or &gt;
      |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/length limit=],
      then set |putativeLengthLimit| to |trustedBiddingSignalsBatcher|'s
      [=trusted bidding signals batcher/length limit=].
    1. If |ig|'s [=interest group/trusted bidding signals keys=] is not null, [=list/extend=]
      |putativeKeys| with |ig|'s [=interest group/trusted bidding signals keys=].
    1. [=list/Append=] |igName| to |putativeIgNames|.
    1. Let |biddingSignalsUrl| be the result of [=building trusted bidding signals url=] with
      |signalsUrl|, |putativeKeys|, |putativeIgNames|, |experimentGroupId|, |topLevelOrigin|, and
      |slotSizeQueryParam|.
    1. If [=URL serializer|serialized=] |biddingSignalsUrl|'s [=string/length=] &le; |putativeLengthLimit|:
        1. Set |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/keys=] to |putativeKeys|.
        1. Set |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/ig names=] to
          |putativeIgNames|.
        1. Set |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/length limit=] to
          |putativeLengthLimit|.
    1. Otherwise:
      1. [=Fetch the current outstanding trusted signals batch=] given |trustedBiddingSignalsBatcher|,
        |signalsUrl|, |scriptOrigin|, |experimentGroupId|, |topLevelOrigin|, |slotSizeQueryParam|, and
        |policyContainer|.
      1. If |ig|'s [=interest group/trusted bidding signals keys=] is not null, set
        |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/keys=] to a
        [=list/clone=] of |ig|'s [=interest group/trusted bidding signals keys=].
      1. Otherwise, set |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/keys=] to a
        new [=list=].
      1. Set |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/ig names=] to
          « |igName| ».
      1. Set |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/length limit=] to
        |ig|'s [=interest group/max trusted bidding signals url length=].
  1. Otherwise:
    1. Let |keyValueInterestGroups| be |trustedBiddingSignalsBatcher|'s [=trusted bidding signals
      batcher/key value interest groups=].
    1. Let |key| be [=tuple=] of (|ig|'s [=interest group/joining origin=], |ig|'s [=interest group/owner=]).
    1. If |keyValueInterestGroups| [=map/contains=] |key|, [=set/append=] |ig| to
      |keyValueInterestGroups|[|key|].
    1. Otherwise, [=map/set=] |keyValueInterestGroups|[|key|] to a [=set=] « |ig| ».

</div>

<div algorithm>

To <dfn>build trusted key value bidding signals request body</dfn> given a [=set=] |interestGroups|,
an {{unsigned short}}-or-null |experimentGroupId|, an [=origin=] |topLevelOrigin|, a [=string=]
|slotSizeQueryParam|, an [=origin=] |coordinator|, and an [=origin=] |owner|:

1. Let |compressionGroups| be an empty [=list=], whose [=list/items=] are [=bidding compression groups=].
1. Let |compressionGroupMap| be an empty [=map=], where the [=map/keys=] are integers as
  [=bidding compression group/compression group id=], and the [=map/values=] are [=maps=] with integers as [=map/keys=]
  for [=bidding partition/id=], and [=bidding partitions=] as their [=map/values=].
1. Let |compressionIdMap| be an empty [=map=], whose [=map/keys=] are [=origins=] and [=map/values=] are integers.
1. Let |interestGroupIdMap| be an empty [=map=], whose [=map/keys=] are [=strings=] and [=map/values=] are [=tuples=]
  of (interger, integer).
1. Let |slotSizeParams| be the result of [=strictly splitting=] |slotSizeQueryParam| on U+003D (=).
1. Let |nextCompressionGroupId| be 0.
1. [=list/For each=] |group| of |interestGroups|:
  1. Let |joiningOrigin| be |group|'s [=interest group/joining origin=].
  1. If |compressionIdMap| does not [=map/contain=] |joiningOrigin|:
    1. [=map/Set=] |compressionIdMap|[|joiningOrigin|] to |nextCompressionGroupId|.
    1. Increment |nextCompressionGroupId| by 1.
  1. Let |compressionGroupId| be |compressionIdMap|[|joiningOrigin|].
  1. If |compressionGroupMap| does not [=map/contain=] |compressionGroupId|:
    1. [=map/Set=] |compressionGroupMap|[|compressionGroupId|] to an empty [=map=], whose [=map/keys=] are integers
      and [=map/values=] are [=maps=].
  1. Let |partitionId| be 0.
  1. If |group|'s [=interest group/execution mode=] is not "`group-by-origin`":
    1. If |compressionGroupMap|[|compressionGroupId|] [=map/contains=] 0, set |partitionId| to
      [=map/size=] of |compressionGroupMap|[|compressionGroupId|].
    1. Otherwise, set |partitionId| to [=list/size=] of |compressionGroupMap|[|joiningOrigin|] plus 1.
  1. [=map/Set=] |interestGroupIdMap|[|group|'s [=interest group/name=]] to [=tuple=] of
    (|compressionGroupId|, |partitionId|).
  1. If |compressionGroupMap|[|compressionGroupId|] does not [=map/contain=] |partitionId|, set
    |compressionGroupMap|[|compressionGroupId|][|partitionId|] to a [=bidding partition=] with the following [=struct/items=]:
    : [=bidding partition/id=]
    :: |partitionId|

    : [=bidding partition/namespace=]
    :: The [=ordered map=] «[ "interestGroupNames" → « |group|'s [=interest group/name=] »,
      "biddingKeys" → |group|'s [=interest group/trusted bidding signals keys=] ]»

    : [=bidding partition/metadata=]
    :: The [=ordered map=] «[ "experimentGroupId" → |experimentGroupId|, |slotSizeParams|[0] → |slotSizeParams|[1] ]»
  1. Otherwise:
    1. [=list/Append=] |group|'s [=interest group/name=] into |compressionGroupMap|[|compressionGroupId|]
      [|partitionId|]["interest_group_names"].
    1. [=list/Append=] |group|'s [=interest group/trusted bidding signals keys=] into
      |compressionGroupMap|[|compressionGroupId|][|partitionId|]["bidding_keys"].
1. [=map/For each=] |id| → |group| in |compressionGroupMap|:
  1. Let |compressionGroup| be a [=bidding compression group=], whose
    [=bidding compression group/compression group id=] is |id|, and
    [=bidding compression group/partition=] is an empty [=list=].
  1. [=list/For each=] |partition| in |group|'s [=map/values=]:
    1. [=list/Append=] |partition| to |compressionGroup|'s [=bidding compression group/partition=].
  1. [=list/Append=] |compressionGroup| to |compressionGroups|.
1. Let |metadata| be an empty [=map=], whose [=map/keys=] and [=map/values=] are [=strings=].
1. Let |hostname| be the result of [=string/UTF-8 percent-encoding=] the
  [=serialization of an origin|serialized=] |topLevelOrigin| using [=component percent-encode set=].
1. [=map/Set=] |metadata|["hostname"] to |hostname|.
1. Let |keyInfo| be the result of [=looking up the server encryption key=] with |owner| and
  |coordinator|.
1. If |keyInfo| is failure, then return « null, null, null ».
1. Let (|requestBlob|, |context|) be the result of generating request with |keyInfo|, |metadata| and
  |compressionGroups|. The generation method may follow that described in
  [Section 2.2.4 of the Protected Audience Key Value Services](https://privacysandbox.github.io/draft-ietf-protected-audience-key-value-service/draft-ietf-protected-audience-key-value-services.html#name-generating-a-request).
1. Return « |requestBlob|, |interestGroupIdMap|, |context| ».

</div>

<div algorithm>
To <dfn>fetch the trusted key value signals batch</dfn> given a
[=trusted bidding signals batcher=] |trustedBiddingSignalsBatcher|, a [=URL=] |signalsUrl|,
an [=origin=] |scriptOrigin|, an {{unsigned short}}-or-null |experimentGroupId|, an [=origin=]
|topLevelOrigin|, a [=string=] |slotSizeQueryParam|, and a [=policy container=] |policyContainer|:

  1. If |signalsUrl| is null, return.
  1. [=map/For each=] (|joiningOrigin|, |owner|) → |interestGroups| of [=trusted bidding signals
    batcher/key value interest groups=]:
    1. Let « |requestBody|, |interestGroupIdMap|, |context| » be the result of [=building trusted
      key value bidding signals request body=] with |interestGroups|, |experimentGroupId|,
      |topLevelOrigin|, |slotSizeQueryParam|, |joiningOrigin| and |owner|.
    1. If |requestBody| is not null:
      1. Let « |partialTrustedBiddingSignals|, |partialPerInterestGroupData|, |dataVersion| » be the
        result of [=fetching trusted key value signals=] with |signalsUrl|, |requestBody|, |context|,
        |scriptOrigin|, |policyContainer|, |interestGroupIdMap| and true.
    1. If |partialTrustedBiddingSignals| is not null:
      1. [=map/For each=] |key| → |value| in |partialTrustedBiddingSignals|, [=map/set=]
        |trustedBiddingSignalsBatcher|'s [=trusted bidding signals batcher/all trusted bidding
        signals=][|key|] to |value|.
      1. Let |igNames| be |interestGroupIdMap|'s [=map/keys=].
      1. [=set/For each=] |igName| of |igNames|, [=map/set=] |trustedBiddingSignalsBatcher|'s
        [=trusted bidding signals batcher/data versions=][|igName|] to |dataVersion|[|igName|].
      1. [=Append to a bidding signals per-interest group data map=] with
        |partialPerInterestGroupData|, |igNames|, and |trustedBiddingSignalsBatcher|'s
        [=trusted bidding signals batcher/all per interest group data=].
    1. Otherwise, [=set/for each=] |igName| of |igNames|:
      1. [=map/Set=] |trustedBiddingSignalsBatcher|'s
        [=trusted bidding signals batcher/no signals flags=][|igName|] to "fetch-failed".

</div>

<h3 id=trusted-seller-signals-batcher>Trusted scoring signals batcher</h3>

A <dfn>trusted scoring signals batcher</dfn> helps manage merging multiple trusted scoring signals
requests into smaller number of fetches. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="trusted scoring signals batcher">
  : <dfn>request queue</dfn>
  :: A [=list=] of [=trusted scoring signals requests=] that hasn't yet been organized to aid
    batching.
  : <dfn>request map</dfn>
  :: A [=map=] from a tuple of [=script fetcher=], a [=URL=] representing the trusted signals
    base [=URL=], {{unsigned short}} or null for experiment ID, [=origin=] or null for coordinator,
    and [=origin=], representing the top frame's [=origin=], and a [=boolean=] representing whether
    to send creative scanning info, to a [=list=] of [=trusted scoring
    signals requests=]. This organizes fetches that can possibly be merged together.
  : <dfn>url length limit</dfn>
  :: A {{long}} denoting a user-configured limit which should not be exceeded due to combining of
    fetches. 0 denotes no limit, and is the initial value.
</dl>

A <dfn>creative info</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="creative info">
  : <dfn>ad descriptor</dfn>
  :: An [=ad descriptor=].
  : <dfn>creative scanning metadata</dfn>
  :: A [=string=], initially empty.
  : <dfn>interest group owner</dfn>
  :: [=origin=], or null.
  : <dfn>buyer or seller reporting id</dfn>
  :: A [=string=], initially empty.
</dl>

<div algorithm>
To <dfn>fill in creative info</dfn> given a [=boolean=] |sendCreativeScanningMetadata|,
an [=ad descriptor=] |adDescriptor|, an [=origin=] |ownerOrigin|, and
an [=interest group ad=] |bidAd|:

  1. Let |result| be a new [=creative info=].
  1. If |sendCreativeScanningMetadata| is true:
    1. Set |result|'s [=creative info/ad descriptor=] to |adDescriptor|.
    1. If |bidAd|'s [=interest group ad/creative scanning metadata=] is not null, set |result|'s
      [=creative info/creative scanning metadata=] to it.
    1. Set |result|'s [=creative info/interest group owner=] to |ownerOrigin|.
    1. If |bidAd|'s [=interest group ad/buyer and seller reporting ID=] is not null, set |result|'s
      [=creative info/buyer or seller reporting id=] to it.
  1. Otherwise:
    1. Set |result|'s [=creative info/ad descriptor=] to a new [=ad descriptor=] whose
      [=ad descriptor/url=] to |adDescriptor|'s [=ad descriptor/url=].
  1. Return |result|.
</div>

A <dfn>trusted scoring signals request</dfn> is a [=struct=] with the following [=struct/items=],
representing all information needed to produce a trusted scoring signals fetch for a single scoring
invocation:

<dl dfn-for="trusted scoring signals request">
  : <dfn>send creative scanning metadata</dfn>
  :: A [=boolean=], to determine whether creative scanning metadata should be added to requests
    using the basic HTTP GET based protocol (rather than encrypted one for TEE).
  : <dfn>seller</dfn>
  :: An [=origin=] of the seller the fetch is on behalf of.
  : <dfn>seller script fetcher</dfn>.
  :: A [=script fetcher=] for the seller's decision logic script.
  : <dfn>base url</dfn>
  :: A [=URL=], the base URL for trusted seller signals to fetch.
  : <dfn>seller experiment group id</dfn>
  :: Null or an {{unsigned short}}, initially null.
  : <dfn>top level origin</dfn>
  :: An [=origin=]. The origin of top-level frame in the hierarchy containing the document running
    the auction.
  : <dfn>ad</dfn>
  :: The [=creative info=] for main ad to pass with the fetch.
  : <dfn>ad components</dfn>
  :: A [=set=] of [=creative info=], information about component ads to pass with the fetch.
  : <dfn>policy container</dfn>
  :: A [=policy container=] to use for the network fetch.
  : <dfn>signal coordinator</dfn>
  :: An [=origin=] to use for the public key fetch.
  : <dfn>owner origin</dfn>
  :: An [=origin=] of the owner on behalf of the initial interest group.
  : <dfn>joining origin</dfn>
  :: An [=origin=] of the owner's joining origin on behalf of the initial interest group.
  : <dfn>reply</dfn>
  :: A [=trusted scoring signals reply=], null, or failure. Initially null. Set to a non-null value
    when the fetch has been completed.
</dl>

A <dfn>trusted scoring signals reply</dfn> is a [=struct=] with the following [=struct/items=]
<dl dfn-for="trusted scoring signals reply">
  : <dfn>all trusted scoring signals</dfn>
  :: A [=ordered map=] or failure.
  : <dfn>data version</dfn>
  :: An {{unsigned long}} or null.
</dl>

A <dfn>scoring compression group</dfn> is a collection of [=scoring partitions=] that can be compressed
together in the signals response. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="scoring compression group">
  : <dfn>compression group id</dfn>
  :: An integer indicates the index of this compression group.
  : <dfn>partitions</dfn>
  :: A [=list=] of [=scoring partition=]. Contains all the [=scoring partitions=] belong to this compression
    group.
</dl>

A <dfn>scoring partition</dfn> is a collection of ad and ad component render URLs that can be
processed together by the service without any potential privacy leakage. It's a [=struct=] with the
following [=struct/items=]:

<dl dfn-for="scoring partition">
  : <dfn>id</dfn>
  :: An integer indicates the index of this partition.
  : <dfn>namespace</dfn>
  :: A [=map=], whose [=map/keys=] are [=strings=] and [=map/values=] are [=list=] of
    [=strings=]. A namespace contains all URLs of ads and component ads in the partition.
  : <dfn>metadata</dfn>
  :: A [=map=], whose [=map/keys=] and [=map/values=] are [=strings=].
</dl>

<div algorithm>

To <dfn>create a trusted scoring signals batcher</dfn> given a {{long}} |urlLengthLimit|:

1. Let |batcher| be a new [=trusted scoring signals batcher=].
1. Set |batcher|'s [=trusted scoring signals batcher/url length limit=] to |urlLengthLimit|.
1. Let |queue| be the result of [=starting a new parallel queue=].
1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |queue|:
  1. [=Batch and fetch trusted scoring signals=] given |batcher|.
1. Return |batcher|.

</div>

<div algorithm>

To <dfn>fetch trusted scoring signals with batching</dfn> given a [=trusted scoring signals
batcher=] |batcher| and a [=trusted scoring signals request=] |request|:
1. [=list/Append=] |request| to |batcher|'s [=trusted scoring signals batcher/request queue=].
1. Wait until |request|'s [=trusted scoring signals request/reply=] is non-null.
1. Return |request|'s [=trusted scoring signals request/reply=].

</div>

<div algorithm>
To <dfn>extract URLs from creative info</dfn> given an [=ordered set=] of [=creative info=]
|creativeInfoSet|:

1. Let |result| be a new [=list=] of [=strings=].
1. [=set/For each=] |creativeInfo| in |creativeInfoSet|:
  1. [=list/Append=] [=URL serializer|serialized=] |creativeInfo|'s [=creative info/ad
    descriptor=]'s [=ad descriptor/url=] to |result|.
1. Return |result|.

</div>

<div algorithm>
To <dfn>extract creative scanning metadata</dfn> given an [=ordered set=] of [=creative info=]
|creativeInfoSet|:

1. Let |result| be a new [=list=] of [=strings=].
1. [=set/For each=] |creativeInfo| in |creativeInfoSet|:
  1. [=list/Append=] |creativeInfo|'s [=creative info/creative scanning metadata=] to |result|.
1. Return |result|.

</div>

<div algorithm>
To <dfn>extract buyers</dfn> given an [=ordered set=] of [=creative info=] |creativeInfoSet|:

1. Let |result| be a new [=list=] of [=strings=].
1. [=set/For each=] |creativeInfo| in |creativeInfoSet|:
  1. [=list/Append=] the [=serialization of an origin|serialization=] of |creativeInfo|'s
    [=creative info/interest group owner=] to |result|.
1. Return |result|.

</div>

<div algorithm>
To <dfn>extract buyer and seller reporting ids</dfn> given an [=ordered set=] of [=creative info=]
|creativeInfoSet|:

1. Let |result| be a new [=list=] of [=strings=].
1. [=set/For each=] |creativeInfo| in |creativeInfoSet|:
  1. [=list/Append=] |creativeInfo|'s [=creative info/buyer or seller reporting id=] to |result|.
1. Return |result|.

</div>

<div algorithm>
To <dfn>add trusted signals param if needed</dfn> given a [=string=] |param|, a [=list=] of
[=strings=] |input| and a [=list=] of [=strings=] |queryParamsList|:

1. If |input| [=list/is not empty=]:
  1. [=list/Append=] |param| to |queryParamsList|.
  1. [=list/Append=] the result of [=encode trusted signals keys=] of |input| to |queryParamsList|.

</div>


<div algorithm>
To <dfn>add trusted signals size param if needed</dfn> given a [=string=] |param|, a [=list=] of
[=creative info=] |input| and a [=list=] of [=strings=] |queryParamsList|:

1. If |input| [=list/is not empty=]:
  1. [=list/Append=] |param| to |queryParamsList|.
  1. Let |sizes| be an empty [=list=] of [=strings=].
  1. [=list/For each=] |creative| of |input|:
    1. If |creative|'s [=creative info/ad descriptor=]'s [=ad descriptor/size=] is null,
      [=list/append=] "`,`" to |sizes|.
    1. Otherwise, [=list/append=] the result of [=converting an ad size to a string=] given
      |creative|'s [=creative info/ad descriptor=]'s [=ad descriptor/size=] to |sizes|.
  1. [=list/Append=] the result of [=string/concatenating=] |sizes| with separator set to "," to
    |queryParamsList|.

  Note: this works differently from other query parameters since it has a comma that we do not
  want to escape, and none of the other characters used to represent the width and height of each ad
  need to be escaped either.

</div>

<div algorithm>
To <dfn>build trusted scoring signals url</dfn> given a [=boolean=] |sendCreativeScanningMetadata|,
a [=URL=] |signalsUrl|, an [=ordered set=] of [=creative info=] |ads|, an [=ordered set=] of
[=creative info=] |componentAds|, an {{unsigned short}} |experimentGroupId|, and an [=origin=]
|topLevelOrigin|:

Note: When trusted scoring signals fetches are not batched, |ads|'s [=set/size=] is 1.

1. Let |queryParamsList| be a new empty [=list=].
1. [=list/Append=] "hostname=" to |queryParamsList|.
1. [=list/Append=] the result of [=string/UTF-8 percent-encoding=] |topLevelOrigin| using
  [=component percent-encode set=] to |queryParamsList|.
1. Let |renderURLs| be the result of [=extracting URLs from creative info=] given |ads|.
1. [=Add trusted signals param if needed=] given "`&renderURLs=`", |renderURLs|,
  |queryParamsList|.
1. Let |adComponentRenderURLs| be the result of [=extracting URLs from creative info=] given
  |componentAds|.
1. If |adComponentRenderURLs| [=list/is not empty=]:
1. [=Add trusted signals param if needed=] given "`&adComponentRenderURLs=`",
  |adComponentRenderURLs|, |queryParamsList|.
1. If |experimentGroupId| is not null:
  1. [=list/Append=] "`&experimentGroupId=`" to |queryParamsList|.
  1. [=list/Append=] [=serialize an integer|serialized=] |experimentGroupId| to |queryParamsList|.
1. If |sendCreativeScanningMetadata| is true:
  1. [=Add trusted signals param if needed=] given "`&adCreativeScanningMetadata=`",
    the result of [=extracting creative scanning metadata=] given |ads|, |queryParamsList|.
  1. [=Add trusted signals param if needed=] given "`&adComponentCreativeScanningMetadata=`",
    the result of [=extracting creative scanning metadata=] given |componentAds|, |queryParamsList|.
  1. [=Add trusted signals size param if needed=] given "`&adSizes=`", |ads|, |queryParamsList|.
  1. [=Add trusted signals size  param if needed=] given "`&adComponentSizes=`", |componentAds|,
    |queryParamsList|.
  1. [=Add trusted signals param if needed=] given "`&adBuyer=`",
    the result of [=extracting buyers=] given |ads|, |queryParamsList|.
  1. [=Add trusted signals param if needed=] given "`&adComponentBuyer=`",
    the result of [=extracting buyers=] given |componentAds|, |queryParamsList|.
  1. [=Add trusted signals param if needed=] given "`&adBuyerAndSellerReportingIds=`",
    the result of [=extracting buyer and seller reporting ids=] given |ads|, |queryParamsList|.
1. Set |signalsUrl|'s [=url/query=] to the result of [=string/concatenating=] |queryParamsList|.
1. Return |signalsUrl|.

</div>

<div algorithm>
To <dfn>build batched trusted scoring signals url</dfn> given a non-empty [=list=] of [=trusted
scoring signals requests=] |entriesToBatch|:

1. Let |firstEntry| be |entriesToBatch|[0].
1. Let |ads| be an empty [=ordered set=] of [=creative info=].
1. Let |componentAds| be an empty [=ordered set=] of [=creative info=].
1. [=list/For each=] |entry| of |entriesToBatch|:
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/base URL=] is equal to
    |firstEntry|'s [=trusted scoring signals request/base URL=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/seller experiment group id=] is
    equal to |firstEntry|'s [=trusted scoring signals request/seller experiment group id=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/top level origin=] is equal to
    |firstEntry|'s [=trusted scoring signals request/top level origin=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/seller script fetcher=] is equal to
    |firstEntry|'s [=trusted scoring signals request/seller script fetcher=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/policy container=] is equal to
    |firstEntry|'s [=trusted scoring signals request/policy container=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/send creative scanning metadata=]
    is equal to |firstEntry|'s [=trusted scoring signals request/send creative scanning metadata=].
  1. [=set/Append=] |entry|'s [=trusted scoring signals request/ad=] to |ads|.
  1. [=list/Extend=] |componentAds| with |entry|'s [=trusted scoring signals request/
    ad components=].
1. Return the result of [=building trusted scoring signals url=] with |firstEntry|'s [=trusted
  scoring signals request/send creative scanning metadata=], |firstEntry|'s [=trusted
  scoring signals request/base URL=], |ads|, |componentAds|, |firstEntry|'s
  [=trusted scoring signals request/seller experiment group id=],
  |firstEntry|'s [=trusted scoring signals request/top level origin=].

</div>

<div algorithm>
To <dfn>check if trusted scoring signals batch honors URL length limit</dfn> given a
[=trusted scoring signals batcher=] |batcher| and a non-empty [=list=] of [=trusted
scoring signals requests=] |entriesToBatch|:

1. If the [=list/size=] of |entriesToBatch| is 1, return true.
1. If |batcher|'s [=trusted scoring signals batcher/url length limit=] is 0, return true.
1. Return whether the [=string/length=] of the result of [=building batched trusted scoring signals
  url=] for |entriesToBatch| &le; |batcher|'s [=trusted scoring signals batcher/url length
  limit=].

</div>

<div algorithm>

To <dfn>build trusted key value scoring signals request body</dfn> given a non-empty [=list=] of
[=trusted scoring signals requests=] |entriesToBatch|:

1. Let |firstRequest| be |entriesToBatch|[0].
1. Let |compressionGroups| be an empty [=list=], whose [=list/items=] are [=scoring compression groups=].
1. Let |compressionGroupMap| be an empty [=map=], where the [=map/keys=] are integers as
  [=scoring compression group/compression group id=], and the [=map/values=] are [=maps=] with integers as [=map/keys=]
  for [=scoring partition/id=], and [=scoring partitions=] as their [=map/values=].
1. Let |compressionIdMap| be an empty [=map=], whose [=map/keys=] are [=tuples=] of ([=origin=],
  [=origin=]) and [=map/values=] are integers.
1. Let |renderUrlIdMap| be an empty [=map=], whose [=map/keys=] are [=URLs=] and [=map/values=] are [=tuples=]
  of (interger, integer).
1. Let |nextCompressionGroupId| be 0.
1. [=map/For each=] |request| of |entriesToBatch|:
  1. Let |mapKey| be a [=tuple=] of (|request|'s [=trusted scoring signals request/owner origin=],
    |request|'s [=trusted scoring signals request/joining origin=]).
  1. If |compressionIdMap| does not [=map/contain=] |mapKey|:
    1. [=map/Set=] |compressionIdMap|[|mapKey|] to |nextCompressionGroupId|.
    1. Increment |nextCompressionGroupId| by 1.
  1. Let |compressionGroupId| be |compressionIdMap|[|mapKey|].
  1. If |compressionGroupMap| does not [=map/contain=] |compressionGroupId|, then set
    |compressionGroupMap|[|compressionGroupId|] to an empty [=map=], whose [=map/keys=] are integers.
  1. Let |partitionId| be [=map/size=] of |compressionGroupMap|[|compressionGroupId|].
  1. Let |renderURL| be |request|'s [=trusted scoring signals request/ad=]'s
    [=creative info/ad descriptor=]'s [=ad descriptor/url=].
  1. Let |adComponentRenderURLs| be the result of [=extracting URLs from creative info=] given
    |request|'s [=trusted scoring signals request/ad components=].
  1. [=map/Set=] |renderUrlIdMap|[|renderURL|] to [=tuple=] of (|compressionGroupId|, |partitionId|).
  1. [=map/Set=] |compressionGroupMap|[|compressionGroupId|][|partitionId|] to a [=scoring partition=] with the
    following [=struct/items=]:
    : [=scoring partition/id=]
    :: |partitionId|

    : [=scoring partition/namespace=]
    :: The [=ordered map=] «[ "renderUrls" → « |renderURL| »,
      "adComponentRenderUrls" → |adComponentRenderURLs| ]»

    : [=scoring partition/metadata=]
    :: The [=ordered map=] «[ "experimentGroupId" → |firstRequest|'s [=trusted scoring signals request/seller experiment group id=] ]»
1. [=map/For each=] |id| → |group| in |compressionGroupMap|:
  1. Let |compressionGroup| be an [=scoring compression group=] whose [=scoring compression group/compression group id=]
    is |id| and [=scoring compression group/partition=] is an empty [=list=].
  1. [=list/For each=] |partition| in |group|'s [=map/values=]:
    1. [=list/Append=] |partition| to |compressionGroup|'s [=scoring compression group/partitions=].
  1. [=list/Append=] |compressionGroup| to |compressionGroups|.
1. Let |metadata| be an empty [=map=], whose [=map/keys=] and [=map/values=] are [=strings=].
1. Let |hostname| be the result of [=string/UTF-8 percent-encoding=] the
  [=serialization of an origin|serialized=] |firstRequest|'s [=trusted scoring signals request/top
    level origin=] using [=component percent-encode set=].
1. [=map/Set=] |metadata|["hostname"] to |hostname|.
1. Let |keyInfo| be the result of [=looking up the server encryption key=] with |firstRequest|'s
  [=trusted scoring signals request/seller=] and |firstRequest|'s [=trusted scoring signals
  request/signal coordinator=].
1. If |keyInfo| is failure, then return « null, null, null ».
1. Let (|requestBlob|, |context|) be the result of generating request with |keyInfo|, |metadata| and
  |compressionGroups|. The generation method may follow that described in
  [Section 2.2.4 of the Protected Audience Key Value Services](https://privacysandbox.github.io/draft-ietf-protected-audience-key-value-service/draft-ietf-protected-audience-key-value-services.html#name-generating-a-request).
1. Return « |requestBlob|, |renderUrlIdMap| and |context| ».

</div>

<div algorithm>

To <dfn>build batched trusted key value scoring signals request body</dfn> given a non-empty [=list=] of
[=trusted scoring signals requests=] |entriesToBatch|:

1. Let |firstEntry| be |entriesToBatch|[0].
1. [=list/For each=] |entry| of |entriesToBatch|:
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/base URL=] is equal to
    |firstEntry|'s [=trusted scoring signals request/base URL=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/seller=] is equal to
    |firstEntry|'s [=trusted scoring signals request/seller=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/seller experiment group id=] is
    equal to |firstEntry|'s [=trusted scoring signals request/seller experiment group id=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/top level origin=] is equal to
    |firstEntry|'s [=trusted scoring signals request/top level origin=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/seller script fetcher=] is equal to
    |firstEntry|'s [=trusted scoring signals request/seller script fetcher=].
  1. [=Assert=] that |entry|'s [=trusted scoring signals request/policy container=] is equal to
    |firstEntry|'s [=trusted scoring signals request/policy container=].
1. Return the result of [=building trusted key value scoring signals request body=] with
   |entriesToBatch|.

</div>

<div algorithm>

To <dfn>batch and fetch trusted scoring signals</dfn> given a [=trusted scoring signals batcher=]
|batcher|:

1. [=Assert=] that these steps are running [=in parallel=].
1. Until |batcher| is no longer needed:
  1. Wait until at least one of the following is true:
    * |batcher|'s [=trusted scoring signals batcher/request queue=] [=list/is not empty=].
    * |batcher|'s [=trusted scoring signals batcher/request map=] [=map/is not empty=] and some
      heuristically chosen amount of time has passed.
  1. Atomically do:
    1. Let |incomingRequests| be a [=list/clone=] of |batcher|'s [=trusted scoring signals batcher/
      request queue=].
    1. [=list/Empty=] |batcher|'s [=trusted scoring signals batcher/request queue=].

    Note: the result of atomicity is that any concurrent attempts to modify |batcher|'s [=trusted
    scoring signals batcher/request queue=] while these steps are running will not result in
    different items being removed by the [=list/Empty=] operation than were cloned into
    |incomingRequests|.

  1. [=list/For each=] |request| in |incomingRequests|:
    1. Let |key| be (|request|'s [=trusted scoring signals request/seller script fetcher=],
      |request|'s [=trusted scoring signals request/base url=], |request|'s [=trusted scoring
      signals request/seller experiment group id=], |request|'s [=trusted scoring signals request/
      top level origin=], |request|'s [=trusted scoring signals request/signal coordinator=],
      |request|'s [=trusted scoring signals request/send creative scanning metadata=]).
    1. If |batcher|'s [=trusted scoring signals batcher/request map=][|key|] does not [=map/exist=],
      then [=map/set=] |batcher|'s [=trusted scoring signals batcher/request map=][|key|] to an
      [=list/is empty|empty=] [=list=].
    1. [=list/Append=] |request| to |batcher|'s [=trusted scoring signals batcher/request
      map=][|key|].
  1. Some number of times, heuristically, select a |key| from |batcher|'s [=trusted scoring signals
    batcher/request map=]:
    1. If |key|'s [=trusted scoring signals request/signal coordinator=] is null:
      1. Select a non-[=list/is empty|empty=] [=set/subset=] of |batcher|'s [=trusted scoring
        signals batcher/request map=][|key|], called |entriesToBatch|, such that [=checking if
        trusted scoring signals batch honors URL length limit=] on |batcher| and |entriesToBatch|
        returns true:

        Note: implementations are free to wait to collect more requests to merge (by leaving things
        in the |batcher|'s [=trusted scoring signals batcher/request map=]), or send them
        individually, but need to take into account the configured URL length limit if they do
        combine requests. All entries need to be handled eventually.

        1. [=list/Remove=] |entriesToBatch| from |batcher|'s [=trusted scoring signals batcher/
          request map=][|key|].
        1. If |batcher|'s [=trusted scoring signals batcher/request map=][|key|] [=list/is empty=],
          then [=map/remove=] |key| from |batcher|'s [=trusted scoring signals batcher/request map=].
        1. Let |fullSignalsUrl| be the result of [=building batched trusted scoring signals url=] for
          |entriesToBatch|.
        1. Let |seller| be |entriesToBatch|[0]'s [=trusted scoring signals request/seller=].
        1. Let |scriptFetcher| be |entriesToBatch|[0]'s [=trusted scoring signals request/seller
          script fetcher=].
        1. If |fullSignalsUrl|'s [=url/origin=] is not [=same origin=] with |seller| then:
          1. Let |allowCrossOriginTrustedScoringSignalsFrom| be the result of [=wait for cross origin
            trusted scoring signals authorization from a fetcher=] given |scriptFetcher|.
          1. If |allowCrossOriginTrustedScoringSignalsFrom| does not [=list/contain=]
            |fullSignalsUrl|'s [=url/origin=], set |fullSignalsUrl| to null.
        1. Let |result| be failure.
        1. If |fullSignalsUrl| is not null:
          1. Let «|allTrustedScoringSignals|, <var ignore>ignored</var>, |scoringDataVersion|» be
            the result of [=fetching trusted signals=] with |fullSignalsUrl|, |seller|,
            |entriesToBatch|[0]'s [=trusted scoring signals request/policy container=], and false.
          1. If |allTrustedScoringSignals| is an [=ordered map=]:
            1. Set |result| to a new [=trusted scoring signals reply=]
            1. Set |result|'s [=trusted scoring signals reply/all trusted scoring signals=] to
              |allTrustedScoringSignals|.
            1. Set |result|'s [=trusted scoring signals reply/data version=] to |scoringDataVersion|.
        1. [=list/For each=] |entry| in |entriesToBatch|:
          1. Set |entry|'s [=trusted scoring signals request/reply=] to |result|.
    1. Otherwise:
      1. Select a non-[=list/is empty|empty=] [=set/subset=] of |batcher|'s [=trusted scoring
        signals batcher/request map=][|key|], called |entriesToBatch|.
      1. [=map/Remove=] |key| from |batcher|'s [=trusted scoring signals batcher/request map=].
      1. Let « |requestBody|, |renderUrlIdMap|, |context| » be the result of [=building batched
        trusted key value scoring signals request body=] for |entriesToBatch|.
      1. Let |baseUrl| be |entriesToBatch|[0]'s [=trusted scoring signals request/base url=].
      1. Let |seller| be |entriesToBatch|[0]'s [=trusted scoring signals request/seller=].
      1. Let |scriptFetcher| be |entriesToBatch|[0]'s [=trusted scoring signals request/seller
        script fetcher=].
      1. If |baseUrl|'s [=url/origin=] is not [=same origin=] with |seller| then:
        1. Let |allowCrossOriginTrustedScoringSignalsFrom| be the result of [=wait for cross origin
          trusted scoring signals authorization from a fetcher=] given |scriptFetcher|.
        1. If |allowCrossOriginTrustedScoringSignalsFrom| does not [=list/contain=]
          |baseUrl|'s [=url/origin=], set |baseUrl| to null.
      1. Let |allTrustedScoringSignals| be failure.
      1. If |baseUrl| and |requestBody| are not null, let «|allTrustedScoringSignals|, <var ignore>ignored</var>,
        |scoringDataVersionMap|» be the result of [=fetching trusted key value signals=] with |baseUrl|, |requestBody|,
        |context|, |seller|, |entriesToBatch|[0]'s [=trusted scoring signals request/policy container=], |renderUrlIdMap|
        and false.
      1. If |allTrustedScoringSignals| is an [=ordered map=]:
        1. [=list/For each=] |entry| in |entriesToBatch|:
          1. Let |result| be a new [=trusted scoring signals reply=].
          1. Set |result|'s [=trusted scoring signals reply/all trusted scoring signals=] to
            |allTrustedScoringSignals|.
          1. If |scoringDataVersionMap| is not null:
            1. Let |renderURL| be |entry|'s [=trusted scoring signals request/ad=]'s
              [=creative info/ad descriptor=]'s [=ad descriptor/url=].
            1. Set |result|'s [=trusted scoring signals reply/data version=] to
              |scoringDataVersionMap|[[=URL serializer|serialized=] |renderURL|].
          1. Set |entry|'s [=trusted scoring signals request/reply=] to |result|.
      1. Otherwise, [=list/for each=] |entry| in |entriesToBatch|:
        1. Set |entry|'s [=trusted scoring signals request/reply=] to failure.

</div>

<h3 id=generated-bid-header>Generated bid</h3>

A <dfn>generated bid</dfn> is a bid that needs to be scored by the seller. The bid is either the
result of [=evaluating a bidding script=], or an [=additional bid=] provided by the
[:Ad-Auction-Additional-Bid:] response headers. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="generated bid">
  : <dfn>reporting id</dfn>
  :: A [=reporting bid key=] or null, initially null. Used to identify a [=generated bid=].
  : <dfn>for k-anon auction</dfn>
  :: A [=boolean=], initially true. If this is false, the bid is only used to determine the hypothetical
    winner with no k-anonymity constraints, which would be used to [=update k-anonymity counts=] only.
  : <dfn>bid</dfn>
  :: A [=bid with currency=], or null. If not null and the [=bid with currency/value=] is zero or negative, then this
    [=interest group=] will not participate in the auction. This field should only
    be null if the top-level auction is performed on a trusted auction server.
  : <dfn>bid in seller currency</dfn>
  :: A {{double}} or null. An equivalent of the original bid in seller's currency. This is either
    the original bid if the currency already matched, or a conversion provided by `scoreAd()`.
  : <dfn>ad</dfn>
  :: A [=string=]. JSON string to be passed to the scoring function.

    Issue: TODO: Check whether [=generated bid/ad descriptor=] can be moved to
    [=generated bid/bid ad=] to avoid duplication
    (<a href="https://github.com/WICG/turtledove/issues/868">WICG/turtledove#868</a>).
  : <dfn>ad descriptor</dfn>
  :: An [=ad descriptor=]. Render URL and size of the bid's ad.
  : <dfn>ad component descriptors</dfn>
  :: Null or a [=list=] of [=ad descriptors=]. Ad components associated with bid, if any.
    Will be limited to at most 40 [=list/items=] (and if {{GenerateBidOutput/targetNumAdComponents}}
    was specified, it will have exactly that many [=list/items=]) by the time the bid participates
    in the auction. Must be null if the interest group making this bid has a null
    [=interest group/ad components=] field.
  : <dfn>selected buyer and seller reporting ID</dfn>
  :: Null or [=string=]. The selected reporting id from the
    [=interest group ad/selectable buyer and seller reporting IDs=] within the
    [=generated bid/interest group=]. If present, this will be:
      * Passed alongside [=interest group ad/buyer reporting ID=] and
        [=interest group ad/buyer and seller reporting ID=] to [=report win=]
        subject to [=k-anonymity=] checks.
      * Passed alongside [=interest group ad/buyer and seller reporting ID=]
        to [=report result=] subject to [=k-anonymity=] checks.
      * Passed alongside [=interest group ad/buyer and seller reporting ID=]
        to `scoreAd()`.
  : <dfn>ad cost</dfn>
  :: Null or a {{double}}. Advertiser click or conversion cost passed from `generateBid()` to
    `reportWin()`. Negative values will be ignored and not passed. Will be
    [=round a value|stochastically rounded=] when passed.
  : <dfn>modeling signals</dfn>
  :: Null or an {{unsigned short}}. A 0-4095 integer (12-bits) passed to `reportWin()`, with noising.
  : <dfn>interest group</dfn>
  :: An [=interest group=], whose `generateBid()` invocation generated this bid, or specified by the
    additional bid.
  : <dfn>bid ad</dfn>
  :: The [=interest group ad=] within [=generated bid/interest group=] to display.
  : <dfn>bid ad components</dfn>
  :: A [=list=] of [=interest group ad=] ad components within [=generated bid/interest group=] to
    display.
  : <dfn>modified bid</dfn>
  :: Null or a [=bid with currency=]. Being null for top level auction.
    The bid value a component auction's `scoreAd()` script returns.
  : <dfn>bid duration</dfn>
  :: A [=duration=] in milliseconds. How long it took to run `generateBid()`.
  : <dfn>provided as additional bid</dfn>
  :: A [=boolean=], initially false.
  : <dfn>component seller</dfn>
  :: Null or an [=origin=]. Seller in component auction which the [=generated bid/interest group=]
    is participating. Only set for component auctions, null otherwise.
  : <dfn>target number of ad components</dfn>
  :: Null or {{unsigned long}}, initially null. Set if the bidder requested
    [=generated bid/ad component descriptors=] they provided to be reduced to the given target,
    taking in account k-anonymity.
  : <dfn>number of mandatory ad components</dfn>
  :: {{unsigned long}}. Only relevant if [=generated bid/target number of ad components=] is set.
     Requires the first that many given ad components to be included.
</dl>

<div algorithm>

To <dfn>apply any component ads target to a bid</dfn>, given a [=generated bid=] |generatedBid|:
1. If |generatedBid|'s [=generated bid/target number of ad components=] is null, return.
1. [=Assert=] that |generatedBid|'s [=generated bid/ad component descriptors=] is not null.
1. While |generatedBid|'s [=generated bid/ad component descriptors=]'s [=list/size=] &gt;
    [=generated bid/target number of ad components=]:
    1. [=list/Remove=] the last value from |generatedBid|'s [=generated bid/ad component descriptors=].

</div>

<div algorithm>

To <dfn>try to reach component ads target considering k-anonymity</dfn>, given a [=generated bid=] |generatedBid|:
1. If |generatedBid|'s [=generated bid/target number of ad components=] is null, return false.
1. Let |selectedComponents| be a new [=list=] of [=ad descriptors=].
1. [=set/For each=] |i| of [=list/get the indices=] of |generatedBid|:
  1. Let |candidateComponent| be |generatedBid|'s [=generated bid/ad component descriptors=][|i|].
  1. Compute |componentAdHashCode| by getting the result of [=compute the key hash of component ad=] given |candidateComponent|'s [=interest group ad/render url=].
  1. If [=query k-anonymity cache=] given |componentAdHashCode| returns true:
    1. [=list/Append=] |candidateComponent| to |selectedComponents|.
  1. Otherwise:
    1. If |i| &lt; |generatedBid|'s [=generated bid/number of mandatory ad components=], return false.
1. If |selectedComponents|'s [=list/size=] &lt; |generatedBid|'s [=generated bid/target number of ad components=],
   return false.
1. Set |generatedBid|'s [=generated bid/ad component descriptors=] to |selectedComponents|.
1. [=Apply any component ads target to a bid=] given |generatedBid|.
1. Return [=query generated bid k-anonymity count=] given |generatedBid|.

</div>

<div algorithm>

To <dfn>adjust bid list based on k-anonymity</dfn> given a [=list=] of [=generated bids=] |bidsBatch|:
1. Let |bidsToScore| be a new [=list=] of [=generated bids=]
1. [=list/For each=] |generatedBid| of |bidsBatch|:
  1. Let |bidCopy| be a clone of |generatedBid|.
  1. Set |bidCopy|'s [=generated bid/for k-anon auction=] to false.
  1. [=Apply any component ads target to a bid=] given |bidCopy|.
  1. [=list/Append=] |bidCopy| to |bidsToScore|
  1. Let |selectedReportingId| be a [=string=]-or-null that is set to null.
  1. If |generatedBid|'s [=generated bid/selected buyer and seller reporting ID=] is not null, set
    |selectedReportingId| to it.
  1. Let |igAd| be the [=interest group ad=] from |generatedBid|'s [=generated bid/interest group=]'s
    [=interest group/ads=] whose [=interest group ad/render url=] is |generatedBid|'s
    [=generated bid/ad descriptor=]'s [=ad descriptor/url=].
  1. Let |isBidKAnon| be the result of [=query generated bid k-anonymity count=] given |generatedBid|.
  1. If |isBidKAnon| is true and running [=query reporting ID k-anonymity count=] with |generatedBid|'s
    [=generated bid/interest group=], |igAd|, |selectedReportingId| is true:
    1. [=list/Append=] |generatedBid| to |bidsToScore|.

    Note: Conceptually, a bid that's already k-anonymous is considered for both the k-anonymous and
    non-enforcing-k-anonymity leadership, which is represented here in the specification by two
    separate [=generated bid=] objects that get scored independently. An implementation does not,
    however, actually need to perform the relevant work twice.

  1. Otherwise, if the result of applying [=try to reach component ads target considering k-anonymity=]
     given |generatedBid| is true:
    1. [=list/Append=] |generatedBid| to |bidsToScore|.
1. Return |bidsToScore|.

</div>

A <dfn>bid debug reporting info</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="bid debug reporting info">
  : <dfn>component seller</dfn>
  ::  Null or an [=origin=]. Seller in component auction which was running to produce
    this reporting information. Only set for component auctions, null otherwise.
  : <dfn>interest group owner</dfn>
  :: An [=origin=]. Matches [=interest group/owner=] of the interest group that was
     used to call `generateBid()` to produce this reporting information.

  : <dfn>bidder debug win report url</dfn>
  :: Null or a [=URL=], initially null. Set by `generateBid()`'s
    {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}}'s
    {{ForDebuggingOnly/reportAdAuctionWin(url)}}.
  : <dfn>bidder debug loss report url</dfn>
  :: Null or a [=URL=], initially null. Set by `generateBid()`'s
    {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}}'s
    {{ForDebuggingOnly/reportAdAuctionLoss(url)}}.
  : <dfn>seller debug win report url</dfn>
  :: Null or a [=URL=], initially null. In the case of a component auction, these are the values
    from component seller that the scored ad was created in. Set by `scoreAd()`'s
    {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}}'s
    {{ForDebuggingOnly/reportAdAuctionWin(url)}}.
  : <dfn>seller debug loss report url</dfn>
  :: Null or a [=URL=], initially null. In the case of a component auction, these are the values
    from component seller that the scored ad was created in. Set by `scoreAd()`'s
    {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}}'s
    {{ForDebuggingOnly/reportAdAuctionLoss(url)}}.
  : <dfn>top level seller debug win report url</dfn>
  :: Null or a [=URL=], initially null. Set in the case this bid was made in a component auction,
    won it, and was then scored by the top-level seller. Set by top-level seller's `scoreAd()`'s
    {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}}'s
    {{ForDebuggingOnly/reportAdAuctionWin(url)}}.
  : <dfn>top level seller debug loss report url</dfn>
  :: Null or a [=URL=], initially null. Set in the case this bid was made in a component auction,
    won it, and was then scored by the top-level seller. Set by top-level seller's `scoreAd()`'s
    {{InterestGroupBiddingAndScoringScriptRunnerGlobalScope/forDebuggingOnly}}'s
    {{ForDebuggingOnly/reportAdAuctionLoss(url)}}.
  : <dfn>server filtered debugging only reports</dfn>
  :: A [=map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are [=lists=] of [=urls=].
    forDebuggingOnly reports that have been filtered (also downsampled) by the trusted auction server.
</dl>

A <dfn>bid with currency</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="bid with currency">
  : <dfn>value</dfn>
  :: A {{double}}. The value of the bid.
  : <dfn>currency</dfn>
  :: A [=currency tag=]. The currency the bid is in.
</dl>

An <dfn>ad descriptor</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="ad descriptor">
  : <dfn>url</dfn>
  :: A [=URL=], which will be rendered to display the [=ad creative=] if this bid wins the auction.
  : <dfn>size</dfn>
  :: Null or an [=ad size=], initially null.
</dl>

An <dfn>ad size</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="ad size">
  : <dfn>width</dfn>
  :: A {{double}}.
  : <dfn>width units</dfn>
  :: A [=string=]. Can only be one of "px" (pixel), "sh" (screen height), and "sw" (screen width).
  : <dfn>height</dfn>
  :: A {{double}}.
  : <dfn>height units</dfn>
  :: A [=string=]. Can only be one of "px" (pixel), "sh" (screen height), and "sw" (screen width).
</dl>

<div algorithm>
  To <dfn>parse an AdRender ad size</dfn> given an object |adSlotSize|:

  1. If either |adSlotSize|["height"] or |adSlotSize|["width"] does not [=map/exist=], return null.
  1. Let |width| and |widthUnit| be the dimension and dimension unit that results from running
    [=parse an AdRender dimension value=] with |adSlotSize|["width"], respectively.
  1. If |width| is null, return null.
  1. Let |height| and |heightUnit| be the dimension and dimension unit that results from running
    [=parse an AdRender dimension value=] with |adSlotSize|["height"], respectively.
  1. If |height| is null, return null.
  1. Let |adSize| be a new [=ad size=].
  1. Set |adSize|'s [=ad size/width=] to |width|, [=ad size/width units=] to |widthUnit|,
    [=ad size/height=] to |height|, [=ad size/height units=] to |heightUnit|.
  1. Return |adSize|.
</div>

An <dfn>ad keyword replacement</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="ad keyword replacement">
  : <dfn>match</dfn>
  :: A [=string=], represents the match within a {{AuctionAd/renderURL}}, that is going to be
    replaced by [=ad keyword replacement/replacement=]. Must be in the format `${...}` or
    `%%...%%`.
  : <dfn>replacement</dfn>
  :: A [=string=], meant to replace [=ad keyword replacement/match=] within a
    {{AuctionAd/renderURL}}.
</dl>

<h3 id=direct-from-seller-signals-section>Direct from seller signals</h3>

A <dfn>direct from seller signals key</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="direct from seller signals key">
  : <dfn>seller</dfn>
  :: An [=origin=]. Matches the origin that served the captured [:Ad-Auction-Signals:] header.
  : <dfn>ad slot</dfn>
  :: A [=string=]. Matches the `adSlot` key of the JSON dictionaries in the top-level array of the
    [:Ad-Auction-Signals:] value.
</dl>

A <dfn>direct from seller signals</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="direct from seller signals">
  : <dfn>auction signals</dfn>
  :: Null or a [=string=].
    Opaque JSON data passed to both buyers' and the seller's [=script runners=].
  : <dfn>seller signals</dfn>
  :: Null or a [=string=].
    Opaque JSON data passed to the seller's [=script runner=].
  : <dfn>per buyer signals</dfn>
  :: A [=map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are [=strings=].
    [=map/Keys=] are buyers whose [=origin/scheme=] must be "`https`". [=map/Values=] are opaque
    JSON data passed to corresponding buyer's [=script runner=].
</dl>

<h3 id=additional-bids-structs-section>Additional bids</h3>

A <dfn>signed additional bid with metadata</dfn> is a [=struct=] with the following
[=struct/items=]:

<dl dfn-for="signed additional bid with metadata">
  : <dfn>signed additional bid</dfn>
  :: A [=string=] for an encoded additional bid.
  : <dfn>seller nonce</dfn>
  :: Null or a [=string=]. If present, represents the randomly-generated seller nonce returned in
    the [:Ad-Auction-Additional-Bid:] response header. This must be 36 characters, and should be the
    canonoical [=string=] representation of a [=version 4 UUID=].
</dl>

<h3 id=score-ad-output-header>Score ad output</h3>

The output of running a Protected Audience `scoreAd()` script, is represented using the following type:
<pre class="idl">
dictionary ScoreAdOutput {
  required double desirability;
  double bid;
  DOMString bidCurrency;
  double incomingBidInSellerCurrency;
  boolean allowComponentAuction = false;
};
</pre>
Either a dictionary of this type, or a {{double}}, are handled as the return values.

The meanings of the fields are as follows:
<dl class=domintro>
  <dt>{{ScoreAdOutput/desirability}}
  <dd>Numeric score of the bid. Must be positive or the ad will be rejected. The winner of the auction
  is the bid which was given the highest score.
  <dt>{{ScoreAdOutput/bid}}
  <dd>Only relevant if this is a component auction.  If present, this will be passed to the top-level
  seller's `scoreAd()` and `reportResult()` methods instead of the original bid, if the ad wins the
  component auction and top-level auction, respectively.
  <dt>{{ScoreAdOutput/bidCurrency}}
  <dd>Only relevant if this is a component auction and {{ScoreAdOutput/bid}} is set. Specifies which
  currency the {{ScoreAdOutput/bid}} field is in.
  <dt>{{ScoreAdOutput/incomingBidInSellerCurrency}}
  <dd>Provides a conversion of the incoming bid to auction's seller currency. This is different from
  {{ScoreAdOutput/bid}} which is the bid the component auction itself produces.
  <dt>{{ScoreAdOutput/allowComponentAuction}}
  <dd>If the bid being scored is from a component auction and this value is not true, the bid is
  ignored. This field must be present and true both when the component seller scores a bid, and when
  that bid is being scored by the top-level auction.
</dl>

TODO: This also has an ad field, which should behave similar to the way {{ScoreAdOutput/bid}}
affects [=generated bid/modified bid=], and then affecting the adMetadata parameter to scoreAd.

<div algorithm>
To <dfn>process scoreAd output</dfn> given an [=ECMAScript/Completion Record=] |result|:

  1. If |result| is an an [=ECMAScript/abrupt completion=], return failure.
  1. If |result|.\[[Value]] is a [=Number=]:
    1. Let |checkedScore| be the result of [=converted to an IDL value|converting=]
      |result|.\[[Value]] to a {{double}}.
    1. If an exception was [=exception/thrown=] in the previous step, return failure.
    1. Let |resultIDL| be a new {{ScoreAdOutput}}.
    1. Set |resultIDL|'s {{ScoreAdOutput/desirability}} to |checkedScore|.
    1. Return |resultIDL|.
  1. Let |resultIDL| be the result of [=converted to an IDL value|converting=]
          |result|.\[[Value]] to a {{ScoreAdOutput}}.
  1. If an exception was [=exception/thrown=] in the previous step, return failure.
  1. If |resultIDL|["{{ScoreAdOutput/bidCurrency}}"] [=map/exists=] and result of
    [=checking whether a string is a valid currency tag=] applied to
    |resultIDL|["{{ScoreAdOutput/bidCurrency}}"] is false, then return failure.
  1. Return |resultIDL|.
</div>

<h3 id=leading-bid-info-header>Leading bid info</h3>

A <dfn>leading bid info</dfn> is the information of the auction's leading bid so far when ranking
scored bids. It's a [=struct=] with the following [=struct/items=]:

<dl dfn-for="leading bid info">
  : <dfn>top score</dfn>
  :: A {{double}}, initially 0.0. The highest score so far.
  : <dfn>top non-k-anon-enforced score</dfn>
  :: A {{double}}, initially 0.0. The highest score so far when disregarding k-anonymity.
  : <dfn>top bids count</dfn>
  :: An integer, initially 0. The number of bids with the same `top score`.
  : <dfn>top non-k-anon-enforced bids count</dfn>
  :: Number of bids that are tied for leadership when disregarding k-anonymity thus far.
  : <dfn>at most one top bid owner</dfn>
  :: A [=boolean=], initially true. Whether all bids of `top score` are from the same interest
    group owner.
  : <dfn>leading bid</dfn>
  :: Null or a [=generated bid=], initially null. The leading bid of the auction so far.
  : <dfn>leading non-k-anon-enforced bid</dfn>
  :: Null or a [=generated bid=], initially null. The leading bid of the auction disregarding k-anonymity so far.
  : <dfn>auction config</dfn>
  :: An [=auction config=]. The auction config of the auction which generated this
    [=leading bid info/leading bid=].
  : <dfn>second highest score</dfn>
  :: A {{double}}, initially 0.0. The second highest score so far. If more than one bids tie with
    `top score`, this will be set to `top score`.
  : <dfn>highest scoring other bids count</dfn>
  :: An integer, initially 0. The number of bids with the same `second highest score`.
  : <dfn>highest scoring other bid</dfn>
  :: Null or a [=generated bid=]. The second highest scoring other bid.
  : <dfn>highest scoring other bid owner</dfn>
  :: Null or an [=origin=], initially null. The interest group owner that made bids with the
    `second highest score`. Set to null if there are more than one owners made bids with the
    `second highest score`.
  : <dfn>top level seller</dfn>
  :: Null or an [=origin=]. The seller in the top level auction. Only set for component auctions,
    null otherwise.
  : <dfn>top level seller signals</dfn>
  :: Null or a [=string=]. Signals from the seller in the top level auction, produced as the output
    of the top-level seller's `reportResult()` method. Only set for component auctions, null
    otherwise.
  : <dfn>component seller</dfn>
  :: Null or an [=origin=]. Seller in component auction which generated this
    [=leading bid info/leading bid=]. Only set for the top level auction when component auctions are
    present, null otherwise.
  : <dfn>bidding data version</dfn>
  :: Null or an {{unsigned long}}.
    Data-Version value from the trusted bidding signals server's response(s). Will only be not null
    if the [:Data-Version:] header was provided and had a consistent value for all of the trusted
    bidding signals server responses used to construct the trustedBiddingSignals.
  : <dfn>scoring data version</dfn>
  :: Null or an {{unsigned long}}.
    Data-Version value from the trusted scoring signals server's response. Will only be not null if
    the [:Data-Version:] header was provided in the response headers from the trusted scoring
    signals server.
  : <dfn>buyer reporting result</dfn>
  :: Null or a [=reporting result=], initially null.
  : <dfn>seller reporting result</dfn>
  :: Null or a [=reporting result=], initially null.
  : <dfn>component seller reporting result</dfn>
  :: Null or a [=reporting result=], initially null.
</dl>

A <dfn>reporting result</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="reporting result">
  : <dfn>report url</dfn>
  :: Null or a [=URL=], initially null. Set by
     {{InterestGroupReportingScriptRunnerGlobalScope/sendReportTo(url)}}.

  : <dfn>reporting beacon map</dfn>
  :: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
     [=URLs=], initially null. Set by
     {{InterestGroupReportingScriptRunnerGlobalScope/registerAdBeacon(map)}}.

  : <dfn>reporting macro map</dfn>
  :: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
     [=strings=], initially null. Set by
     {{InterestGroupReportingScriptRunnerGlobalScope/registerAdMacro(name, value)}}.
</dl>

An <dfn>auction report info</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="auction report info">
  : <dfn>debug win report urls</dfn>
  :: A [=list=] of [=URLs=] whose [=url/schemes=] must be "`https`". The winning bid's
    [=generated bid=]'s debug win report URLs.
  : <dfn>debug loss report urls</dfn>
  :: A [=list=] of [=strings=] whose [=url/schemes=] must be "`https`". Losing bid's
    [=generated bid=]'s debug loss report URLs.

    Issue: TODO:  Change the two lists to a single URL since no more than one debug reports can be
    sent after [downsampling debug reports](#downsampling-header). While the browser is
    experimenting with third party cookie deprecation (before they have been fully removed), the
    `forDebuggingOnly` reporting APIs are not downsampled, so they are still lists.

  : <dfn>real time reporting contributions map</dfn>
  :: A [=real time reporting contributions map=]
</dl>

A <dfn>real time reporting contributions map</dfn> is an [=ordered map=] whose [=map/keys=] are
[=origins=] and whose [=map/values=] are [=lists=] of [=real time reporting contributions=].

A <dfn>real time reporting contribution</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="real time reporting contribution">
  : <dfn>bucket</dfn>
  :: A {{long}}. Must be greater than 0 and less than the sum of [=number of user buckets=] and
    [=number of platform buckets=].
  : <dfn>priority weight</dfn>
  :: A {{double}}. Must be greater than 0 and less than infinity, dictates the relative likelihood
    of which bucket will get the contribution.
  : <dfn>latency threshold</dfn>
  :: Null or a [=duration=] in milliseconds. Initially null.
    Reports when a latency (e.g., `generateBid()` execution latency) is greater than this threshold.
</dl>

<h3 id=k-anonymity-records>K-Anonymity Records</h3>
A <dfn>k-anonymity key</dfn> is a [=string=] used as a key for tracking k-anonymity status.

A <dfn>k-anonymity record</dfn> is a timestamped cache of the k-anonymity status
for a given [=k-anonymity key=]. These records are stored in the [=user agent=].

<dl dfn-for="k-anonymity record">
  : <dfn>is k-anonymous</dfn>
  :: A {{boolean}} indicating whether the [=k-anonymity key=] indicated by this record was reported as k-anonymous.
  : <dfn>timestamp</dfn>
  :: The [=moment=] when the k-anonymity status in this record was last fetched.
</dl>

<h3 id=auction-data-config-header>auction data config</h3>

An <dfn>auction data config</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="auction data config">
  :  <dfn>publisher</dfn>
  ::  An [=origin=].
    The origin of the top level page running the ad auction. The
    [=origin/scheme=] must be "`https`".
  :  <dfn>seller</dfn>
  :: An [=origin=].
    The origin of the seller running the ad auction. The [=origin/scheme=] must be "`https`".
  :  <dfn>coordinator</dfn>
  :: The origin of the coordinator hosting public encryption keys for the server
    running the ad auction. The [=origin/scheme=] must be "`https`".
  :  <dfn>encryption key</dfn>
  :: Null or a [=byte sequence=]. The public [[RFC9180|HPKE]] encryption key to be used
     to encrypt the request.
  : <dfn>encryption key id</dfn>
  :: Null or a [=byte=] containing the key ID corresponding to the [=auction data config/encryption key=].
  :  <dfn>request size</dfn>
  :: {{unsigned long}} or null. An optional field, containing the desired size
    for the returned encrypted request blob.
  :  <dfn>per buyer config</dfn>
  :: A [=map=] whose [=map/keys=] are [=origins=] and [=map/values=] are [=auction data buyer config=].
</dl>

An <dfn>auction data per seller result</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="auction data per seller result">
  :  <dfn>seller</dfn>
  :: The [=origin=] of the seller that this result corresponds to. Will match one of the provided
     [=auction data configs=]'s [=auction data config/seller=].
  :  <dfn>request</dfn>
  :: Null or a [=byte sequence=]. The encrypted request generated for this
     [=auction data per seller result/seller=]. Null indicates an error occured and
     the [=auction data per seller result/error=] field will contain additional information.
  :  <dfn>error</dfn>
  :: Null or a [=string=]. Null when the request succeeds. Otherwise contains
     additional information about the failure.
</dl>

An <dfn>auction data buyer config</dfn> is a [=struct=] with the following [=struct/items=]:
<dl dfn-for="auction data buyer config">
  :  <dfn>size</dfn>
  :: {{unsigned long}} or null. An optional field, initially null, containing the
    size of the request to allocate to this buyer.
</dl>

<h3 id=cumul-timeout-tracker>Cumulative timeout tracker</h3>

A <dfn>cumulative timeout tracker</dfn> is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="cumulative timeout tracker">
  : <dfn>remaining</dfn>
  :: A [=duration=] in milliseconds or null. When non-null, records how much of the timeout
    remains to be consumed. When null, states there is no limit. Initially null.
  : <dfn>limit</dfn>
  :: A [=duration=] in milliseconds, or null (reprensenting no limit).
</dl>

<div algorithm>
To <dfn>create a cumulative timeout tracker</dfn> given an [=auction config=] |auctionConfig|
and an [=origin=] |buyer|:
1. Let |tracker| be a new [=cumulative timeout tracker=].
1. Set |tracker|'s [=cumulative timeout tracker/limit=] to |auctionConfig|'s
    [=auction config/all buyers cumulative timeout=].
1. If |auctionConfig|'s [=auction config/per buyer cumulative timeouts=] is not null and
  [=auction config/per buyer cumulative timeouts=] [=map/contains=] |buyer|, then set
  |tracker|'s [=cumulative timeout tracker/limit=] to |auctionConfig|'s [=auction config/per
  buyer cumulative timeouts=][|buyer|].
1. Set |tracker|'s [=cumulative timeout tracker/remaining=] to |tracker|'s [=cumulative timeout
  tracker/limit=].
1. Return |tracker|.

</div>

<div algorithm>
To <dfn>expend cumulative timeout time</dfn> given a [=cumulative timeout tracker=]
|tracker| and a [=duration=] in milliseconds |timeUsed|:
1. If |tracker|'s [=cumulative timeout tracker/remaining=] is null, return.
1. Decrement |tracker|'s [=cumulative timeout tracker/remaining=] by |timeUsed|.

</div>


<div algorithm>
To <dfn>compute effective timeout</dfn> given a [=cumulative timeout tracker=] |tracker| and a
[=duration=] in milliseconds |perBuyerTimeout|:
1. If |tracker|'s [=cumulative timeout tracker/remaining=] is null, return |perBuyerTimeout|.
1. If |perBuyerTimeout| &lt; |tracker|'s [=cumulative timeout tracker/remaining=], return
  |perBuyerTimeout|.
1. Return |tracker|'s [=cumulative timeout tracker/remaining=].

</div>

<div algorithm>
The <dfn for="cumulative timeout tracker">is expired</dfn> of a [=cumulative timeout tracker=]
|tracker| is:
1. False if |tracker|'s [=cumulative timeout tracker/remaining=] is null or positive.
1. True otherwise, that is, if |tracker|'s [=cumulative timeout tracker/remaining=] &leq; 0.

</div>

# Privacy Considerations # {#privacy-considerations}

Protected Audience aims to advance the privacy of remarketing and custom audience
advertising on the web, so naturally privacy considerations are paramount to Protected Audience's
design.  Partitioning data by site is the central mechanism to prevent joining a user's identity
across sites:
- Interest group definitions come from just one site, the site that called
  {{Navigator/joinAdInterestGroup()}}.
- Bidding (`generateBid()`) and scoring (`scoreAd()`) scripts are exposed to interest group data
  from the joining site, and data from the site that will display the ad, but these scripts are run
  in strict isolation to prevent leaking this cross-site information.
- The browser can enforce that trusted bidding and scoring signals are fetched from servers
  complying with certain privacy requirements, e.g. not performing event-level logging.
- Ads are rendered in <{fencedframe}>s that isolate them from the surrounding page to prevent
  cross-site leakage.
- Reporting is strictly controlled by the browser to prevent cross-site leaks:  Inputs to
  event-level reporting functions, `reportWin()` and `reportResult()`, only contain limited
  cross-site information, e.g. the k-anonymous ad URL.  Event-level reporting is meant to be a
  temporary stepping stone to more private mechanisms like [Private Aggregation
  API](https://github.com/patcg-individual-drafts/private-aggregation-api).
- If [[#interest-group-updates]] are allowed to run after navigating to another page, the source IP
  address used for those requests can continue to reveal coarse location information about the
  device. Implementations may wish to implement some form of IP privacy, like a proxy, or limit how
  long updates can run post-navigation.


# Security Considerations # {#security-considerations}

Protected Audience involves the browser running untrusted JavaScript downloaded from multiple
parties, so security concerns are top of mind. Fortunately Protected Audience is a highly
constrained API not attempting to be a general purpose execution environment. Execution of this
JavaScript is controlled and limited as follows:
- Protected Audience requires the origin of the scripts' URLs to match that of the origin of the
  interest group owner, which is in turn required to match the origin of the context calling the
  {{Navigator/joinAdInterestGroup()}}.
- URL schemes are required to be HTTPS.
- Redirects are disallowed.
- Responses are required to contain the `Ad-Auction-Allowed: ?1` header.
- Fetches are uncredentialed.

Protected Audience has the browser pass in several “browserSignals” to the bidding script that give
the script unforgeable information about the context that the script is being executed in. This way
bidders and sellers have the choice to only participate in auctions where they are comfortable
working with the involved parties.

The [execution environment](#script-runners) available to these scripts is the absolute minimum
necessary to calculate a bid. It supports only ECMAScript. It does not support network, storage,
timer, date, DOM, Workers, postMessage, Navigator or Window APIs.

Protected Audience adds Permission-Policies to control access to the Protected Audience APIs to
give sites and embedders the ability to clamp down on use of the APIs as they see fit.

Auction config and interest group data are processed as JSON and not via the [=structured clone
algorithm=], in part because interest groups are updated via JSON server responses. However, there
is also a security reason to not use the structured clone algorithm, which is that the data may
be shared with other parties -- in particular, the auction config
{{AuctionAdConfig/perBuyerSignals}} are sent from the seller to each buyer. Supporting structured
cloning here would mean that buyer scripts would have to be prepared to handle arbitrary, complex,
and potentially cyclic objects from the seller.
