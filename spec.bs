<pre class="metadata">
Title: Protected Audience (formerly FLEDGE)
Shortname: protected-audience
Repository: WICG/turtledove
Inline Github Issues: true
Group: WICG
Status: CG-DRAFT
Level: 1
URL: https://wicg.github.io/turtledove/
Boilerplate: omit conformance, omit feedback-header
Editor: Paul Jensen, Google https://www.google.com/, pauljensen@google.com
Abstract: Provides a privacy advancing API to facilitate interest group based advertising.
!Participate: <a href="https://github.com/WICG/turtledove">GitHub WICG/turtledove</a> (<a href="https://github.com/WICG/turtledove/issues/new">new issue</a>, <a href="https://github.com/WICG/turtledove/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/turtledove/commits/main/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
Assume Explicit For: yes
</pre>

<pre class="anchors">
urlPrefix: https://www.ietf.org/rfc/rfc4122.txt
  type: dfn; text: urn uuid
spec: RFC6234; urlPrefix: https://www.ietf.org/rfc/rfc6234.txt
  type: dfn; text: SHA-256
spec: html; urlPrefix: https://html.spec.whatwg.org/C
  type: dfn
    text: create an agent; url: create-an-agent
    text: immediately; url: immediately
spec: RFC8941; urlPrefix: https://httpwg.org/specs/rfc8941.html
  type: dfn
    text: structured header; url: top
    for: structured header
      text: integer; url: integer
spec: WebAssembly; urlPrefix: https://webassembly.github.io/spec/core/
  type: dfn
    urlPrefix: appendix/embedding.html
      text: error; url: embed-error
spec: WebAssembly-js-api; urlPrefix: https://webassembly.github.io/spec/js-api/
  type: dfn
    text: compiling a WebAssembly module; url: #compile-a-webassembly-module
spec: Fenced Frame; urlPrefix: https://wicg.github.io/fenced-frame/
  type: dfn
    for: browsing context
      text: fenced frame config instance; url: #browsing-context-fenced-frame-config-instance
</pre>

<style>
/* domintro from https://resources.whatwg.org/standard.css */
.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

.domintro dt, .domintro dt * {
  color: black;
  font-size: inherit;
}
.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
.domintro dd p {
  margin: 0.5em 0;
}
.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}
</style>

# Introduction # {#intro}

<em>This section is non-normative</em>

The Protected Audience API facilitates selecting an advertisement to display to a user based on a
previous interaction with the advertiser or advertising network.

When a user's interactions with an advertiser indicate an interest in something, the advertiser can
ask the browser to record this interest on-device by calling
{{Window/navigator}}.{{Navigator/joinAdInterestGroup()}}. Later, when a website wants to select an
advertisement to show to the user, the website can call
{{Window/navigator}}.{{Navigator/runAdAuction()}} to ask the browser to conduct an auction where
each of these on-device recorded interests are given the chance to calculate a bid to display their
advertisement.


<h2 id="joining-interest-groups">Joining Interest Groups</h2>

When a user's interactions with a website indicate that the user may have a particular interest, an
advertiser or someone working on behalf of the advertiser (e.g. a demand side platform, DSP) can ask
the user's browser to record this interest on-device by calling
{{Window/navigator}}.{{Navigator/joinAdInterestGroup()}}. This indicates an intent to display an
advertisement relevant to this interest to this user in the future. The user agent has an
<dfn>interest group set</dfn>, a [=list=] of [=interest groups=] in which
[=interest group/owner=] / [=interest group/name=] pairs are unique.


<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<undefined> joinAdInterestGroup(AuctionAdInterestGroup group);
};

dictionary AuctionAd {
  required USVString renderURL;
  any metadata;
};

dictionary GenerateBidInterestGroup {
  required USVString owner;
  required USVString name;
  required double lifetimeMs;

  boolean enableBiddingSignalsPrioritization = false;
  record<DOMString, double> priorityVector;

  DOMString executionMode = "compatibility";
  USVString biddingLogicURL;
  USVString biddingWasmHelperURL;
  USVString updateURL;
  USVString trustedBiddingSignalsURL;
  sequence<USVString> trustedBiddingSignalsKeys;
  any userBiddingSignals;
  sequence<AuctionAd> ads;
  sequence<AuctionAd> adComponents;
};

dictionary AuctionAdInterestGroup : GenerateBidInterestGroup {
  double priority = 0.0;
  record<DOMString, double> prioritySignalsOverrides;
};
</xmp>

{{AuctionAdInterestGroup}} is used by {{Window/navigator}}.{{Navigator/joinAdInterestGroup()}}, and
when an interest group is stored to [=interest group set=].
`priority` and `prioritySignalsOverrides` are not passed to `generateBid()` because they can be
modified by `generatedBid()` calls, so could theoretically be used to create a cross-site profile of
a user accessible to `generateBid()` methods, otherwise.

<div algorithm="joinAdInterestGroup()">

The <dfn for=Navigator method>joinAdInterestGroup(|group|)</dfn> method steps are:
<div class="note">

Temporarily, Chromium does not include the <a for="dictionary member"><span class="allow-2119">required</span></a> keyword
for {{GenerateBidInterestGroup/lifetimeMs}}, and instead starts this algorithm with the step

1. If |group|["{{GenerateBidInterestGroup/lifetimeMs}}"] does not [=map/exist=], throw a {{TypeError}}.

This is detectable because it can change the set of fields that are read from the argument when a
{{TypeError}} is eventually thrown, but it will never change whether the call succeeds or fails.

</div>
1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=allowed to use=] the
  "[=join-ad-interest-group=]" [=policy-controlled feature=], then [=exception/throw=] a
  "{{NotAllowedError}}" {{DOMException}}.
1. Let |frameOrigin| be [=this=]'s [=relevant settings object=]'s [=environment settings object/origin=].
1. [=Assert=] that |frameOrigin| is not an [=opaque origin=] and its [=origin/scheme=] is "`https`".
1. Let |interestGroup| be a new [=interest group=].
1. Validate the given |group| and set |interestGroup|'s fields accordingly.
  1. Set |interestGroup|'s [=interest group/expiry=] to the [=current wall time=] plus
    |group|["{{GenerateBidInterestGroup/lifetimeMs}}"] milliseconds.
  1. Set |interestGroup|'s [=interest group/next update after=] to the [=current wall time=] plus 24
    hours.
  1. Set |interestGroup|'s [=interest group/owner=] to the result of [=parsing an origin=] on
    |group|["{{GenerateBidInterestGroup/owner}}"].
  1. If |interestGroup|'s [=interest group/owner=] is failure, or its [=url/scheme=] is not
    "`https`", [=exception/throw=] a {{TypeError}}.
  1. Set |interestGroup|'s [=interest group/name=] to |group|["{{GenerateBidInterestGroup/name}}"].
  1. Set |interestGroup|'s [=interest group/priority=] to
    |group|["{{AuctionAdInterestGroup/priority}}"].
  1. Set |interestGroup|'s [=interest group/enable bidding signals prioritization=] to
    |group|["{{GenerateBidInterestGroup/enableBiddingSignalsPrioritization}}"].
  1. If |group|["{{GenerateBidInterestGroup/priorityVector}}"] [=map/exists=], then set
    |interestGroup|'s [=interest group/priority vector=] to
    |group|["{{GenerateBidInterestGroup/priorityVector}}"].
  1. If |group|["{{AuctionAdInterestGroup/prioritySignalsOverrides}}"] [=map/exists=], then set
    |interestGroup|'s [=interest group/priority signals overrides=] to
    |group|["{{AuctionAdInterestGroup/prioritySignalsOverrides}}"].
  1. Set |interestGroup|'s [=interest group/execution mode=] to
    |group|["{{GenerateBidInterestGroup/executionMode}}"].
  1. For each |groupMember| and |interestGroupField| in the following table
    <table class="data">
      <thead><tr><th>Group member</th><th>Interest group field</th></tr></thead>
      <tr>
        <td>"{{GenerateBidInterestGroup/biddingLogicURL}}"</td>
        <td>[=interest group/bidding url=]</td>
      </tr>
      <tr>
        <td>"{{GenerateBidInterestGroup/biddingWasmHelperURL}}"</td>
        <td>[=interest group/bidding wasm helper url=]</td>
      </tr>
      <tr>
        <td>"{{GenerateBidInterestGroup/updateURL}}"</td>
        <td>[=interest group/update url=]</td>
      </tr>
      <tr>
        <td>"{{GenerateBidInterestGroup/trustedBiddingSignalsURL}}"</td>
        <td>[=interest group/trusted bidding signals url=]</td>
      </tr>
    </table>
    1. If |group| [=map/contains=] |groupMember|:
      1. Let |parsedUrl| be the result of running the [=URL parser=] on |group|[|groupMember|].
      1. [=exception/Throw=] a {{TypeError}} if any of the following conditions hold:
        * |parsedUrl| is failure;
        * |parsedUrl| is not [=same origin=] with |interestGroup|'s [=interest group/owner=];
        * |parsedUrl| [=includes credentials=];
        * |parsedUrl| [=url/fragment=] is not null.
      1. Set |interestGroup|'s |interestGroupField| to |parsedUrl|.
  1. If |interestGroup|'s [=interest group/trusted bidding signals url=]'s [=url/query=] is not
    null, then [=exception/throw=] a {{TypeError}}.
  1. If |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsKeys}}"] [=map/exists=], then set
    |interestGroup|'s [=interest group/trusted bidding signals keys=] to
    |group|["{{GenerateBidInterestGroup/trustedBiddingSignalsKeys}}"].
  1. If |group|["{{GenerateBidInterestGroup/userBiddingSignals}}"] [=map/exists=]:
    1. Set |interestGroup|'s [=interest group/user bidding signals=] to the result of
      [=serializing a JavaScript value to a JSON string=], given
      |group|["{{GenerateBidInterestGroup/userBiddingSignals}}"]. This can [=exception/throw=] a
      {{TypeError}}.
  1. For each |groupMember| and |interestGroupField| in the following table
    <table class="data">
      <thead><tr><th>Group member</th><th>Interest group field</th></tr></thead>
      <tr>
        <td>"{{GenerateBidInterestGroup/ads}}"</td>
        <td>[=interest group/ads=]</td>
      </tr>
      <tr>
        <td>"{{GenerateBidInterestGroup/adComponents}}"</td>
        <td>[=interest group/ad components=]</td>
      </tr>
    </table>
    1. [=list/For each=] |ad| of |group|[|groupMember|]:
      1. Let |igAd| be a new [=interest group ad=].
      1. Let |renderURL| be the result of running the [=URL parser=] on
        |ad|["{{AuctionAd/renderURL}}"].
      1. [=exception/Throw=] a {{TypeError}} if any of the following conditions hold:
        * |renderURL| is failure;
        * |renderURL| [=url/scheme=] is not "`https`";
        * |renderURL| [=includes credentials=].
      1. Set |igAd|'s [=interest group ad/render url=] to |renderURL|.
      1. If |ad|["{{AuctionAd/metadata}}"] [=map/exists=], then let
        |igAd|'s [=interest group ad/metadata=] be the result of
        [=serializing a JavaScript value to a JSON string=], given |ad|["{{AuctionAd/metadata}}"].
        This can [=exception/throw=] a {{TypeError}}.
      1. [=list/Append=] |igAd| to |interestGroup|'s |interestGroupField|.
1. If |interestGroup|'s [=interest group/estimated size=] is greater than 50 KB, then
  [=exception/throw=] a {{TypeError}}.
1. Let |p| be [=a new promise=].
1. Let |queue| be the result of [=starting a new parallel queue=].
1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |queue|:
  1. Let |permission| be the result of [=checking interest group permissions=] with 
    |interestGroup|'s [=interest group/owner=], |frameOrigin|, and true.
  1. If |permission| is false, then [=queue a task=] to [=reject=] |p| with a
     "{{NotAllowedError}}" {{DOMException}} and do not run the remaining steps.
  1. [=Queue a task=] to [=resolve=] |p| with `undefined`.
  1. If the browser is currently storing an interest group with `owner` and `name` that matches
    |interestGroup|, then set the [=interest group/bid counts=],
    [=interest group/join counts=], and [=interest group/previous wins=] of
    |interestGroup| to the values of the currently stored one and remove
    the currently stored one from the browser.
  1. Set |interestGroup|'s [=interest group/joining origin=] to [=this=]'s
    [=relevant settings object=]'s [=environment/top-level origin=].
  1. If the most recent entry in [=interest group/join counts=] corresponds to
    the current day in UTC, increment its count. If not, insert a new entry with
    the time set to the current UTC day and a count of 1.
  1. Store |interestGroup| in the browser’s [=interest group set=].
1. Return |p|.

</div>

<div algorithm>

The <dfn for="interest group">estimated size</dfn> of an [=interest group=] |ig| is the sum of:
1. The [=string/length=] of the [=serialization of an origin|serialization=] of |ig|'s
  [=interest group/owner=].
1. The [=string/length=] of |ig|'s [=interest group/name=].
1. 8 bytes, which is the size of |ig|'s [=interest group/priority=].
1. The [=string/length=] of |ig|'s [=interest group/execution mode=].
1. 2 bytes, which is the size of |ig|'s [=interest group/enable bidding signals prioritization=].
1. If |ig|'s [=interest group/priority vector=] is not null, [=map/for each=] |key| → |value| of
  [=interest group/priority vector=]:
  1. The [=string/length=] of |key|.
  1. 8 bytes, which is the size of |value|.
1. If |ig|'s [=interest group/priority signals overrides=] is not null, [=map/for each=] |key| → |value| of
  [=interest group/priority signals overrides=]:
  1. The [=string/length=] of |key|.
  1. 8 bytes, which is the size of |value|.
1. The size of [=interest group/execution mode=].
1. The [=string/length=] of the [=URL serializer|serialization=] of |ig|'s
  [=interest group/bidding url=], if the field is not null.
1. The [=string/length=] of the [=URL serializer|serialization=] of |ig|'s
  [=interest group/bidding wasm helper url=], if the field is not null.
1. The [=string/length=] of the [=URL serializer|serialization=] of |ig|'s
  [=interest group/update url=], if the field is not null.
1. The [=string/length=] of the [=URL serializer|serialization=] of |ig|'s
  [=interest group/trusted bidding signals url=], if the field is not null.
1. [=list/For each=] |key| of |ig|'s [=interest group/trusted bidding signals keys=]:
  1. The [=string/length=] of |key|.
1. The [=string/length=] of |ig|'s [=interest group/user bidding signals=].
1. If |ig|'s [=interest group/ads=] is not null, [=list/for each=] |ad| of it:
  1. The [=string/length=] of the [=URL serializer|serialization=] of |ad|'s
    [=interest group ad/render url=].
  1. The [=string/length=] of |ad|'s [=interest group ad/metadata=] if the field is not null.
1. If |ig|'s [=interest group/ad components=] is not null, [=list/for each=] |ad| of it:
  1. The [=string/length=] of the [=URL serializer|serialization=] of |ad|'s
    [=interest group ad/render url=].
  1. The [=string/length=] of |ad|'s [=interest group ad/metadata=] if the field is not null.

</div>

<div algorithm>

To <dfn>check interest group permissions</dfn> given an [=origin=]
|ownerOrigin|, an [=origin=] |frameOrigin|, and a [=boolean=] |isJoin|:
1. If |ownerOrigin| is [=same origin=] with |frameOrigin|, then return true.
1. Let |permissionsUrl| be the result of [=building an interest group permissions url=] with
  |ownerOrigin| and |frameOrigin|.
1. Let |request| be a new [=request=] with the following properties:
  :   [=request/URL=]
  ::  |permissionsUrl|
  :   [=request/header list=]
  ::  «`Accept`: `application/json`»
  :   [=request/client=]
  ::  `null`
  :   [=request/service-workers mode=]
  ::  "`none`"
  :   [=request/origin=]
  ::  |frameOrigin|
  :   [=request/mode=]
  ::  "`cors`"
  :   [=request/referrer=]
  :: "`no-referrer`"
  :   [=request/credentials mode=]
  ::  "`omit`"
  :   [=request/redirect mode=]
  :: "`error`"
1. Let |resource| be null.
1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true, and
  [=fetch/processResponseConsumeBody=] set to the following steps given a [=response=] |response|
  and null, failure, or a [=byte sequence=] |responseBody|:
  1. If |responseBody| is null or failure, set |resource| to failure and return.
  1. Let |headers| be |response|'s [=response/header list=].
  1. Let |mimeType| be the result of [=header list/extracting a MIME type=] from |headers|.
  1. If |mimeType| is failure or is not a [=JSON MIME Type=], throw, set |resource| to failure and return.
  1. Set |resource| to |responseBody|.
1. Wait for |resource| to be set.
1. If |resource| is failure, then return false.
1. Let |permissions| be the result of [=parsing a JSON string to an Infra value=] with |resource|, returning false
  on failure.
1. If |permissions| is not an [=ordered map=], then return false.
1. If |isJoin| is true and |permissions|["`joinAdInterestGroup`"] [=map/exists=], then return |permissions|["`joinAdInterestGroup`"].
1. If |isJoin| is false and |permissions|["`leaveAdInterestGroup`"] [=map/exists=], then return |permissions|["`leaveAdInterestGroup`"].
1. Return false.

The browser may cache requests for |permissionsUrl| within a network partition.

In order to prevent leaking data, the browser must request |permissionsUrl|
regardless of whether the user is a member of the ad interest group. This
prevents a leak of the user's ad interest group membership to the server.

</div>

<div algorithm>

To <dfn>build an interest group permissions url</dfn> given a [=origin=] |ownerOrigin| and a [=origin=] |frameOrigin|:
1. Let |serializedFrameOrigin| be the result of [=serialization of an origin|serializing=] |frameOrigin|.
1. Return the string formed by [=string/concatenating=]
  * The [=serialization of an origin|serialization=] of |ownerOrigin|,
  * The string "`/.well-known/interest-group/permissions/?origin=`", and
  * The result of [=string/UTF-8 percent-encoding=] |serializedFrameOrigin| using [=component percent-encode set=].

</div>

<h2 id="leaving-interest-groups">Leaving Interest Groups</h2>

In order to remove a user from a particular interest group,

{{Window/navigator}}.{{Navigator/leaveAdInterestGroup()}} can be called.

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<undefined> leaveAdInterestGroup(optional AuctionAdInterestGroupKey group = {});
};

dictionary AuctionAdInterestGroupKey {
  required USVString owner;
  required USVString name;
};
</xmp>

<div algorithm>

The <dfn for=Navigator method>leaveAdInterestGroup(group)</dfn> method steps
are:

1. Let |frameOrigin| be the [=relevant settings object=]'s [=environment settings object/origin=].
1. [=Assert=] that |frameOrigin| is not an [=opaque origin=] and its [=origin/scheme=] is "`https`".
1. Let |p| be [=a new promise=].
1. If |group| [=map/is empty=]:
  1. Let |instance| be [=this=]'s [=relevant global object=]'s [=Window/browsing context=]'s
    [=browsing context/fenced frame config instance=].
  1. If |instance| is null, [=exception/throw=] a {{TypeError}}.
  1. Let |interestGroup| be |instance|'s [=fenced frame config instance/interest group descriptor=].
  1. Run these steps [=in parallel=]:
    1. [=Queue a task=] to [=resolve=] |p| with `undefined`.
    1. If |interestGroup| is not null:
      1. Let |owner| be |interestGroup|'s [=interest group descriptor/owner=].
      1. Let |name| be |interestGroup|'s [=interest group descriptor/name=].
      1. If |owner| is [=same origin=] with |frameOrigin|:
        1. [=list/Remove=] [=interest groups=] from the user agent's [=interest group set=] whose
          [=interest group/owner=] is |owner| and [=interest group/name=] is |name|.
1. Otherwise:
  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=allowed to use=] the
    "[=join-ad-interest-group=]" [=policy-controlled feature=], then [=exception/throw=] a
    "{{NotAllowedError}}" {{DOMException}}.
  1. Let |owner| be the result of [=parsing an origin=] with
    |group|["{{AuctionAdInterestGroupKey/owner}}"].
  1. If |owner| is failure, [=exception/throw=] a {{TypeError}}.
  1. Let |name| be |group|["{{AuctionAdInterestGroupKey/name}}"].
  1. Run these steps [=in parallel=]:
    1. Let |permission| be the result of [=checking interest group permissions=] with 
      |owner|, |frameOrigin|, and false.
    1. If |permission| is false, then [=queue a task=] to [=reject=] |p| with a
       "{{NotAllowedError}}" {{DOMException}} and do not run the remaining steps.
    1. [=Queue a task=] to [=resolve=] |p| with `undefined`.
    1. [=list/Remove=] [=interest groups=] from the user agent's [=interest group set=] whose
      [=interest group/owner=] is |owner| and [=interest group/name=] is |name|.
1. Return |p|.

</div>

<h2 id="running-ad-auctions">Running Ad Auctions</h2>

When a website or someone working on behalf of the website (e.g. a supply side platform, SSP) wants
to conduct an auction to select an advertisement to display to the user, they can call the
{{Window/navigator}}.{{Navigator/runAdAuction()}} function, providing an auction configuration that
tells the browser how to conduct the auction and which on-device recorded interests are allowed to
bid in the auction for the chance to display their advertisement.

<h3 id="runadauction">runAdAuction()</h3>

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  Promise<(USVString or FencedFrameConfig)?> runAdAuction(AuctionAdConfig config);
};

dictionary AuctionAdConfig {
  required USVString seller;
  required USVString decisionLogicURL;
  USVString trustedScoringSignalsURL;
  sequence<USVString> interestGroupBuyers;
  Promise<any> auctionSignals;
  any sellerSignals;
  USVString directFromSellerSignals;
  unsigned long long sellerTimeout;
  unsigned short sellerExperimentGroupId;
  USVString sellerCurrency;
  Promise<record<USVString, any>> perBuyerSignals;
  record<USVString, unsigned long long> perBuyerTimeouts;
  record<USVString, unsigned short> perBuyerGroupLimits;
  record<USVString, unsigned short> perBuyerExperimentGroupIds;
  record<USVString, record<USVString, double>> perBuyerPrioritySignals;
  record<USVString, USVString> perBuyerCurrencies;
  sequence<AuctionAdConfig> componentAuctions = [];
  AbortSignal? signal;
  Promise<boolean> resolveToConfig;
};
</xmp>

<div algorithm="runAdAuction()">

The <dfn for=Navigator method>runAdAuction(|config|)</dfn> method steps are:

1. Let |global| be [=this=]'s [=relevant global object=].
1. Let |settings| be [=this=]'s [=relevant settings object=].
1. If |global|'s [=associated Document=] is not [=allowed to use=] the "[=run-ad-auction=]"
  [=policy-controlled feature=], then [=exception/throw=] a "{{NotAllowedError}}" {{DOMException}}.
1. Let |auctionConfig| be the result of running [=validate and convert auction ad config=] with
  |config| and true.
1. If |auctionConfig| is failure, then [=exception/throw=] a {{TypeError}}.
1. Let |p| be [=a new promise=].
1. If |config|["{{AuctionAdConfig/signal}}"] [=map/exists=], then:
  1. Let |signal| be |config|["{{AuctionAdConfig/signal}}"].
  1. If |signal| is [=AbortSignal/aborted=], then [=reject=] |p| with |signal|'s
    [=AbortSignal/abort reason=] and return |p|.
  1. [=AbortSignal/Add|Add the following abort steps=] to |signal|:
    1. [=Reject=] |p| with |signal|’s [=AbortSignal/abort reason=].
    1. TODO: Update bidCount for interest groups that participated in the auction.
    1. Run [=interest group update=] with |auctionConfig|'s
      [=auction config/interest group buyers=].
1. Let |queue| be the result of [=starting a new parallel queue=].
1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |queue|:
  1. Let |winner| be the result of running [=generate and score bids=] with |auctionConfig|, null,
    |global|, and |settings|.
  1. If |winner| is failure:
    1. [=Queue a global task=] on [=DOM manipulation task source=], given |global|, to [=reject=]
      |p| with a "{{TypeError}}".
  1. If |winner| is null:
    1. [=Queue a global task=] on [=DOM manipulation task source=], given |global|, to resolve |p|
      with null.
  1. Otherwise:
    1. Let |urn| and |fencedFrameConfig| be the result of TODO: constructing the relevant
       {{FencedFrameConfig}} with |winner|'s [=generated bid/ad descriptor=].
    1. Wait until |auctionConfig|'s [=auction config/resolve to config=] is a boolean.
    1. Let |result| be |fencedFrameConfig|.
    1. If |auctionConfig|'s [=auction config/resolve to config=] is false:
      1. Set |result| to |urn|.
    1. [=Queue a global task=] on the [=DOM manipulation task source=], given |global|, to
       resolve |p| with |result|.
    1. [=Increment ad k-anonymity count=] given |winner|'s [=generated bid/interest group=] and
      |winner|'s [=generated bid/ad descriptor=]'s [=ad descriptor/url=].
    1. If |winner|'s [=generated bid/ad component descriptors=] is not null:
      1. [=set/For each=] |adComponentDescriptor| in |winner|'s
        [=generated bid/ad component descriptors=]:
        1. [=Increment component ad k-anonymity count=] given |adComponentDescriptor|'s
          [=ad descriptor/url=].
    1. [=Increment reporting ID k-anonymity count=] given |winner|'s
      [=generated bid/interest group=] and |winner|'s [=generated bid/ad descriptor=]'s
      [=ad descriptor/url=].
  1. Run [=interest group update=] with |auctionConfig|'s [=auction config/interest group buyers=].
  1. TODO: Update bidCount and prevWinsMs for interest groups that participated in the auction.
1. Return |p|.

</div>

<div algorithm="validate and convert auction ad config">

To <dfn>validate and convert auction ad config</dfn> given an {{AuctionAdConfig}} |config| and a
[=boolean=] |isTopLevel|:
1. Let |auctionConfig| be a new [=auction config=].
1. Let |seller| be the result of [=parsing an origin=] with |config|["{{AuctionAdConfig/seller}}"].
1. If |seller| is failure, or its [=url/scheme=] is not "`https`", then [=exception/throw=] a
  {{TypeError}}.
1. Set |auctionConfig|'s [=auction config/seller=] to |seller|.
1. Let |decisionLogicURL| be the result of running the [=URL parser=] on
  |config|["{{AuctionAdConfig/decisionLogicURL}}"].
1. If |decisionLogicURL| is failure, or it is not [=same origin=] with |auctionConfig|'s
  [=auction config/seller=], then [=exception/throw=] a {{TypeError}}.
1. [=Assert=]: |decisionLogicURL|'s [=url/scheme=] is "`https`".
1. Set |auctionConfig|'s [=auction config/decision logic url=] to |decisionLogicURL|.
1. If |config|["{{AuctionAdConfig/trustedScoringSignalsURL}}"] [=map/exists=]:
  1. Let |trustedScoringSignalsURL| be the result of running the [=URL parser=] on
    |config|["{{AuctionAdConfig/trustedScoringSignalsURL}}"].
  1. If |trustedScoringSignalsURL| is failure, or it is not [=same origin=] with |auctionConfig|'s
    [=auction config/seller=], then [=exception/throw=] a {{TypeError}}.
  1. [=Assert=]: |trustedScoringSignalsURL|'s [=url/scheme=] is "`https`".
  1. Set |auctionConfig|'s [=auction config/trusted scoring signals url=] to
    |trustedScoringSignalsURL|.
1. If |config|["{{AuctionAdConfig/interestGroupBuyers}}"] [=map/exists=]:
  1. Let |buyers| be a new [=list=].
  1. [=list/For each=] |buyerString| in |config|["{{AuctionAdConfig/interestGroupBuyers}}"]:
    1. Let |buyer| be the result of [=parsing an origin=] with |buyerString|.
    1. If |buyer| is failure, or |buyer|'s [=url/scheme=] is not "`https`", then [=exception/throw=]
      a {{TypeError}}.
    1. [=list/Append=] |buyer| to |buyers|.
  1. Set |auctionConfig|'s [=auction config/interest group buyers=] to |buyers|.
1. If |config|["{{AuctionAdConfig/auctionSignals}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/auction signals=] to
    |config|["{{AuctionAdConfig/auctionSignals}}"].
  1. Increment |auctionConfig|'s [=auction config/pending promise count=].
  1. Let |resolvedAndTypeChecked| be the promise representing performing the following steps
    [=upon fulfillment=] of |auctionConfig|'s [=auction config/auction signals=] with |result|:    
    1. Let |auctionSignalsJSON| be the result of
      [=serializing a JavaScript value to a JSON string=], given |result|.
    1. If no exception was [=exception/thrown=] in the previous step:
      1. Set |auctionConfig|'s [=auction config/auction signals=] to |auctionSignalsJSON|.
      1. Set |auctionConfig|'s [=auction config/config idl=]["{{AuctionAdConfig/auctionSignals}}"]
        to |result|.
      1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
  1. [=Upon rejection=] of |resolvedAndTypeChecked|:
    1. Set |auctionConfig|'s [=auction config/auction signals=] to failure.
    1. Set |auctionConfig|'s [=auction config/config idl=]["{{AuctionAdConfig/auctionSignals}}"]
      to undefined.
    1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
1. If |config|["{{AuctionAdConfig/sellerSignals}}"] [=map/exists=]:
  1. If |config|["{{AuctionAdConfig/sellerSignals}}"] is a {{Promise}}:
    1. Set |auctionConfig|'s [=auction config/seller signals=] to
      |config|["{{AuctionAdConfig/sellerSignals}}"].
    1. Increment |auctionConfig|'s [=auction config/pending promise count=].
    1. [=Upon fulfillment=] of |auctionConfig|'s [=auction config/seller signals=] with |result|:
      1. Set |auctionConfig|'s [=auction config/seller signals=] to the result of
        [=serializing a JavaScript value to a JSON string=], given |result|.
      1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
    1. [=Upon rejection=] of |auctionConfig|'s [=auction config/seller signals=]:
      1. Set |auctionConfig|'s [=auction config/seller signals=] to failure.
      1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
  1. Otherwise, set |auctionConfig|'s [=auction config/seller signals=] to the result of
    [=serializing a JavaScript value to a JSON string=], given
    |config|["{{AuctionAdConfig/sellerSignals}}"].
1. If |config|["{{AuctionAdConfig/directFromSellerSignals}}"] [=map/exists=], let
  |directFromSellerSignalsPrefix| be the result of running the [=URL parser=] on
  |config|["{{AuctionAdConfig/directFromSellerSignals}}"].
  1. [=exception/Throw=] a {{TypeError}} if any of the following conditions hold:
    * |directFromSellerSignalsPrefix| is failure;
    * |directFromSellerSignalsPrefix| is not [=same origin=] with |auctionConfig|'s
      [=auction config/seller=];
    * |directFromSellerSignalsPrefix|'s [=url/query=] is not null.
  1. [=Assert=]: |directFromSellerSignalsPrefix|'s [=url/scheme=] is "`https`".
1. If |config|["{{AuctionAdConfig/sellerTimeout}}"] [=map/exists=], set |auctionConfig|'s
  [=auction config/seller timeout=] to |config|["{{AuctionAdConfig/sellerTimeout}}"] in milliseconds
  or 500 milliseconds, whichever is smaller.
1. If |config|["{{AuctionAdConfig/sellerExperimentGroupId}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/seller experiment group id=] to
    |config|["{{AuctionAdConfig/sellerExperimentGroupId}}"].
1. If |config|["{{AuctionAdConfig/sellerCurrency}}"]  [=map/exists=]:
  1. If the result of [=checking whether a string is a valid currency tag=] on |config|["{{AuctionAdConfig/sellerCurrency}}"] is false, [=exception/throw=] a {{TypeError}}.
  1. Set |auctionConfig|'s [=auction config/seller currency=] to |config|["{{AuctionAdConfig/sellerCurrency}}"]
1. If |config|["{{AuctionAdConfig/perBuyerSignals}}"] [=map/exists=]:
  1. Set |auctionConfig|'s [=auction config/per buyer signals=] to
    |config|["{{AuctionAdConfig/perBuyerSignals}}"].
  1. Increment |auctionConfig|'s [=auction config/pending promise count=].
  1. Let |resolvedAndTypeChecked| be the promise representing performing the following steps [=upon fulfillment=] of |auctionConfig|'s [=auction config/per buyer signals=] with |result|:
    1. Set |auctionConfig|'s [=auction config/per buyer signals=] to a new [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are [=strings=].
    1. [=map/For each=] |key| → |value| of |result|:
      1. Let |buyer| be the result of [=parsing an origin=] with |key|. If |buyer| is failure, throw a {{TypeError}}.
      1. Let |signalsString| be the result of [=serializing a JavaScript value to a JSON string=], given |value|.
      1. [=map/Set=] |auctionConfig|'s [=auction config/per buyer signals=][|buyer|] to |signalsString|.
    1. If the previous steps did not [=exception/throw=] an exception:
      1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
  1. [=Upon rejection=] of |resolvedAndTypeChecked|:
    1. Set |auctionConfig|'s [=auction config/per buyer signals=] to failure.
    1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
1. If |config|["{{AuctionAdConfig/perBuyerTimeouts}}"] [=map/exists=]:
  1. If |config|["{{AuctionAdConfig/perBuyerTimeouts}}"] is a {{Promise}}:
    1. Set |auctionConfig|'s [=auction config/per buyer timeouts=] to
      |config|["{{AuctionAdConfig/perBuyerTimeouts}}"].
    1. Increment |auctionConfig|'s [=auction config/pending promise count=].
    1. [=Upon fulfillment=] of |auctionConfig|'s [=auction config/per buyer timeouts=] with |result|:
      1. Let |pendingException| be null.
      1. If |result| is not a [=record=] mapping from {{USVString}} to {{unsigned long long}}, set
        |pendingException| to a {{TypeError}} and jump to the step labeled
        <i><a href=#validate-per-buyer-timeouts-finish>finish</a></i>.
      1. Set |auctionConfig|'s [=auction config/per buyer timeouts=] to a new [=ordered map=] whose
        [=map/keys=] are [=origins=] and whose [=map/values=] are [=durations=] in milliseconds.
      1. [=map/For each=] |key| → |value| of |result|:
        1. If |key| is "*", then set |auctionConfig|'s [=auction config/all buyers timeout=]
          to |value| in milliseconds or 500 milliseconds, whichever is smaller, and [=iteration/continue=].
        1. Let |buyer| be the result of [=parsing an origin=] with |key|. If |buyer| is failure,
          set |pendingException| to a {{TypeError}} and jump to the step labeled
          <i><a href=#validate-per-buyer-timeouts-finish>finish</a></i>.
        1. [=map/Set=] |auctionConfig|'s [=auction config/per buyer timeouts=][|buyer|] to
          |value| in milliseconds or 500 milliseconds, whichever is smaller.
      1. <i id=validate-per-buyer-timeouts-finish>Finish</i>:
        1. If |pendingException| is not null:
          1. Set |auctionConfig|'s [=auction config/per buyer timeouts=] to failure.
          1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
          1. [=exception/Throw=] |pendingException|.
        1. Otherwise, decrement |auctionConfig|'s [=auction config/pending promise count=].
    1. [=Upon rejection=] of |auctionConfig|'s [=auction config/per buyer timeouts=]:
      1. Set |auctionConfig|'s [=auction config/per buyer timeouts=] to failure.
      1. Decrement |auctionConfig|'s [=auction config/pending promise count=].
  1. [=map/for each=] |key| → |value| of |config|["{{AuctionAdConfig/perBuyerTimeouts}}"]:
    1. If |key| is "*", then set |auctionConfig|'s [=auction config/all buyers timeout=]
      to |value| in milliseconds or 500 milliseconds, whichever is smaller, and [=iteration/continue=].
    1. Let |buyer| the result of [=parsing an origin=] with |key|. If |buyer| is failure,
      [=exception/throw=] a {{TypeError}}.
    1. [=map/Set=] |auctionConfig|'s [=auction config/per buyer timeouts=][|buyer|] to
      |value| in milliseconds or 500 milliseconds, whichever is smaller.
1. If |config|["{{AuctionAdConfig/perBuyerGroupLimits}}"] [=map/exists=], [=map/for each=]
  |key| → |value| of |config|["{{AuctionAdConfig/perBuyerGroupLimits}}"]:
  1. If |value| is 0, [=exception/throw=] a {{TypeError}}.
  1. If |key| is "*", then set |auctionConfig|'s [=auction config/all buyers group limit=]
    to |value|, and [=iteration/continue=].
  1. Let |buyer| be the result of [=parsing an origin=] with |key|. If |buyer| is failure,
    [=exception/throw=] a {{TypeError}}.
  1. Set |auctionConfig|'s [=auction config/per buyer group limits=][|buyer|] to |value|.
1. If |config|["{{AuctionAdConfig/perBuyerExperimentGroupIds}}"] [=map/exists=], [=map/for each=]
  |key| → |value| of |config|["{{AuctionAdConfig/perBuyerExperimentGroupIds}}"]:
  1. If |key| is "*", then set |auctionConfig|'s
    [=auction config/all buyer experiment group id=] to |value|, and [=iteration/continue=].
  1. Let |buyer| the result of [=parsing an origin=] with |key|. If |buyer| is failure,
    [=exception/throw=] a {{TypeError}}.
  1. Set |auctionConfig|'s [=auction config/per buyer experiment group ids=][|buyer|] to |value|.
1. If |config|["{{AuctionAdConfig/perBuyerPrioritySignals}}"] [=map/exists=], [=map/for each=]
  |key| → |value| of |config|["{{AuctionAdConfig/perBuyerPrioritySignals}}"]:
  1. Let |signals| be an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=]
    are {{double}}.
  1. [=map/for each=] |k| → |v| of |value|:
    1. If |k| [=string/starts with=] "browserSignals.", [=exception/throw=] a {{TypeError}}.
    1. [=map/Set=] |signals|[|k|] to |v|.
  1. If |key| is "*", then set |auctionConfig|'s
    [=auction config/all buyers priority signals=] to |value|, and [=iteration/continue=].
  1. Let |buyer| be the result of [=parsing an origin=] with |key|. If it fails, [=exception/throw=]
    a {{TypeError}}.
  1. [=map/Set=] |auctionConfig|'s [=auction config/per buyer priority signals=][|buyer|] to
    |signals|.
1. If |config|["{{AuctionAdConfig/perBuyerCurrencies}}"] [=map/exists=], [=map/for each=]
  |key| → |value| of |config|["{{AuctionAdConfig/perBuyerCurrencies}}"]:
  1. If the result of [=checking whether a string is a valid currency tag=] given |value| is false, [=exception/throw=] a {{TypeError}}.
  1. If |key| is "*", then set |auctionConfig|'s
    [=auction config/all buyers currency=] to |value|, and [=iteration/continue=].
  1. Let |buyer| be the result of [=parsing an origin=] with |key|. If |buyer| is failure, [=exception/throw=] a {{TypeError}}.
  1. [=map/Set=] |auctionConfig|'s [=auction config/per buyer currencies=][|buyer|] to |value|.
1. [=list/For each=] |component| in |config|["{{AuctionAdConfig/componentAuctions}}"]:
  1. If |isTopLevel| is false, [=exception/throw=] a {{TypeError}}.
  1. Let |componentAuction| be the result of running [=validate and convert auction ad config=] with
    |component| and false.
  1. [=list/Append=] |componentAuction| to |auctionConfig|'s [=auction config/component auctions=].
1. Set |auctionConfig|'s [=auction config/config idl=] to |config|.
1. If |config|["{{AuctionAdConfig/resolveToConfig}}"] [=map/exists=]:
  1. Let |auctionConfig|'s [=auction config/resolve to config=] be
     |config|["{{AuctionAdConfig/resolveToConfig}}"].
  1. [=Upon fulfillment=] of |auctionConfig|'s [=auction config/resolve to config=] with
     |resolveToConfig|, set |auctionConfig|'s [=auction config/resolve to config=] to
     |resolveToConfig|.
1. Return |auctionConfig|.

</div>

<div algorithm>

To <dfn>parse an origin</dfn> given a [=string=] |input|:
1. Let |url| be the result of running the [=URL parser=] on |input|.
1. If |url| is failure, then return failure.
1. Return |url|'s [=url/origin=].

</div>

<div algorithm>

To <dfn>build bid generators map</dfn> given an [=auction config=] |auctionConfig|:
1. Let |bidGenerators| be a new [=ordered map=] whose [=map/keys=] are [=origins=] and whose
  [=map/values=] are [=per buyer bid generators=].
1. [=list/For each=] |buyer| in |auctionConfig|'s [=auction config/interest group buyers=]:
  1. [=list/For each=] |ig| of the user agent's [=interest group set=] whose
    [=interest group/owner=] is |buyer|:
    1. Let |signalsUrl| be |ig|'s [=interest group/trusted bidding signals url=].
    1. Let |joiningOrigin| be |ig|'s [=interest group/joining origin=].
    1. If |bidGenerators| does not [=map/contain=] |buyer|:
      1. Let |perBuyerGenerator| be a new [=per buyer bid generator=].
      1. Let |perSignalsUrlGenerator| be a new [=per signals url bid generator=].
      1. [=map/Set=] |perSignalsUrlGenerator|[|joiningOrigin|] to « |ig| ».
      1. [=map/Set=] |perBuyerGenerator|[|signalsUrl|] to |perSignalsUrlGenerator|.
      1. [=map/Set=] |bidGenerators|[|buyer|] to |perBuyerGenerator|.
      1. TODO: add a perBiddingScriptUrlGenerator layer that replaces the list of IGs with a map
        from biddingScriptUrl to a list of IGs.
    1. Otherwise:
      1. Let |perBuyerGenerator| be |bidGenerators|[|buyer|].
      1. If |perBuyerGenerator| does not [=map/contain=] |signalsUrl|:
        1. Let |perSignalsUrlGenerator| be a new [=per signals url bid generator=].
        1. [=map/Set=] |perSignalsUrlGenerator|[|joiningOrigin|] to « |ig| ».
        1. [=map/Set=] |perBuyerGenerator|[|signalsUrl|] to |perSignalsUrlGenerator|.
      1. Otherwise:
        1. Let |perSignalsUrlGenerator| be |perBuyerGenerator|[|signalsUrl|].
        1. If |perSignalsUrlGenerator| does not [=map/contain=] |joiningOrigin|:
          1. [=map/Set=] |perSignalsUrlGenerator|[|joiningOrigin|] to « |ig| ».
        1. Otherwise:
          1. [=list/Append=] |ig| to |perSignalsUrlGenerator|[|joiningOrigin|].
1. Return |bidGenerators|.

</div>

<div algorithm="generate a bid">

To <dfn>generate a bid</dfn> given an [=ordered map=] |allTrustedBiddingSignals|, a 
[=string=] |auctionSignals|, a {{BiddingBrowserSignals}} |browserSignals|, a [=string=]
|perBuyerSignals|, a [=duration=] |perBuyerTimeout| in milliseconds, a [=currency tag=] |expectedCurrency|,
an [=interest group=] |ig|, and a [=moment=] |auctionStartTime|:
  1. Let |igGenerateBid| be the result of [=building an interest group passed to generateBid=]
    with |ig|.
  1. Set |browserSignals|["{{BiddingBrowserSignals/joinCount}}"] to the sum of |ig|'s
     [=interest group/join counts=] for all days within the last 30 days.
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/bidCount}}"] to the sum of |ig|'s
     [=interest group/bid counts=] for all days within the last 30 days.
  1. Let |prevWins| be a new <code>[=sequence=]<{{PreviousWin}}></code>.
  1. [=list/For each] |prevWin| of |ig|'s [=interest group/previous wins=] for all days within the
    the last 30 days:
    1. Let |timeDelta| be |auctionStartTime| minus |prevWin|[=previous win/time=].
    1. Set |timeDelta| to 0 if |timeDelta| is negative, |timeDelta|'s nearest second (rounding down)
      otherwise.
    1. Let |prevWinIDL| be a new {{PreviousWin}}.
    1. [=map/Set=] |prevWinIDL|["{{PreviousWin/timeDelta}}"] to |timeDelta|.
    1. [=map/Set=] |prevWinIDL|["{{PreviousWin/adJSON}}"] to |prevWin|'s [=previous win/ad json=].
    1. [=list/Append=] |prevWinIDL| to |prevWins|.
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/prevWinsMs}}"] to |prevWins|.
  1. Let |biddingScript| be the result of [=fetching script=] with |ig|'s
    [=interest group/bidding url=].
  1. If |biddingScript| is failure, return failure.
  1. If |ig|'s [=interest group/bidding wasm helper url=] is not null:
    1. Let |wasmModuleObject| be the result of [=fetching WebAssembly=] with |ig|'s
      [=interest group/bidding wasm helper url=].
    1. If |wasmModuleObject| is not failure:
      1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/wasmHelper}}"] to |wasmModuleObject|.
  1. Let |trustedBiddingSignals| be an [=ordered map=] whose [=map/keys=] are [=strings=] and
    whose [=map/values=] are {{any}}.
  1. [=list/For each=] |key| of |ig|'s [=interest group/trusted bidding signals keys=]:
    1. If |allTrustedBiddingSignals| is an [=ordered map=] and |allTrustedBiddingSignals|[|key|]
      [=map/exists=], then [=map/set=] |trustedBiddingSignals|[|key|] to
      |allTrustedBiddingSignals|[|key|].
  1. Return the result of [=evaluating a bidding script=] with |biddingScript|, |ig|, |expectedCurrency|,
    |igGenerateBid|, |auctionSignals|, |perBuyerSignals|, |trustedBiddingSignals|, |browserSignals|,
    and |perBuyerTimeout|.
</div>
  
<div algorithm="generate and score bids">

To <dfn>generate and score bids</dfn> given an [=auction config=] |auctionConfig|, an
[=auction config=]-or-null |topLevelAuctionConfig|, a [=global object=] |global|, and an
[=environment settings object=] |settings|:
1. [=Assert=] that these steps are running [=in parallel=].
1. Let |auctionStartTime| be the [=current wall time=].
1. Let |decisionLogicScript| be the result of [=fetching script=] with |auctionConfig|'s
  [=auction config/decision logic url=].
1. If |decisionLogicScript| is failure, return null.
1. Let |bidGenerators| be the result of running [=build bid generators map=] with |auctionConfig|.
1. Let |leadingBidInfo| be a new [=leading bid info=].
1. Let |queue| be the result of [=starting a new parallel queue=].
1. If |auctionConfig|'s [=auction config/component auctions=] are not [=list/is empty|empty=]:
  1. [=Assert=] |topLevelAuctionConfig| is null.
  1. Let |pendingComponentAuctions| be the [=list/size=] of |auctionConfig|'s
    [=auction config/component auctions=].
  1. [=list/For each=] |component| in |auctionConfig|'s [=auction config/component auctions=],
    [=parallel queue/enqueue steps|enqueue the following steps=] to |queue|:
    1. Let |compWinner| be the result of running [=generate and score bids=] with |component|,
      |auctionConfig|, |global|, and |settings|.
    1. If |compWinner| is failure, return failure.
    1. If |compWinner| is not null:
      1. Run [=score and rank a bid=] with |auctionConfig|, |compWinner|, |leadingBidInfo|,
        |decisionLogicScript|, null, "top-level-auction", null, and |settings|'s [=environment/top-level origin=].

    1. Decrement |pendingComponentAuctions| by 1.
  1. Wait until |pendingComponentAuctions| is 0.
  1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is null, return null.
  1. Let |winningComponentConfig| be |leadingBidInfo|'s [=leading bid info/auction config=].
  1. Set |leadingBidInfo|'s [=leading bid info/auction config=] to |auctionConfig|.
  1. Set |leadingBidInfo|'s [=leading bid info/component seller=] to |winningComponentConfig|'s
    [=auction config/seller=].
  1. Let « |topLevelSellerSignals|, unusedTopLevelReportResultBrowserSignals » be the result of
    running [=report result=] with |leadingBidInfo| and |winningComponentConfig|.
  1. Set |leadingBidInfo|'s [=leading bid info/auction config=] to |winningComponentConfig|.
  1. Set |leadingBidInfo|'s [=leading bid info/component seller=] to null.
  1. Set |leadingBidInfo|'s [=leading bid info/top level seller=] to |auctionConfig|'s
    [=auction config/seller=].
  1. Set |leadingBidInfo|'s [=leading bid info/top level seller signals=] to
    |topLevelSellerSignals|.
  1. Let « |sellerSignals|, |reportResultBrowserSignals| » be the result of running
    [=report result=] with |leadingBidInfo| and null.
  1. Run [=report win=] with |leadingBidInfo|, |sellerSignals|, and |reportResultBrowserSignals|.
  1. Return |leadingBidInfo|'s [=leading bid info/leading bid=].

1. Let |allBuyersExperimentGroupId| be |auctionConfig|'s
  [=auction config/all buyer experiment group id=].
1. Let |allBuyersGroupLimit| be |auctionConfig|'s
  [=auction config/all buyers group limit=].  
1. Wait until |auctionConfig|'s [=auction config/pending promise count=] is 0.
1. Let |auctionSignals| be |auctionConfig|'s [=auction config/auction signals=].
1. [=Assert=] |auctionSignals|, |auctionConfig|'s [=auction config/seller signals=],
  [=auction config/per buyer signals=], and [=auction config/per buyer timeouts=] are not {{Promise}}s.
1. If |auctionSignals|, |auctionConfig|'s [=auction config/seller signals=],
  [=auction config/per buyer signals=], or [=auction config/per buyer timeouts=] is failure, return
  failure.
1. Let |browserSignals| be a {{BiddingBrowserSignals}}.
1. Let |topLevelHost| be the result of running the <a spec=url>host serializer</a> on [=this=]'s
  [=relevant settings object=]'s [=environment/top-level origin=]'s [=origin/host=].
1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/topWindowHostname}}"] to |topLevelHost|.
1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/seller}}"] to the [=serialization of an
  origin|serialization=] of |auctionConfig|'s [=auction config/seller=].
1. Let |auctionLevel| be "single-level-auction".
1. Let |componentAuctionExpectedCurrency| be null.
1. If |topLevelAuctionConfig| is not null:
  1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/topLevelSeller}}"]] to the
    [=serialization of an origin|serialization=] of |topLevelAuctionConfig|'s
    [=auction config/seller=].
  1. Set |auctionLevel| to "component-auction".
  1. Set |componentAuctionExpectedCurrency| to the result of [=looking up per-buyer currency=] with |topLevelAuctionConfig| and |auctionConfig|'s [=auction config/seller=].
1. Let |pendingBuyers| be the [=map/size=] of |bidGenerators|.
1. [=map/For each=] |buyer| → |perBuyerGenerator| of |bidGenerators|,
  [=parallel queue/enqueue steps|enqueue the following steps=] to |queue|:
  1. Let |buyerExperimentGroupId| be |allBuyersExperimentGroupId|.
  1. Let |perBuyerExperimentGroupIds| be |auctionConfig|'s
    [=auction config/per buyer experiment group ids=].
  1. If |perBuyerExperimentGroupIds| is not null and |perBuyerExperimentGroupIds|[|buyer|]
    [=map/exists=]:
    1. Set |buyerExperimentGroupId| to |perBuyerExperimentGroupIds|[|buyer|].
  1. <dfn>Apply interest groups limits to prioritized list</dfn>:
    1. Let |buyerGroupLimit| be |allBuyersGroupLimit|.
    1. Let |perBuyerGroupLimits| be |auctionConfig|'s
      [=auction config/per buyer group limits=].
    1. If |perBuyerGroupLimits| is not null and |perBuyerGroupLimits|[|buyer|] exists:
      1. Set |buyerGroupLimit| to |perBuyerGroupLimits|[|buyer|].
    1. Let |igs| be a new [=list=] of [=interest groups=].
    1. [=map/For each=] signalsUrl → |perSignalsUrlGenerator| of |perBuyerGenerator|:
      1. [=map/For each=] joiningOrigin → |groups| of |perSignalsUrlGenerator|:
        1. [=list/Extend=] |igs| with |groups|.
    1. [=list/Sort in descending order=] |igs|, with |a| being less than |b| if |a|'s
      [=interest group/priority=] is less than |b|'s [=interest group/priority=].
    1. [=list/Remove=] the first |buyerGroupLimit| items from |igs|.
    1. [=map/For each=] signalsUrl → |perSignalsUrlGenerator| of |perBuyerGenerator|:
      1. [=map/For each=] joiningOrigin → |groups| of |perSignalsUrlGenerator|:
        1. [=list/Remove=] from |groups| any [=interest group=] [=list/contained=] in |igs|.
  1. Let |perBuyerSignals| be null.
  1. If |auctionConfig|'s [=auction config/per buyer signals=] is not null and
    [=auction config/per buyer signals=][|buyer|] [=map/exists=]:
    1. Set |perBuyerSignals| to |auctionConfig|'s [=auction config/per buyer signals=][|buyer|].
  1. Let |perBuyerTimeout| be |auctionConfig|'s [=auction config/all buyers timeout=].
  1. If |auctionConfig|'s [=auction config/per buyer timeouts=] is not null and
    [=auction config/per buyer timeouts=][|buyer|] [=map/exists=]:
    1. Set |perBuyerTimeout| to |auctionConfig|'s [=auction config/per buyer timeouts=][|buyer|].
  1. Let |expectedCurrency| be the result of [=looking up per-buyer currency=] with |auctionConfig| and |buyer|.
  1. [=map/For each=] |signalsUrl| → |perSignalsUrlGenerator| of |perBuyerGenerator|:
    1. Let |keys| be a new [=ordered set=].
    1. Let |igNames| be a new [=ordered set=].
    1. [=map/For each=] joiningOrigin → |groups| of |perSignalsUrlGenerator|:
      1. [=list/For each=] |ig| of |groups|:
        1. [=set/Append=] |ig|'s [=interest group/trusted bidding signals keys=] to |keys|.
        1. [=set/Append=] |ig|'s [=interest group/name=] to |igNames|.
    1. Let |biddingSignalsUrl| be the result of [=building trusted bidding signals url=] with
      |signalsUrl|, |keys|, |igNames|, |buyerExperimentGroupId|.
    1. Let « |allTrustedBiddingSignals|, |dataVersion| » be the result of [=fetching trusted signals=]
      with |biddingSignalsUrl| and true.
    1. If |dataVersion| is not null:
      1. [=map/Set=] |browserSignals|["{{BiddingBrowserSignals/dataVersion}}"] to |dataVersion|.
    1. [=map/For each=] joiningOrigin → |groups| of |perSignalsUrlGenerator|:
      1. [=list/For each=] |ig| of |groups|:
        1. If |ig|'s [=interest group/bidding url=] is null, [=iteration/continue=].
        1. Let |generatedBid| be the result of [=generate a bid=] given
          |allTrustedBiddingSignals|, |auctionSignals|, a [=map/clone=] of |browserSignals|,
          |perBuyerSignals|, |perBuyerTimeout|, |expectedCurrency|, |ig|, and |auctionStartTime|.
        1. If |generatedBid| is failure, [=iteration/continue=].
        1. If [=query generated bid k-anonymity count=] given |generatedBid| returns false:

          Note: [=Generate a bid=] is now rerun with only k-anonymous [=interest group/ads=] to give
          the buyer a chance to [=generate a bid=] for k-anonymous [=interest group/ads=]. Allowing
          the buyer to first [=generate a bid=] for non-k-anonymous [=interest group/ads=] provides a
          mechanism to bootstrap the k-anonymity count, otherwise no [=interest group/ads=] would
          ever trigger [=increment k-anonymity count=] and all ads would fail
          [=query k-anonymity count=].
          1. TODO: Run [=score and rank a bid=] on |generatedBid| to find the highest scoring bid
            that isn't k-anonymous. After the auction, if the highest scoring bid that isn't
            k-anonymous has a higher score than the highest scoring k-anonymous bid, then call
            [=increment ad k-anonymity count=] on it.
          1. Let |originalAds| be |ig|'s [=interest group/ads=].
          1. Let |originalAdComponents| be |ig|'s [=interest group/ad components=].
          1. Set |ig|'s [=interest group/ads=] to a new empty [=list=] of
            [=interest group ad=].
          1. Set |ig|'s [=interest group/ad components=] to a new [=list/is empty|empty=]
            [=list=] of [=interest group ad=].
          1. [=list/For each=] |ad| in |originalAds|:
            1. If [=query ad k-anonymity count=] given |ig| and |ad|'s
              [=interest group ad/render url=] returns true, [=list/append=] |ad| to |ig|'s
              [=interest group/ads=].
          1. [=list/For each=] |adComponent| in |originalAdComponents|:
            1. If [=query component ad k-anonymity count=] given |adComponent|'s
              [=interest group ad/render url=] returns true, [=list/append=] |adComponent| to |ig|'s
              [=interest group/ad components=].
          1. Set |generatedBid| to the result of [=generate a bid=] given
            |allTrustedBiddingSignals|, |auctionSignals|, a [=map/clone=] of |browserSignals|,
            |perBuyerSignals|, |perBuyerTimeout|, |expectedCurrency|, and |ig|.

          1. Set |ig|'s [=interest group/ads=] to |originalAds|.
          1. Set |ig|'s [=interest group/ad components=] to |originalAdComponents|.
          1. If |generatedBid| is failure, [=iteration/continue=].
        1. [=Score and rank a bid=] with |auctionConfig|, |generatedBid|, |leadingBidInfo|,
          |decisionLogicScript|, |dataVersion|, |auctionLevel|, |componentAuctionExpectedCurrency|, and |settings|'s
          [=environment/top-level origin=].

  1. Decrement |pendingBuyers| by 1.
1. Wait until |pendingBuyers| is 0.
1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is null, return null.
1. If |topLevelAuctionConfig| is null:
  1. Let « |sellerSignals|, |reportResultBrowserSignals| » be the result of running
    [=report result=] with |leadingBidInfo| and null.
  1. Run [=report win=] with |leadingBidInfo|, |sellerSignals|, and |reportResultBrowserSignals|.
1. Return |leadingBidInfo|'s [=leading bid info/leading bid=].

</div>

<div algorithm>
To <dfn>build an interest group passed to generateBid</dfn> given an [=interest group=] |ig|:
  
  1. Let |igGenerateBid| be a new {{GenerateBidInterestGroup}} with the following fields:
    <dl>
      <dt>{{GenerateBidInterestGroup/owner}}
      <dd>The [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      <dt>{{GenerateBidInterestGroup/name}}
      <dd>|ig|'s [=interest group/name=]
      <dt>{{GenerateBidInterestGroup/enableBiddingSignalsPrioritization}}
      <dd>|ig|'s [=interest group/enable bidding signals prioritization=]
      <dt>{{GenerateBidInterestGroup/priorityVector}}
      <dd>|ig|'s [=interest group/priority vector=] if not null, otherwise {{undefined}}
      <dt>{{GenerateBidInterestGroup/executionMode}}
      <dd>|ig|'s [=interest group/execution mode=]
      <dt>{{GenerateBidInterestGroup/biddingLogicURL}}
      <dd>The [=serialize a URL|serialization-or-undefined=] of |ig|'s [=interest group/bidding url=]
      <dt>{{GenerateBidInterestGroup/biddingWasmHelperURL}}
      <dd>The [=serialize a URL|serialization=] of |ig|'s [=interest group/bidding wasm helper url=]
      <dt>{{GenerateBidInterestGroup/updateURL}}
      <dd>The [=serialize a URL|serialization=] of |ig|'s [=interest group/update url=]
      <dt>{{GenerateBidInterestGroup/trustedBiddingSignalsURL}}
      <dd>The [=serialize a URL|serialization=] of |ig|'s [=interest group/trusted bidding signals url=]
      <dt>{{GenerateBidInterestGroup/trustedBiddingSignalsKeys}}
      <dd>|ig|'s [=interest group/trusted bidding signals keys=]
      <dt>{{GenerateBidInterestGroup/userBiddingSignals}}
      <dd>[=Parse a JSON string to a JavaScript value=] given |ig|'s [=interest group/user bidding signals=]

      <dt>{{GenerateBidInterestGroup/ads}}
      <dd>|ig|'s [=interest group/ads=] [=converted to an AuctionAd sequence=]
      <dt>{{GenerateBidInterestGroup/adComponents}}
      <dd>|ig|'s [=interest group/ad components=] [=converted to an AuctionAd sequence=]
    </dl>
  1. Return |igGenerateBid|.
</div>

<div algorithm>
To <dfn>serialize a URL</dfn> given a [=URL=]-or-null |url|:

  1. If |url| is null, then return {{undefined}}.
  1. Return the [=URL serializer|serialization=] of |url|.
</div>

<div algorithm>
To <dfn>convert to an AuctionAd sequence</dfn> given a [=list=]-or-null |ads|:

  1. If |ads| is null, then return {{undefined}}.
  1. Let |adsIDL| be a new <code>[=sequence=]<{{AuctionAd}}></code>.
  1. [=list/For each] |ad| of |ads|:
    1. Let |adIDL| be a new {{AuctionAd}}.
    1. [=map/Set=] |adIDL|["{{AuctionAd/renderURL}}"] to the [=URL serializer|serialization=] of
      |ad|'s [=interest group ad/render url=].
    1. If |ad|'s [=interest group ad/metadata=] is not null, then:
      1. [=map/Set=] |adIDL|["{{AuctionAd/metadata}}"] to the result of
        [=parsing a JSON string to a JavaScript value=] given |ad|'s [=interest group ad/metadata=].
    1. [=list/Append=] |adIDL| to |adsIDL|.
  1. Return |adsIDL|.
</div>

<div algorithm>

To <dfn>score and rank a bid</dfn> given an [=auction config=] |auctionConfig|, a [=generated bid=]
|generatedBid|, a [=leading bid info=] |leadingBidInfo|, a [=string=] |decisionLogicScript|, a
{{unsigned long}}-or-null |biddingDataVersion|, an enum |auctionLevel|, which is "single-level-auction", "top-level-auction", or "component-auction", a [=currency tag=] |componentAuctionExpectedCurrency|, and an [=origin=]
|topWindowOrigin|:

1. Let |renderURLs| be a new [=set=].
1. Let |adComponentRenderUrls| be a new [=set=].
1. [=set/Append=] |generatedBid|'s [=generated bid/ad descriptor=]'s [=ad descriptor/url=] to |renderURLs|.
1. If |generatedBid|'s [=generated bid/ad component descriptors=] is not null:
  1. [=set/For each=] |adComponentDescriptor| in |generatedBid|'s
    [=generated bid/ad component descriptors=]:
    1. [=set/Append=] |adComponentDescriptor|'s [=ad descriptor/url=] to |adComponentRenderUrls|.
1. Let |fullSignalsUrl| be the result of [=building trusted scoring signals url=] with |auctionConfig|'s
  [=auction config/trusted scoring signals url=], |renderURLs|, |adComponentRenderUrls|,
  |auctionConfig|'s [=auction config/seller experiment group id=], and |topWindowOrigin|.

  Implementations may batch requests by collecting render URLs and ad component render URLs
  from multiple invocations of [=score and rank a bid=] and passing them all to a single invocation
  of [=building trusted scoring signals url=] -- the network response has to be parsed to pull out the pieces
  relevant to each [=evaluating a scoring script|evaluation of a scoring script=].
1. Let |trustedScoringSignals| be null.
1. Let «|allTrustedScoringSignals|, |scoringDataVersion|» be the result of [=fetching trusted signals=] with
  |fullSignalsUrl| and false.
1. If |allTrustedScoringSignals| is an [=ordered map=]:
  1. Let |trustedScoringSignals| be a new [=map=].
  1. [=Assert=]: |renderURLs|'s [=set/size=] is 1.
  1. [=set/For each=] |renderURL| in |renderURLs|:
    1. If |allTrustedScoringSignals|["`renderURLs`"] [=map/exists=] and
      |allTrustedScoringSignals|["`renderURLs`"][|renderURL|] [=map/exists=]:
      1. Let |renderURLValue| be a new [=map=].
      1. [=map/Set=] |renderURLValue|[|renderURL|] to |allTrustedScoringSignals|["`renderURLs`"][|renderURL|].
      1. [=map/Set=] |trustedScoringSignals|["`renderURL`"] to |renderURLValue|.
  1. Let |adComponentRenderUrlsValue| be a new [=map=].
  1. [=set/For each=] |adComponentRenderUrl| in |adComponentRenderUrls|:
    1. If |allTrustedScoringSignals|["`adComponentRenderUrls`"] [=map/exists=] and
      |allTrustedScoringSignals|["`adComponentRenderUrls`"][|adComponentRenderUrl|] [=map/exists=]:
      1. [=map/Set=] |adComponentRenderUrlsValue|[|adComponentRenderUrl|] to
          |allTrustedScoringSignals|["`adComponentRenderUrls`"][|adComponentRenderUrl|].
  1. If |adComponentRenderUrlsValue| is not [=map/is empty|empty=]:
    1. [=map/Set=] |trustedScoringSignals|["`adComponentRenderUrls`"] to |adComponentRenderUrlsValue|.
1. Let |adMetadata| be |generatedBid|'s [=generated bid/ad=].
1. Let |bidValue| be |generatedBid|'s [=generated bid/bid=].
1. If |generatedBid|'s [=generated bid/modified bid=] is not null:
  1. Set |bidValue| to |generatedBid|'s [=generated bid/modified bid=].
1. Let |owner| be |generatedBid|'s [=generated bid/interest group=]'s [=interest group/owner=].
1. Let |browserSignals| be an [=ordered map=] whose [=map/keys=] are [=strings=] and whose
  [=map/values=] are {{any}}. TODO: Change to an IDL record<>.
1. [=map/Set=] |browserSignals|["`bidCurrency`"] to the result of [=serializing a currency tag=] with |generatedBid|'s
  [=generated bid/bid=]'s [=bid with currency/currency=].
1. [=map/Set=] |browserSignals|["`topWindowHostname`"] to |topWindowOrigin|'s [=origin/host=].
1. [=map/Set=] |browserSignals|["`interestGroupOwner`"] to |owner|.
1. [=map/Set=] |browserSignals|["`renderURL`"] to |generatedBid|'s [=generated bid/ad descriptor=]'s
  [=ad descriptor/url=].
1. [=map/Set=] |browserSignals|["`adComponents`"] to |generatedBid|'s
  [=generated bid/ad component descriptors=].
1. [=map/Set=] |browserSignals|["`biddingDurationMsec`"] to |generatedBid|'s
  [=generated bid/bid duration=].
1. If |scoringDataVersion| is not null:
  1. [=map/Set=] |browserSignals|["`dataVersion`"] to |scoringDataVersion|.
1. Let |scoreAdResult| be the result of [=evaluating a scoring script=] with
   |decisionLogicScript|, « |adMetadata|, |bidValue|'s [=bid with currency/value=], |auctionConfig|'s
   [=auction config/config idl=], |trustedScoringSignals|, |browserSignals| », and |auctionConfig|'s
   [=auction config/seller timeout=].
1. Let |scoreAdOutput| be result of [=processing scoreAd output=] with |scoreAdResult|.
1. If |scoreAdOutput| is failure, return.
1. If |auctionLevel| is not "single-level-auction", and |scoreAdOutput|
  ["{{ScoreAdOutput/allowComponentAuction}}"] is false, return.
1. Let |score| be |scoreAdOutput|["{{ScoreAdOutput/desirability}}"].
1. If |score| is negative or 0, return.
1. If |auctionLevel| is "component-auction":
  1. Let |bidToCheck| be |generatedBid|'s [=generated bid/bid=].
  1. If |scoreAdOutput|["{{ScoreAdOutput/bid}}"] [=map/exists=]:
    1. Let |modifiedBidValue| be |scoreAdOutput|["{{ScoreAdOutput/bid}}"].
    1. If |modifiedBidValue| is negative or 0, return.
    1. Let |modifiedBidCurrency| be null.
    1. If |scoreAdOutput|["{{ScoreAdOutput/bidCurrency}}] [=map/exists=]:
      1. Set |modifiedBidCurrency| to |scoreAdOutput|["{{ScoreAdOutput/bidCurrency}}].
    1. Set |generatedBid|'s [=generated bid/modified bid=] to a [=bid with currency=] with [=bid with currency/value=] |modifiedBidValue| and [=bid with currency/currency=] |modifiedBidCurrency|.
    1. Set |bidToCheck| to |generatedBid|'s [=generated bid/modified bid=].
  1. If the result of [=checking a currency tag=] with |componentAuctionExpectedCurrency| and |bidToCheck|'s [=bid with currency/currency=] is false, return.
  1. If the result of [=checking a currency tag=] with |auctionConfig|'s [=auction config/seller currency=] and |bidToCheck|'s [=bid with currency/currency=] is false, return.
1. If |auctionConfig|'s [=auction config/seller currency=] is not null:
  1. If |generatedBid|'s [=generated bid/bid=]'s [=bid with currency/currency=] is equal to |auctionConfig|'s [=auction config/seller currency=]:
    1. Set |generatedBid|'s [=generated bid/bid in seller currency=] to |generatedBid|'s [=generated bid/bid=]'s [=bid with currency/value=].
    1. If |scoreAdOutput|["{{ScoreAdOutput/incomingBidInSellerCurrency}}"] [=map/ exists=] and does not equal |generatedBid|'s [=generated bid/bid in seller currency=], return.
  1. Otherwise if |scoreAdOutput|["{{ScoreAdOutput/incomingBidInSellerCurrency}}"] [=map/ exists=]:
    1. Set |generatedBid|'s [=generated bid/bid in seller currency=] to |scoreAdOutput|["{{ScoreAdOutput/incomingBidInSellerCurrency}}"]
1. Let |updateLeadingBid| be false.
1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is null, or |score| is greater than
  |leadingBidInfo|'s [=leading bid info/top score=]:
  1. Set |updateLeadingBid| to true.
  1. Set |leadingBidInfo|'s [=leading bid info/top bids count=] to 1.
  1. Set |leadingBidInfo|'s [=leading bid info/at most one top bid owner=] to true.
1. Otherwise if |score| equals |leadingBidInfo|'s [=leading bid info/top score=]:
  1. Increment |leadingBidInfo|'s [=leading bid info/top bids count=] by 1.
  1. Set |updateLeadingBid| to true with 1 in |leadingBidInfo|'s [=leading bid info/top bids count=]
    chance.
  1. If |updateLeadingBid| is false:
    1. [=Update highest scoring other bid=] with |score|, |leadingBidInfo|'s
      [=leading bid info/leading bid=], and |leadingBidInfo|.
  1. If |owner| is not [=same origin=] with |leadingBidInfo|'s [=leading bid info/leading bid=]'s
    [=generated bid/interest group=]'s [=interest group/owner=]:
    1. Set |leadingBidInfo|'s [=leading bid info/at most one top bid owner=] to false.
1. Otherwise if |score| is greater than or equal to |leadingBidInfo|'s
  [=leading bid info/second highest score=]:
  1. [=Update highest scoring other bid=] with |score|, |bidValue|, and |leadingBidInfo|.
1. If |updateLeadingBid| is true:
  1. If |leadingBidInfo|'s [=leading bid info/leading bid=] is not null:
    1. [=Update highest scoring other bid=] with |leadingBidInfo|'s [=leading bid info/top score=],
      |leadingBidInfo|'s [=leading bid info/leading bid=], and |leadingBidInfo|.
  1. Set |leadingBidInfo|'s [=leading bid info/top score=] to |score|.
  1. Set |leadingBidInfo|'s [=leading bid info/leading bid=] to |generatedBid|.
  1. Set |leadingBidInfo|'s [=leading bid info/auction config=] to |auctionConfig|.
  1. Set |leadingBidInfo|'s [=leading bid info/bidding data version=] to |biddingDataVersion|.
  1. Set |leadingBidInfo|'s [=leading bid info/scoring data version=] to |scoringDataVersion|.

</div>

<div algorithm>
To <dfn>update highest scoring other bid</dfn> given a {{double}} |score|, a
[=generated bid=]-or-null |bid|, and a [=leading bid info=] |leadingBidInfo|:

  1. If |bid| is null, return.
  1. Let |owner| be |bid|'s [=generated bid/interest group=]'s [=interest group/owner=].
  1. If |score| is greater than |leadingBidInfo|'s [=leading bid info/second highest score=]:
    1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bid=] to |bid|.
    1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bids count=] to 1.
    1. Set |leadingBidInfo|'s [=leading bid info/second highest score=] to |score|.
    1. If |leadingBidInfo|'s [=leading bid info/at most one top bid owner=] is true:
      1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bid owner=] to |owner|.
    1. Otherwise,
      1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bid owner=] to null.
  1. Otherwise if |score| is equal to |leadingBidInfo|'s [=leading bid info/second highest score=]:
    1. Increment |leadingBidInfo|'s [=leading bid info/highest scoring other bids count=] by 1.
    1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bid=] to |bid| with 1 in
      |leadingBidInfo|'s [=leading bid info/highest scoring other bids count=] chance.
    1. If |leadingBidInfo|'s [=leading bid info/highest scoring other bid owner=] is not null:
      1. If |owner| is not [=same origin=] with |leadingBidInfo|'s
        [=leading bid info/highest scoring other bid owner=]:
        1. Set |leadingBidInfo|'s [=leading bid info/highest scoring other bid owner=] to null.
</div>

<div algorithm>
To <dfn>validate fetching response</dfn> given a [=response=] |response|, null, failure, or a
[=byte sequence=]|responseBody|, and a [=string=] |mimeType|:

  1. If |responseBody| is null or failure, return false.
  1. If [=header list/getting a structured field value|getting=] "X-Allow-Protected-Audience" from
    |response|'s [=response/header list=] does not return true, return false.
  1. Let |headerMimeType| be the result of [=header list/extracting a MIME type=] from |response|'s
    [=response/header list=].
  1. Return false if any of the following conditions hold:
    * |headerMimeType| is failure;
    * |mimeType| is "`text/javascript`" and |headerMimeType| is not a [=JavaScript MIME type=];
    * |mimeType| is "`application/json`" and |headerMimeType| is not a [=JSON MIME type=].
  1. Let |mimeTypeCharset| be |headerMimeType|'s [=MIME type/parameters=]["`charset`"].
  1. Return false if any of the following conditions hold:
    * |mimeTypeCharset| does not [=map/exist=], or |mimeTypeCharset| is "utf-8", and |responseBody|
      is not [=UTF-8=] encoded;
    * |mimeTypeCharset| is "us-ascii", and |responseBody| is not [=ascii string=].
  1. Return true.
</div>

<div algorithm>
To <dfn>fetch script</dfn> given a [=URL=] |url|:
  1. Let |request| be a new [=request=] with the following properties:
    :   [=request/URL=]
    ::  |url|
    :   [=request/header list=]
    ::  «`Accept`: `text/javascript`»
    :   [=request/client=]
    ::  `null`
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/mode=]
    ::  "`no-cors`"
    :   [=request/referrer=]
    :: "`no-referrer`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/redirect mode=]
    :: "`error`"
  1. Let |script| be null.
  1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true, and
    [=fetch/processResponseConsumeBody=] set to the following steps given a [=response=] |response|
    and null, failure, or a [=byte sequence=] |responseBody|:
    1. If [=validate fetching response=] with |response|, |responseBody| and "`text/javascript`"
      returns false, set |script| to failure and return.
    1. Set |script| to |responseBody|.
  1. Wait for |script| to be set.
  1. Return |script|.
</div>

<div algorithm>
To <dfn>fetch WebAssembly</dfn> given a [=URL=] |url|:

  1. Let |request| be a new [=request=] with the following properties:
    :   [=request/URL=]
    ::  |url|
    :   [=request/header list=]
    ::  «`Accept`: `application/wasm`»
    :   [=request/client=]
    ::  `null`
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/mode=]
    ::  "`no-cors`"
    :   [=request/referrer=]
    :: "`no-referrer`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/redirect mode=]
    :: "`error`"
  1. Let |moduleObject| be null.
  1. [=Fetch=] |request| with [=fetch/processResponseConsumeBody=] set to the following steps given
    a [=response=] |response| and |responseBody|:
    1. Set |moduleObject| to failure and return, if any of the following conditions hold:
      * |responseBody| is null or failure;
      * [=header list/getting a structured field value|Getting=] "X-Allow-Protected-Audience" from
        |response|'s [=response/header list=] does not return true.
    1. Let |module| be the result of [=compiling a WebAssembly module=] |response|.
    1. If |module| is [=error=], set |moduleObject| to failure.
    1. Otherwise, set |moduleObject| to |module|.
  1. Wait for |moduleObject| to be set.
  1. Return |moduleObject|.
</div>

The <dfn http-header><code>Data-Version</code></dfn> HTTP response header is a
[=structured header=] whose value must be an [=structured header/integer=].
The <dfn http-header><code>X-protected-audience-bidding-signals-format-version</code></dfn>
HTTP response header is a [=structured header=] whose value must be an [=structured header/integer=].

<div algorithm>
To <dfn>fetch trusted signals</dfn> given a [=URL=] |url|, and a [=boolean=] |isBiddingSignal|:

  1. Let |request| be a new [=request=] with the following properties:
    :   [=request/URL=]
    ::  |url|
    :   [=request/header list=]
    ::  «`Accept`: `application/json`»
    :   [=request/client=]
    ::  `null`
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/mode=]
    ::  "`no-cors`"
    :   [=request/referrer=]
    :: "`no-referrer`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/redirect mode=]
    :: "`error`"
  1. Let |signals| be null.
  1. Let |dataVersion| be null.
  1. Let |formatVersion| be null.
  1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true, and
    [=fetch/processResponseConsumeBody=] set to the following steps given a [=response=] |response|
    and null, failure, or a [=byte sequence=] |responseBody|:
    1. If [=validate fetching response=] with |response|, |responseBody| and "`application/json`"
      returns false, set |signals| to failure and return.
    1. Let |headers| be |response|'s [=response/header list=].
    1. Set |dataVersion| to the result of [=header list/getting a structured field value=]
      given [:Data-Version:] and "`item`" from |headers|.
    1. If |dataVersion| is not null:
      1. If |dataVersion| is not an integer, or is less than 0 or more than 4294967295, set
        |signals| to failure and return.
      1. TODO: Check whether version is consistent for all keys requested by this interest group.
    1. If |isBiddingSignal| is true:
      1. Set |formatVersion| to the result of [=header list/getting a structured field value=]
        given [:X-protected-audience-bidding-signals-format-version:] and "`item`" from |headers|.
    1. Set |signals| to the result of [=parsing JSON bytes to an Infra value=] |responseBody|.
  1. Wait for |signals| to be set.
  1. If |signals| is a parsing exception, or if |signals| is not an [=ordered map=], return « null,
    null ».
  1. If |formatVersion| is 2:
    1. If |signals|["`keys`"] does not [=map/exist=], return « null, null ».
    1. Set |signals| to |signals|["`keys`"].
    1. If |signals| is not an [=ordered map=], return « null, null ».
    1. TODO: handle priority vector.
  1. Return « |signals|, |dataVersion| ».
</div>

<div algorithm>

To <dfn>encode trusted signals keys</dfn> given an [=ordered set=] of [=strings=] |keys|:
1. Let |list| be a new empty [=list=].
1. Let |keysStr| be the result of [=string/concatenating=] |keys| with separator set to ",".
1. [=list/Append=] the result of [=string/UTF-8 percent-encoding=] |keysStr| using
  [=component percent-encode set=] to |list|.
1. Return |list|.

</div>

<div algorithm>

To <dfn>build trusted bidding signals url</dfn> given a [=URL=] |signalsUrl|, an [=ordered set=] of
[=strings=] |keys|, an [=ordered set=] of [=strings=] |igNames|, and an {{unsigned short}}-or-null
|experimentGroupId|:
1. Let |queryParamsList| be a new empty [=list=].
1. [=list/Append=] "hostname=" to |queryParamsList|.
1. [=list/Append=] the result of [=string/UTF-8 percent-encoding=] [=this=]'s
  [=relevant settings object=]'s [=environment/top-level origin=] using
  [=component percent-encode set=] to |queryParamsList|.
1. If |keys| is not [=set/is empty|empty=]:
  1. [=list/Append=] "&keys=" to |queryParamsList|.
  1. [=list/Extend=] |queryParamsList| with the result of [=encode trusted signals keys=] with
    |keys|.
1. If |igNames| is not [=set/is empty|empty=]:
  1. [=list/Append=] "&interestGroupNames=" to |queryParamsList|.
  1. [=list/Extend=] |queryParamsList| with the result of [=encode trusted signals keys=] with
    |igNames|.
1. If |experimentGroupId| is not null:
  1. [=list/Append=] "&experimentGroupId=" to |queryParamsList|.
  1. [=list/Append=] [=serialize an integer|serialized=] |experimentGroupId| to |queryParamsList|.
1. Let |fullSignalsUrl| be |signalsUrl|.
1. Set |fullSignalsUrl|'s [=url/query=] to the result of [=string/concatenating=] |queryParamsList|.
1. return |fullSignalsUrl|.

</div>

<div algorithm>

To <dfn>build trusted scoring signals url</dfn> given a [=URL=] |signalsUrl|, an [=ordered set=] of
[=URLs=] |renderURLs|, an [=ordered set=] of [=URLs=] |adComponentRenderUrls|, an {{unsigned short}}
|experimentGroupId|, and an [=origin=] |topWindowOrigin|:
1. Let |queryParamsList| be a new empty [=list=].
1. [=list/Append=] "hostname=" to |queryParamsList|.
1. [=list/Append=] the result of [=string/UTF-8 percent-encoding=] |topWindowOrigin| using
  [=component percent-encode set=] to |queryParamsList|.
1. If |renderURLs| is not [=set/is empty|empty=]:
  1. [=list/Append=] "&renderURLs=" to |queryParamsList|.
  1. Let |renderURLsStrings| be a new empty [=list=].
  1. [=list/For each=] |renderURL| of |renderURLs|:
    1. [=list/Append=] the result of [=URL serializer|serialization=] of |renderURL| to
      |renderURLsStrings|.
  1. [=list/Extend=] |queryParamsList| with the result of [=encode trusted signals keys=] with
    |renderURLsStrings|.
1. If |adComponentRenderUrls| is not [=set/is empty|empty=]:
  1. [=list/Append=] "&adComponentRenderUrls=" to |queryParamsList|.
  1. Let |adComponentRenderUrlsStrings| be a new empty [=list=].
  1. [=list/For each=] |adComponentRenderUrl| of |adComponentRenderUrls|:
    1. [=list/Append=] the result of [=URL serializer|serialization=] of |adComponentRenderUrl| to
      |adComponentRenderUrlsStrings|.
  1. [=list/Extend=] |queryParamsList| with the result of [=encode trusted signals keys=] with
    |adComponentRenderUrlsStrings|.
1. If |experimentGroupId| is not null:
  1. [=list/Append=] "&experimentGroupId=" to |queryParamsList|.
  1. [=list/Append=] [=serialize an integer|serialized=] |experimentGroupId| to |queryParamsList|.
1. Set |signalsUrl|'s [=url/query=] to the result of [=string/concatenating=] |queryParamsList|.
1. return |signalsUrl|.

</div>

<div algorithm>

To <dfn>serialize an integer</dfn>, represent it as a string of the shortest possible decimal
number.

Issue: This would ideally be replaced by a more descriptive algorithm in Infra. See
<a href="https://github.com/whatwg/infra/issues/201">infra/201</a>

</div>

<div algorithm>
To <dfn>report result</dfn> given a [=leading bid info=] |leadingBidInfo| and [=auction config=] or null |winningComponentConfig|:
  1. Let |config| be |leadingBidInfo|'s [=leading bid info/auction config=].
  1. Let |bidCurrency| be null.
  1. If |winningComponentConfig| is not null:
    1. [=Assert=] that |leadingBidInfo|'s [=leading bid info/component seller=] is not null.
    1. Set |bidCurrency| to |winningComponentConfig|'s [=auction config/seller currency=].
    1. If |bidCurrency| is null:
      1. Set |bidCurrency| to the result of [=looking up per-buyer currency=] with |config| and |leadingBidInfo|'s [=leading bid info/component seller=].
  1. Otherwise:
    1. Set |bidCurrency| to the result of [=looking up per-buyer currency=] with |config| and |leadingBidInfo|'s [=leading bid info/leading bid=]'s [=generated bid/interest group=]'s [=interest group/owner=].
  1. Let |browserSignals| be an [=ordered map=] whose [=map/keys=] are [=strings=] and whose
    [=map/values=] are {{any}}.
  1. [=map/Set=] |browserSignals|["`topWindowHostname`"] to [=this=]'s
    [=relevant settings object=]'s [=environment/top-level origin=]'s [=origin/host=].
  1. Let |winner| be |leadingBidInfo|'s [=leading bid info/leading bid=].
  1. [=map/Set=] |browserSignals|["`interestGroupOwner`"] to |winner|'s
    [=generated bid/interest group=]'s [=interest group/owner=].
  1. [=map/Set=] |browserSignals|["`renderURL`"] to |winner|'s [=generated bid/ad descriptor=]'s
    [=ad descriptor/url=].
  1. Let |sellerCurrency| be |leadingBidInfo|'s [=leading bid info/auction config=]'s [=auction config/seller currency=].
  1. [=map/Set=] |browserSignals|["`desirability`"] to |leadingBidInfo|'s
    [=leading bid info/top score=].
  1. [=map/Set=] |browserSignals|["`bid`"] to |winner|'s [=generated bid/bid=]'s [=bid with currency/value=] (TODO: This gets rounded).
  1. [=map/Set=] |browserSignals|["`bidCurrency`"] to the result of [=serializing a currency tag=] with |bidCurrency|.

  1. If |sellerCurrency| is null:
    1. [=map/Set=] |browserSignals|["`highestScoringOtherBid`"] to |leadingBidInfo|'s [=leading bid info/highest scoring other bid=]'s [=generated bid/bid=]'s [=bid with currency/value=] (or 0 if encountered a null).
    1. [=map/Set=] |browserSignals|["`highestScoringOtherBidCurrency`"] to "`???`".
  1. Otherwise:
    1. [=map/Set=] |browserSignals|["`highestScoringOtherBid`"] to |leadingBidInfo|'s [=leading bid info/highest scoring other bid=]'s [=generated bid/bid in seller currency=] (or 0 if encountered a null).
    1. [=map/Set=] |browserSignals|["`highestScoringOtherBidCurrency`"] to |sellerCurrency|.
  1. TODO: if trusted scoring signals response data version is not null, set
    |browserSignals|["`dataVersion`"].
  1. If |leadingBidInfo|'s [=leading bid info/top level seller=] is not null, [=map/set=]
    |browserSignals|["`topLevelSeller`"] to it.
  1. If |leadingBidInfo|'s [=leading bid info/top level seller signals=] is not null, [=map/set=]
    |browserSignals|["`topLevelSellerSignals`"] to it.
  1. If |leadingBidInfo|'s [=leading bid info/component seller=] is not null:
    1. [=map/Set=] |browserSignals|["`componentSeller`"] to |leadingBidInfo|'s
      [=leading bid info/component seller=].
    1. If |winner|'s [=generated bid/modified bid=] is not null, [=map/set=]
      |browserSignals|["`bid`"] to it.
  1. Otherwise, if |winner|'s [=generated bid/modified bid=] is not null, [=map/set=]
    |browserSignals|["`modifiedBid`"] to it.
  1. Set |config| to |leadingBidInfo|'s [=leading bid info/auction config=].
  1. Let |sellerReportingScript| be the result of [=fetching script=] with |config|'s
    [=auction config/decision logic url=].
  1. Let |reportResultOutputJS| be the result of [=evaluating a reporting script=] with
     |sellerReportingScript|, "`reportResult`", and « |config|, |browserSignals|».
  1. [=map/Remove=] |browserSignals|["`dataVersion`"].
  1. [=map/Remove=] |browserSignals|["`modifiedBid`"].
  1. [=map/Remove=] |browserSignals|["`topLevelSellerSignals`"].
  1. If |reportResultOutputJS| is an [=ECMAScript/abrupt completion=], return « null, |browserSignals| ».
  1. Let |reportResultOutputIDL| be the result of [=converted to an IDL value|converting=]
     |reportResultOutputJS| to a {{ReportResultOutput}}.
  1. If an exception was [=exception/thrown=] in the previous step, return « null, |browserSignals| ».
  1. TODO: Store |reportResultOutputIDL|["{{ReportResultOutput/reportUrl}}"] and
     |reportResultOutputIDL|["{{ReportResultOutput/reportingBeaconMap}}"] in the
     {{FencedFrameConfig}} as appropriate.
  1. Return « |reportResultOutputIDL|["{{ReportResultOutput/signalsForWinner}}"], |browserSignals| ».
</div>

<div algorithm>
To <dfn>report win</dfn> given a [=leading bid info=] |leadingBidInfo|, a [=string=]
|sellerSignals| and an [=ordered map=] |browserSignals| whose [=map/keys=] are [=strings=] and whose
[=map/values=] are {{any}}:

  1. Let |config| be |leadingBidInfo|'s [=leading bid info/auction config=].
  1. Let |winner| be |leadingBidInfo|'s [=leading bid info/leading bid=].
  1. Let |perBuyerSignals| be |config|'s [=auction config/per buyer signals=].
  1. Let |buyer| be |winner|'s [=generated bid/interest group=]'s [=interest group/owner=].
  1. Let |sellerCurrency| be |config|'s [=auction config/seller currency=].
  1. Let |perBuyerCurrency| be result of [=looking up per-buyer currency=] with |config| and |buyer|.
  1. Let |serializedPerBuyerCurrency| be the result of [=serializing a currency tag=] applied to |perBuyerCurrency|.
  1. Let |perBuyerSignalsForBuyer| be |perBuyerSignals|[|buyer|] if that member [=map/exists=],
    and null otherwise.
  1. [=map/Remove=] |browserSignals|["`desirability`"].
  1. If the result of [=query reporting ID k-anonymity count=] given |winner|'s [=generated bid/interest group=]

    and |winner|'s [=generated bid/ad descriptor=]'s [=ad descriptor/url=] is true:

    1. [=map/Set=] |browserSignals|["`interestGroupName`"] to |winner|'s
      [=generated bid/interest group=] [=interest group/name=].
  1. [=map/Set=] |browserSignals|["`bid`"] to |winner|'s [=generated bid/bid=]'s [=bid with currency/value=]. (TODO: This gets rounded).
  1. [=map/Set=] |browserSignals|["`bidCurrency`"] to |serializedPerBuyerCurrency|.
  1. [=map/Set=] |browserSignals|["`madeHighestScoringOtherBid`"] to false.
  1. Let |highestScoringOtherBidOwner| be |leadingBidInfo|'s
    [=leading bid info/highest scoring other bid owner=].
  1. If |highestScoringOtherBidOwner| is not null, and |buyer| is [=same origin=] with
    |highestScoringOtherBidOwner|:
    1. [=map/Set=] |browserSignals|["`madeHighestScoringOtherBid`"] to true.
  1. If |sellerCurrency| is null:
    1. [=map/Set=] |browserSignals|["`highestScoringOtherBid`"] to |leadingBidInfo|'s [=leading bid info/highest scoring other bid=]'s [=generated bid/bid=]'s [=bid with currency/value=] (or 0 if encountered a null). (TODO: This get rounded).
    1. [=map/Set=] |browserSignals|["`highestScoringOtherBidCurrency`"] to "`???`".
  1. Otherwise:
    1. [=map/Set=] |browserSignals|["`highestScoringOtherBid`"] to |leadingBidInfo|'s [=leading bid info/highest scoring other bid=]'s [=generated bid/bid in seller currency=] (or 0 if encountered a null).  (TODO: This get rounded).
    1. [=map/Set=] |browserSignals|["`highestScoringOtherBidCurrency`"] to |sellerCurrency|.
  1. If |leadingBidInfo|'s [=leading bid info/bidding data version=] is not null:
    1. [=map/Set=] |browserSignals|["`dataVersion`"] to |leadingBidInfo|'s
      [=leading bid info/bidding data version=].
  1. [=map/Set=] |browserSignals|["`adCost`"] to |winner|'s [=generated bid/ad cost=].
  1. [=map/Set=] |browserSignals|["`seller`"] to |config|'s [=auction config/seller=].
  1. If |leadingBidInfo|'s [=leading bid info/top level seller=] is not null:
    1. [=map/Set=] |browserSignals|["`topLevelSeller`"] to |leadingBidInfo|'s
      [=leading bid info/top level seller=].
  1. If |winner|'s [=generated bid/modeling signals=] is not null:
    1. [=map/Set=] |browserSignals|["`modelingSignals`"] to |winner|'s
      [=generated bid/modeling signals=].
  1. Let |buyerReportingScript| be the result of [=fetching script=] with |winner|'s
    [=generated bid/interest group=]'s [=interest group/bidding url=].
  1. Let « nullReturn, |resultUrl|, |reportingBeaconMap| » be the result of [=evaluating a
     reporting script=] with |buyerReportingScript|, "`reportWin`", and « |leadingBidInfo|'s
     [=leading bid info/auction config=]'s [=auction config/auction signals=],
     |perBuyerSignalsForBuyer|, |sellerSignals|, |browserSignals| ».
  1. TODO: Store |resultUrl| and |reportingBeaconMap| in the {{FencedFrameConfig}} as appropriate.
</div>

# K-anonymity # {#k-anonymity}
  
Two goals of this specification rely on applying k-anonymity thresholds:
  
  * To prevent cross-site leaks:  Inputs to event-level reporting functions, `reportWin()` and
    `reportResult()`, only contain limited cross-site information. As described in
    [[#privacy-considerations]], part of this limiting is done by
    applying k-anonymity requirements to the ad URLs.
  * To prevent microtargeting:  The browser applies k-anonymity requirements on the ad URLs to
    ensure that the same ad or ad component is being shown to at least some minimum number of
    people.

The browser enforces these k-anonymity requirements by maintaining counts of how many times each
ad and ad component has been shown to users. These counts are maintained across users, so the counting must
be done on a central <dfn>k-anonymity server</dfn>. This specification relies on two operations to query and
increment the counts: [=query k-anonymity count=] and [=increment k-anonymity count=].
  
The details of how the [=k-anonymity server=] is operated and accessed are [=implementation-defined=]
but it should be done in a way that prevents the server operator from joining the identity of two
query or increment requests. One way to help prevent this is by making accesses to the server go
through an HTTP proxy that prevents the server from seeing the browsers' IP addresses.

The browser should choose a <dfn>k-anonymity threshold</dfn>, otherwise known as the value for "k", 
and a <dfn>k-anonymity duration</dfn> depending
on the projected sizes of interest groups and the browser's privacy goals. For example an implementation
might choose to require a k-anonymity threshold of fifty users over a seven day period. The server
will maintain the count over the chosen duration and compare the count to the chosen k-anonymity
threshold when responding to [=query k-anonymity count=].

<div algorithm>
  To <dfn>query k-anonymity count</dfn> given a |hashCode|:
    1. If the [=k-anonymity server=] has recorded at least [=k-anonymity threshold=] users
        seeing |hashCode| over the last [=k-anonymity duration=], return true.
        Otherwise return false.
    1. Return true if it is above the threshold, otherwise return false.
</div>

<div algorithm>
  To <dfn>query ad k-anonymity count</dfn> given an [=interest group=] |ig| and a [=URL=] |ad|:
    1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      1. "AdBid"
      1. the [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      1. the [=URL serializer|serialization=] of |ig|'s [=interest group/bidding url=]
      1. the [=URL serializer|serialization=] of |ad|.
    1. Let |keyHash| be the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.

    1. Return the result of [=query k-anonymity count|querying the k-anonymity count=] given |keyHash|.
</div>

<div algorithm>
  To <dfn>query component ad k-anonymity count</dfn> given a [=URL=] |ad|:
    1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      1. "ComponentBid"
      1. the [=URL serializer|serialization=] of |ad|.
    1. Let |keyHash| be the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.

    1. Return the result of [=query k-anonymity count|querying the k-anonymity count=] given |keyHash|.
</div>

<div algorithm>
  To <dfn>query generated bid k-anonymity count</dfn> given a [=generated bid=] |bid|:
    1. If [=query ad k-anonymity count=] given |bid|'s [=generated bid/ad descriptor=]'s
      [=ad descriptor/url=] returns false, return false.
    1. If |bid|'s [=generated bid/ad component descriptors=] is not null:
      1. [=set/For each=] |adComponentDescriptor| in |bid|'s
        [=generated bid/ad component descriptors=]:
        1. If [=query component ad k-anonymity count=] given |adComponentDescriptor|'s
          [=ad descriptor/url=] returns false, return false.
    1. Return true.
 
</div>
  
<div algorithm>
  To <dfn>query reporting ID k-anonymity count</dfn> given an [=interest group=] |ig| and a [=URL=] |ad|:
    1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      1. "NameReport"
      1. the [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      1. the [=URL serializer|serialization=] of |ig|'s [=interest group/bidding url=]
      1. the [=URL serializer|serialization=] of |ad|
      1. |ig|'s [=interest group/name=].
    1. Let |keyHash| be the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.

    1. Return the result of [=query k-anonymity count|querying the k-anonymity count=] given |keyHash|.
</div>

<div algorithm>
  To <dfn>increment k-anonymity count</dfn> given a |hashCode|:
    1. Ask the [=k-anonymity server=] to record that this user agent has seen |hashCode|.
</div>

<div algorithm>
  To <dfn>increment ad k-anonymity count</dfn> given an [=interest group=] |ig| and a [=URL=] |ad|:
    1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      1. "AdBid"
      1. the [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      1. the [=URL serializer|serialization=] of |ig|'s [=interest group/bidding url=]
      1. the [=URL serializer|serialization=] of |ad|.
    1. Let |keyHash| be the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.
    1. [=Increment k-anonymity count=] given |keyHash|.
</div>

<div algorithm>
  To <dfn>increment component ad k-anonymity count</dfn> given a [=URL=] |ad|:
    1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      1. "ComponentBid"
      1. the [=URL serializer|serialization=] of |ad|.
    1. Let |keyHash| be the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.
    1. [=Increment k-anonymity count=] given |keyHash|.
</div>

<div algorithm>
  To <dfn>increment reporting ID k-anonymity count</dfn> given an [=interest group=] |ig| and a [=URL=]
  |ad|:
    1. Let |keyString| be the [=string/concatenation=] of the following strings separated with U+000A LF:
      1. "NameReport"
      1. the [=serialization of an origin|serialization=] of |ig|'s [=interest group/owner=]
      1. the [=URL serializer|serialization=] of |ig|'s [=interest group/bidding url=]
      1. the [=URL serializer|serialization=] of |ad|
      1. |ig|'s [=interest group/name=].
    1. Let |keyHash| be the [=SHA-256=] hash of the [=ASCII encoding=] of |keyString|.
    1. [=Increment k-anonymity count=] given |keyHash|.
</div>

# Script Runners # {#script-runners}

*This introduction sub-section is non-normative*.

This specification defines a new type of script execution environment called a [=script runner=]. On
the surface, these are similar to <a href=https://html.spec.whatwg.org/C#worklets-intro>Worklets</a>
in that they too are used for running scripts independent of the *main* execution environment with a
flexible implementation model.

However, some key differences from traditional Worklets motivate us to create a new kind of script
execution environment. In particular, they:

 * Are not scoped to a particular {{Document}}, but are rather scoped to a user agent, as they are
   spun up by [=interest groups=] in the user agent's [=interest group set=].
 * Consequently have a different, more flexible [=ECMAScript/agent cluster=] allocation model —
   specifically, they need not execute in the same [=ECMAScript/agent cluster=] as any {{Document}},
   and for privacy reasons implementations may be motivated to enjoy this flexibility.
 * Do not have any other WebIDL interfaces exposed to their global besides the ones defined in this
   specification, unlike other Worklet types.
 * Have a restricted set of ECMAScript APIs exposed to them; for example {{Date}} is not exposed in
   these environments.
 * Are not [=module scripts=], and are instead evaluated as if they were [=classic scripts=].
 * Are not [=scripts=] in the [[HTML]] sense, and as such:
   * Their [=ECMAScript/agent=] does not have an [=event loop=]
   * Their [=ECMAScript/realm=] does not have a [=realm/settings object=], and therefore functions
     inside them are not run with the familiar [[WebIDL]] [=invoke|invocation=] mechanism.
   * They do not [=perform a microtask checkpoints=].

## Script evaluation ## {#script-evaluation}

Concretely, a <dfn>script runner</dfn> is a JavaScript execution environment instantiated with one
of the following global objects:

 * {{InterestGroupBiddingScriptRunnerGlobalScope}}
 * {{InterestGroupScoringScriptRunnerGlobalScope}}
 * {{InterestGroupReportingScriptRunnerGlobalScope}}

<div algorithm>
  To <dfn>evaluate a bidding script</dfn> given a [=string=] |script|, an [=interest group=] |ig|, a
  [=currency tag=] |expectedCurrency|, a {{GenerateBidInterestGroup}} |igGenerateBid|, a [=string=]-or-null
  |auctionSignals|, a [=string=]-or-null |perBuyerSignals|, an [=ordered map=] |trustedBiddingSignals|, a
  {{BiddingBrowserSignals}} |browserSignals|, and an integer millisecond [=duration=] |timeout|:

    1. Let |global| be a new {{InterestGroupBiddingScriptRunnerGlobalScope}}.
    1. Set |global|'s
      [=InterestGroupBiddingScriptRunnerGlobalScope/group has ad components=] to true if |ig|'s
      [=interest group/ad components=] is not null, or false otherwise.
    1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/expected currency=] to |expectedCurrency|.
    1. Let |isComponentAuction| be true if |browserSignals|["{{BiddingBrowserSignals/topLevelSeller}}"] is not null, or
      false otherwise.
    1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/is component auction=] to
      |isComponentAuction|.
    1. Set |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/interest group=] to |ig|.
    1. Let |igJS| be the result of [=converted to ECMAScript values|converting to ECMAScript values=]
      given |igGenerateBid|.
    1. Let |auctionSignalsJS| be the result of [=parsing a JSON string to a JavaScript value=] given
      |auctionSignals| if |auctionSignals| is not null, otherwise undefined.
    1. Let |perBuyerSignalsJS| be the result of [=parsing a JSON string to a JavaScript value=]
      given |perBuyerSignals| if |perBuyerSignals| is not null, otherwise undefined.
    1. Let |browserSignalsJS| be the result of [=converted to ECMAScript values|converting to ECMAScript values=]
      given |browserSignals|.
    1. Let |startTime| be the [=current wall time=].
    1. Let |result| be the result of [=evaluating a script=] with |global|, |script|, "`generateBid`",
      « |igJS|, |auctionSignalsJS|, |perBuyerSignalsJS|, |trustedBiddingSignals|, |browserSignalsJS| »,
      and |timeout|.
    1. Let |duration| be the [=current wall time=] minus |startTime| in milliseconds.
    1. If |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/priority=] is not null:
      1. Set |ig|'s [=interest group/priority=] to |global|'s
        [=InterestGroupBiddingScriptRunnerGlobalScope/priority=].
      1. [=list/Replace=] the [=interest group=] that has |ig|'s [=interest group/owner=] and [=interest group/name=] in the browser’s [=interest group set=] with |ig|.
    1. If |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/priority signals=]
      [=map/is not empty=]:
      1. [=map/For each=] |k| → |v| of |global|'s
        [=InterestGroupBiddingScriptRunnerGlobalScope/priority signals=]:
        1. If |v| is null, [=map/remove=] |ig|'s [=interest group/priority signals overrides=][|k|].
        1. Otherwise, [=map/set=] |ig|'s [=interest group/priority signals overrides=][|k|] to |v|.
      1. [=list/Replace=] the [=interest group=] that has |ig|'s [=interest group/owner=] and [=interest group/name=] in the browser’s [=interest group set=] with |ig|.
    1. Let |generatedBid| be |global|'s [=InterestGroupBiddingScriptRunnerGlobalScope/bid=].
    1. If |result| is a [=ECMAScript/normal completion=]:
      1. Let |generatedBidIDL| be the result of [=converted to an IDL value|converting=]
        |result|'s \[[Value]] to a {{GenerateBidOutput}}.
      1. If no exception was [=exception/thrown=] in the previous step:
        1. Let |groupHasAdComponents| be true.
        1. If |ig|'s [=interest group/ad components=] is null, set |groupHasAdComponents| be false.
        1. Let |possibleGeneratedBid| be the result of [=converting GenerateBidOutput to generated bid=]
          with |generatedBidIDL|, |ig|, |expectedCurrency|, |isComponentAuction|, and |groupHasAdComponents|.
        1. If |possibleGeneratedBid| is not failure, set |generatedBid| to it.
    1. If |generatedBid| is null, set it to failure.
    1. If |generatedBid| is not failure:
      1. Set |generatedBid|'s [=generated bid/bid duration=] to |duration|.
      1. Set |generatedBid|'s [=generated bid/interest group=] to |ig|.
    1. Return |generatedBid|.
</div>

<div algorithm>
  To <dfn>evaluate a scoring script</dfn> given a [=string=] |script|, a [=list=] of arguments
  |arguments|, and an integer millisecond duration |timeout|:

    1. Let |global| be a new {{InterestGroupScoringScriptRunnerGlobalScope}}.
    1. Return the result of [=evaluating a script=] with |global|, |script|, "`scoreAd`",
      |arguments|, and |timeout|.
</div>

<div algorithm>
  To <dfn>evaluate a reporting script</dfn> given a [=string=] |script|, a [=string=]
  |functionName|, and a [=list=] of arguments |arguments|:

    1. Let |global| be a new {{InterestGroupReportingScriptRunnerGlobalScope}}.
    1. Let |result| be the result of [=evaluating a script=] with |global|, |script|,
      |functionName|, |arguments|, and 50.
    1. Return « |result|, |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/report url=],
       |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/reporting beacon map=] ».
</div>

<br>

<div algorithm>
  To <dfn>create a new script runner agent</dfn>, run these steps:

    1. Let |signifier| be a new unique internal value.

    1. Let |candidateExecution| be a new [=ECMAScript/candidate execution=].

    1. Return a new [=ECMAScript/agent=] whose \[[CanBlock]] is false, \[[Signifier]] is
       |signifier|, \[[CandidateExecution]] is |candidateExecution|, and \[[IsLockFree1]],
       \[[IsLockFree2]], and \[[LittleEndian]] are set at the implementation's discretion.

  Note: This algorithm is almost identical to [[HTML]]'s [=create an agent=] algorithm, with the
  exception that we do not give 
  the returned agent a new [=event loop=], since it does not process
  [=tasks=] within [=task sources=] in the usual way.
</div>

<div algorithm>
  To <dfn>obtain a script runner agent</dfn>, run these steps:

    1. Let |agentCluster| be a  new [=ECMAScript/agent cluster=].

    1. Let |agent| be the result of [=creating a new script runner agent=].

    1. Add |agent| to |agentCluster|.

    1. Return |agent|.
</div>

<div algorithm>
  To <dfn>evaluate a script</dfn> with a [=realm/global object=] |global|, [=string=] |script|, [=string=]
  |functionName|, a [=list=] |arguments|, and an integer millisecond duration |timeout|, run these steps.
  They return a [=ECMAScript/Completion Record=], which is either an [=ECMAScript/abrupt completion=] (in
  the case of a parse failure or execution error), or a [=ECMAScript/normal completion=] populated with the
  [=ECMAScript/ECMAScript language value=] result of invoking |functionName|.

    1. [=Assert=] that these steps are running [=in parallel=].

    1. Let |agent| be the result of [=obtaining a script runner agent=] given null, true, and
       false. Run the rest of these steps in |agent|.

       Issue: This exclusively creates a new [=ECMAScript/agent cluster=] for the given |script| to
       run in, but we should make this work with [=interest group/execution mode=] somehow.

    1. Let |realmExecutionContext| be the result of [=creating a new realm=] given |agent| and the
       following customizations:

        * For the global object, use |global|.

    1. Let |realm| be |realmExecutionContext|'s Realm component.

    1. Let |global| be |realm|'s [=realm/global object=], and run these steps:

      1. Perform !|global|.\[[Delete]]("`Date`").

      1. If !|global|.\[[HasProperty]]("`Temporal`") is true, then perform
         !|global|.\[[Delete]]("`Temporal`").

      Advisement: This is not the best way to perform such API neutering (see <a
      href=https://github.com/tc39/ecma262/issues/1357#issuecomment-817560121>tc39/ecma262#1357</a>),
      but at the moment it's the way that host environments do this.

      Note: Removing time-referencing APIs from the |global| object is imperative for privacy, as
      |script| might otherwise be able to more easily exfiltrate data by using more accurate time
      measurements.

    1. Let |result| be [$ParseScript$](|script|, |realm|, `empty`).

       Note: The resulting [=ECMAScript/Script Record=] will have no \[[HostDefined]] component,
       unlike traditional [=scripts=] on the web platform.

    1. If |result| is a list of errors, return
       Completion { \[[Type]]: `throw`, \[[Value]]: |result|, \[[Target]]: `empty` }.

    1. [=Assert=]: |result| is a [=ECMAScript/Script Record=].

    1. *Prepare to run script*: Push |realmExecutionContext| onto the [=ECMAScript/execution context
       stack|JavaScript execution context stack=]; it is now the [=ECMAScript/running execution
       context|running JavaScript execution context=].

    1. Let |evaluationStatus| be the result of [$ScriptEvaluation$](result).

    1. If |evaluationStatus| is an [=ECMAScript/abrupt completion=], jump to the step labeled <i><a
       href=#evaluate-script-return>return</a></i>.

    1. Let |F| be [$Get$](|global|, |functionName|). If that returns a [=ECMAScript/throw completion=],
       set |finalCompletion| to |F| and jump to the step labeled <i><a
       href=#evaluate-script-return>return</a></i>.

    1. Set |finalCompletion| be [=ECMAScript/Completion Record|Completion=]([$Call$](F, `undefined`,
       |arguments|)).
       
       In |timeout| milliseconds, if the invocation of [$Call$] has not completed,
       [=immediately=] interrupt the execution and set |finalCompletion| to a new
       [=ECMAScript/throw completion=] given null.

    1. <i id=evaluate-script-return>Return</i>: at this point |finalCompletion| will be set to a
       [=ECMAScript/Completion Record=].

      1. *Clean up after script*: [=Assert=] |realmExecutionContext| is the [=ECMAScript/running
         execution context|running JavaScript execution context=], and remove it from the
         [=ECMAScript/execution context stack|JavaScript execution context stack=].

      1. Return |finalCompletion|.
</div>

## Global scopes ## {#global-scopes}

An additional requirement to the interest group script runner globals defined in this specification
is that they must not expose any interfaces from other specifications whose own exposure set is the
special value "*". The only interfaces that can be exposed inside of the globals defined in this
specification are those that explicitly list the global names provided here.

<pre class="idl">
[Exposed=InterestGroupScriptRunnerGlobalScope]
interface InterestGroupScriptRunnerGlobalScope {
};

</pre>

### InterestGroupBiddingScriptRunnerGlobalScope ### {#bidding-global-scope}

<pre class="idl">
[Exposed=InterestGroupBiddingScriptRunnerGlobalScope,
 Global=(InterestGroupScriptRunnerGlobalScope,
         InterestGroupBiddingScriptRunnerGlobalScope)]
interface InterestGroupBiddingScriptRunnerGlobalScope
        : InterestGroupScriptRunnerGlobalScope {
  boolean setBid();
  boolean setBid(GenerateBidOutput generateBidOutput);
  undefined setPriority(double priority);
  undefined setPrioritySignalsOverride(DOMString key, double priority);
};

dictionary AdRender {
  required DOMString url;
  required DOMString width;
  required DOMString height;
};

dictionary GenerateBidOutput {
  required double bid;
  DOMString bidCurrency;
  required (DOMString or AdRender) adRender;
  any ad;
  sequence<(DOMString or AdRender)> adComponents;
  double adCost;
  double modelingSignals;
  boolean allowComponentAuction = false;
};

</pre>

Each {{InterestGroupBiddingScriptRunnerGlobalScope}} has a
<dl dfn-for="InterestGroupBiddingScriptRunnerGlobalScope">
: <dfn>bid</dfn>
:: A [=generated bid=]
: <dfn>priority</dfn>
:: Null or a {{double}}
: <dfn>priority signals</dfn>
:: An [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are {{double}}
: <dfn>interest group</dfn>
:: An [=interest group=]
: <dfn>expected currency</dfn>
:: A [=currency tag=]
: <dfn>is component auction</dfn>
:: A [=boolean=]
: <dfn>group has ad components</dfn>
:: A [=boolean=]

</dl>

<div algorithm>
  The <dfn method for="InterestGroupBiddingScriptRunnerGlobalScope">setBid()</dfn> method steps are:

  1. Set [=this=]'s [=relevant global object=]'s [=InterestGroupBiddingScriptRunnerGlobalScope/bid=]
    to null.
  1. Return true.
</div>

<div algorithm>

To <dfn>convert GenerateBidOutput to generated bid</dfn> given a {{GenerateBidOutput}} |generateBidOutput|,
an [=interest group=] |ig|, a [=currency tag=] |expectedCurrency|, a [=boolean=] |isComponentAuction| and a [=boolean=] |groupHasAdComponents|:
  1. If |generateBidOutput|["{{GenerateBidOutput/bid}}"] is less than or equal to 0, return failure.
  1. If |isComponentAuction| is true, and
    |generateBidOutput|["{{GenerateBidOutput/allowComponentAuction}}"] is false:
    1. Return failure.
  1. Let |bid| be a new [=generated bid=].
  1. Let |bidCurrency| be null.
  1. If |generateBidOutput|["{{GenerateBidOutput/bidCurrency}}"] is specified:
     1. If the result of [=checking whether a string is a valid currency tag=] on |generateBidOutput|["{{GenerateBidOutput/bidCurrency}}"] is true:
       1. Set |bidCurrency| to |generateBidOutput|["{{GenerateBidOutput/bidCurrency}}"]
     1. Otherwise return failure.
  1. If the result of [=checking a currency tag=] with |expectedCurrency| and |bidCurrency| is false, return failure.
  1. Set |bid|'s [=generated bid/bid=] to a [=bid with currency=] with [=bid with currency/value=] |generateBidOutput|["{{GenerateBidOutput/bid}}"] and [=bid with currency/currency=] |bidCurrency|.
  1. If |generateBidOutput|["{{GenerateBidOutput/ad}}"] [=map/exists=]:
    1. Let |adJSON| be the result of [=serializing a JavaScript value to a JSON string=], given
      |generateBidOutput|["{{GenerateBidOutput/ad}}"].
    1. If |adJSON| is failure, return failure.
    1. Set |bid|'s [=generated bid/ad=] to |adJSON|.
  1. Let |adDescriptor| be a new [=ad descriptor=].
  1. If |generateBidOutput|["{{GenerateBidOutput/adRender}}"] is a {{DOMString}}:
    1. Let |adUrl| be the result of running the [=URL parser=] on
      |generateBidOutput|["{{GenerateBidOutput/adRender}}"].
    1. If |adUrl| is failure, return failure.
    1. If [=validating an ad url=] given |adUrl|, |ig|, and false returns false, return failure.
    1. Set |adDescriptor|'s [=ad descriptor/url=] to |adUrl|.
  1. Otherwise:
    1. Set |adDescriptor| to the result of [=converting an ad render=] given
      |generateBidOutput|["{{GenerateBidOutput/adRender}}"], |ig| and false.
    1. If |adDescriptor| is failure, return failure.
  1. Set |bid|'s [=generated bid/ad descriptor=] to |adDescriptor|.
  1. If |generateBidOutput|["{{GenerateBidOutput/adComponents}}"] [=map/exists=]:
    1. Let |adComponents| be |generateBidOutput|["{{GenerateBidOutput/adComponents}}"].
    1. Return failure if any of the following conditions hold:
      * |groupHasAdComponents| is false;
      * |adComponents|'s size is greater than 20.
    1. Let |adComponentDescriptors| be a new [=list=] of [=ad descriptors=].
    1. For |component| in |adComponents|:
      1. Let |componentDescriptor| be a new [=ad descriptor=].
      1. If |component| is {{DOMString}}:
        1. Let |componentUrl| be the result of running the [=URL parser=] on |component|.
        1. If |componentUrl| is failure, return failure.
        1. If [=validating an ad url=] given |componentUrl|, |ig|, and true returns false, return failure.
        1. Set |componentDescriptor|'s [=ad descriptor/url=] to |componentUrl|.
      1. Otherwise:
        1. Set |componentDescriptor| to the result of [=converting an ad render=] given |component|, |ig|,
          and true.
        1. If |componentDescriptor| is failure, return failure.
      1. [=list/Append=] |componentDescriptor| to |adComponentDescriptors|.
    1. Set |bid|'s [=generated bid/ad component descriptors=] to |adComponentDescriptors|.
  1. If |generateBidOutput|["{{GenerateBidOutput/adCost}}"] [=map/exists=]:
    1. Set |bid|'s [=generated bid/ad cost=] to
      |generateBidOutput|["{{GenerateBidOutput/adCost}}"].
  1. If |generateBidOutput|["{{GenerateBidOutput/modelingSignals}}"] [=map/exists=]:
    1. Let |modelingSignals| be |generateBidOutput|["{{GenerateBidOutput/modelingSignals}}"].
    1. If |modelingSignals| is greater than or equal to 0 and less than 4096:
      1. Set |bid|'s [=generated bid/modeling signals=] to |modelingSignals|.
  1. Return |bid|.

</div>

<div algorithm>
  To <dfn>parse an AdRender dimension value</dfn> given a [=string=] |input|:
  
  1. Let |position| be a [=string/position variable=], initially pointing at the start of |input|.
  1. [=Strip leading and trailing ASCII whitespace=] from |input|.
  1. If |input| [=string/starts with=] "`0`" but [=string/is=] not "`0`" and does not
     [=string/start with=] "`0.`", then return null as the dimension and the empty string as the dimension unit.
  1. [=Collect a sequence of code points=] that are [=ASCII digits=] or U+002E (.), given |position|. Let that be |dimensionString|.
  1. If |dimensionString| is the empty string, then return null as the dimension and the empty string as the dimension unit.
  1. Let |dimension| be the result of parsing |dimensionString| using the [=rules for parsing floating-point number values=].
  1. If |dimension| is an error, then return null as the dimension and the empty string as the dimension unit.
  1. [=Collect a sequence of code points=] that are [=ASCII lower alpha=], given |position|. Let that be |dimensionUnit|.
  1. If |position| is not past the end of |input|, then return null as the dimension and the empty string as the dimension unit.
  1. If |dimensionUnit| [=string/is=] the empty string, then set |dimensionUnit| to "px".
  1. If |dimensionUnit| [=string/is=] not "px", "sh", or "sw", then return null as the dimension and the empty string as the
     dimension unit.
  1. Return |dimension| as the dimension and |dimensionUnit| as the dimension unit.
</div>

<div algorithm>
  To <dfn>convert an ad render</dfn> given an {{AdRender}} |adRender|, an [=interest group=] |ig|,
  and a [=boolean=] |isComponent|:

  1. If |adRender|["{{AdRender/url}}"] does not [=map/exist=], return false.
  1. Let |adUrl| be the result of running the [=URL parser=] on |adRender|["{{AdRender/url}}"].
  1. If |adUrl| is failure, return failure.
  1. If [=validating an ad url=] given |adUrl|, |ig|, and |isComponent| returns false, return failure.
  1. Let |adDescriptor| be a new [=ad descriptor=].
  1. Set |adDescriptor|'s [=ad descriptor/url=] to |adUrl|.
  1. If |adRender|["{{AdRender/width}}"] [=map/exists=]:
    1. If |adRender|["{{AdRender/height}}"] does not [=map/exist=], return failure.
    1. Let |width| and |widthUnit| be the dimension and dimension unit that results from running
      [=parse an AdRender dimension value=] with |adRender|["{{AdRender/width}}"], respectively.
    1. If |width| is null, return failure.
    1. Let |height| and |heightUnit| be the dimension and dimension unit that results from running
      [=parse an AdRender dimension value=] with |adRender|["{{AdRender/height}}"], respectively.
    1. If |height| is null, return failure.
    1. Let |adSize| be a new [=ad size=].
    1. Set |adSize|'s [=ad size/width=] to |width|, [=ad size/width units=] to |widthUnit|,
      [=ad size/height=] to |height|, [=ad size/height units=] to |heightUnit|.
    1. Set |adDescriptor|'s [=ad descriptor/size=] to |adSize|.
  1. Return |adDescriptor|.
</div>

<div algorithm>
  To <dfn>validate an ad url</dfn> given a [=URL=] |adUrl|, an [=interest group=] |ig|, and a
  [=boolean=] |isComponent|:

  1. If |adUrl|'s [=url/scheme=] is not "`https`", return false.
  1. If |isComponent|:
    1. [=list/For each=] |ad| in |ig|'s [=interest group/ad components=]:
      1. If |ad|'s [=interest group ad/render url=] equals |adUrl|, return true.
  1. Otherwise:
    1. [=list/For each=] |ad| in |ig|'s [=interest group/ads=]:
      1. If |ad|'s [=interest group ad/render url=] equals |adUrl|, return true.
  1. Return false.
</div>

<div algorithm>
  The <dfn method for="InterestGroupBiddingScriptRunnerGlobalScope">setBid(|generateBidOutput|)</dfn>
  method steps are:

  1. Set [=this=]'s [=relevant global object=]'s [=InterestGroupBiddingScriptRunnerGlobalScope/bid=]
    to null.
  1. Let |ig| be [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/interest group=].
  1. Let |expectedCurrency| be [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/expected currency=].
  1. Let |bidToSet| be the result of [=converting GenerateBidOutput to generated bid=] with
    |generateBidOutput|, |ig|, |expectedCurrency|, [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/is component auction=], and [=this=]'s
    [=relevant global object=]'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/group has ad components=].
  1. If |bidToSet| is failure, return false.
  1. Set [=this=]'s [=relevant global object=]'s [=InterestGroupBiddingScriptRunnerGlobalScope/bid=]
    to |bidToSet|.
  1. Return true.
</div>

<div algorithm>
  The <dfn method for="InterestGroupBiddingScriptRunnerGlobalScope">setPriority(|priority|)</dfn>
  method steps are:

  1. If [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/priority=] is not null:
    1. Set [=this=]'s [=relevant global object=]'s
      [=InterestGroupBiddingScriptRunnerGlobalScope/priority=] to null.
    1. Return.
  1. Set [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/priority=] to |priority|.
</div>

<div algorithm>
  The <dfn method for="InterestGroupBiddingScriptRunnerGlobalScope">setPrioritySignalsOverride(|key|, |priority|)</dfn>
  method steps are:

  1. [=map/Set=] [=this=]'s [=relevant global object=]'s
    [=InterestGroupBiddingScriptRunnerGlobalScope/priority signals=][|key|] to |priority|.
</div>

### InterestGroupScoringScriptRunnerGlobalScope ### {#scoring-global-scope}

<pre class="idl">
[Exposed=InterestGroupScoringScriptRunnerGlobalScope,
 Global=(InterestGroupScriptRunnerGlobalScope,
         InterestGroupScoringScriptRunnerGlobalScope)]
interface InterestGroupScoringScriptRunnerGlobalScope
        : InterestGroupScriptRunnerGlobalScope {
};

</pre>

### InterestGroupReportingScriptRunnerGlobalScope ### {#reporting-global-scope}

<pre class="idl">
[Exposed=InterestGroupReportingScriptRunnerGlobalScope,
 Global=(InterestGroupScriptRunnerGlobalScope,
         InterestGroupReportingScriptRunnerGlobalScope)]
interface InterestGroupReportingScriptRunnerGlobalScope
        : InterestGroupScriptRunnerGlobalScope {
  undefined sendReportTo(DOMString url);
  undefined registerAdBeacon(record&lt;DOMString, USVString&gt; map);
};

dictionary ReportResultOutput {
  DOMString signalsForWinner;
  USVString reportUrl;
  any reportingBeaconMap;
};

</pre>

Each {{InterestGroupReportingScriptRunnerGlobalScope}} has a
<dl dfn-for="InterestGroupReportingScriptRunnerGlobalScope">
: <dfn>report url</dfn>
:: Null or a [=URL=]. Defaulting to null.
: <dfn>reporting beacon map</dfn>
:: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
  [=URLs=]. Defaulting to null.

</dl>

<div algorithm>
  The <dfn method for="InterestGroupReportingScriptRunnerGlobalScope">sendReportTo(|url|)</dfn>
  method steps are:

  1. If [=this=]'s [=relevant global object=]'s
    [=InterestGroupReportingScriptRunnerGlobalScope/report url=] is not null:
    1. Set [=this=]'s [=relevant global object=]'s
      [=InterestGroupReportingScriptRunnerGlobalScope/report url=] to null.
    1. [=exception/Throw=] a {{TypeError}}.
  1. Let |parsedUrl| be the result of running the [=URL parser=] on |url|.
  1. If |parsedUrl| is failure, or |parsedUrl|'s [=url/scheme=] is not "`https`",
    [=exception/Throw=] a {{TypeError}}.
  1. Set [=this=]'s [=relevant global object=]'s
    [=InterestGroupReportingScriptRunnerGlobalScope/report url=] to |parsedUrl|.
</div>

<div algorithm>
  The <dfn method for="InterestGroupReportingScriptRunnerGlobalScope">registerAdBeacon(|map|)</dfn>
  method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=InterestGroupReportingScriptRunnerGlobalScope/
     reporting beacon map=] is not null, then [=exception/Throw=] a {{TypeError}}.

  1. [=map/For each=] |url| of |map|'s [=map/values=]:

     1. Let |parsedURL| be the result of running [=URL parser=] on |url|.

     1. [=exception/Throw=] a {{TypeError}} if any of the following conditions hold:
        * |parsedURL| is failure;
        * |parsedURL|'s [=url/scheme=] is not "`https`".

  1. Set [=this=]'s [=relevant global object=]'s [=InterestGroupReportingScriptRunnerGlobalScope/
     reporting beacon map=] to |map|.
</div>


# Interest Group Updates # {#interest-group-updates}

[=Interest groups=] have a [=interest group/update url=] field that allows updating the
interest group definition stored on disk with information periodically retrieved from the
[=interest group/update url=].  The [=interest group update=] steps are triggered during
{{Navigator/runAdAuction()}} and by calls to {{Navigator/updateAdInterestGroups()}} API:

<xmp class="idl">
[SecureContext]
partial interface Navigator {
  undefined updateAdInterestGroups();
};
</xmp>

<div algorithm>

The <dfn for=Navigator method>updateAdInterestGroups()</dfn> method steps are:

1. [=In parallel=], run [=interest group update=] with 
  « [=relevant settings object=]'s [=environment/top-level origin=] »

</div>
<div algorithm>
  To <dfn lt="interest group update">update interest groups</dfn> given a [=list=] of [=origins=]
  |owners|:

1. [=list/For each=] |owner| of |owners|:
  1. [=list/For each=] |originalInterestGroup| of the user agent's [=interest group set=] whose
    [=interest group/owner=] is |owner| and [=interest group/next update after=] is before
    the [=current wall time=]:

    Note: Implementations can consider loading only a portion of these interest groups
    at a time to avoid issuing too many requests at once.
    1. Let |ig| be a deep copy of |originalInterestGroup|.
    1. Let |request| be a new [=request=] with the following properties:
      :   [=request/URL=]
      ::  |ig|'s [=interest group/update url=]
      :   [=request/header list=]
      ::  «`Accept`: `application/json`»
      :   [=request/client=]
      ::  `null`
      :   [=request/service-workers mode=]
      ::  "`none`"
      :   [=request/mode=]
      ::  "`no-cors`"
      :   [=request/referrer=]
      :: "`no-referrer`"
      :   [=request/credentials mode=]
      ::  "`omit`"
      :   [=request/redirect mode=]
      :: "`error`"
    1. Let |update| be null.
    1. [=Fetch=] |request| with [=fetch/useParallelQueue=] set to true, and
      [=fetch/processResponseConsumeBody=] set to the following steps given a [=response=] |response|
      and null, failure, or a [=byte sequence=] |responseBody|:
      1. If [=validate fetching response=] with |response|, |responseBody| and "`application/json`"
        returns false, set |update| to failure and return.
      1. Set |update| to |responseBody|.
    1. Wait for |update| to be set.
    1. If |update| is failure, [=iteration/continue=].
    1. Let |parsedUpdate| be the result of [=parsing JSON bytes to an Infra value=], given |update|.
    1. If |parsedUpdate| is failure, [=iteration/continue=].
    1. If |parsedUpdate| is not an [=ordered map=], [=iteration/continue=].
    1. If |parsedUpdate|["`name`"] exists and doesn't match |ig|'s [=interest group/name=], 
      [=iteration/continue=].
    1. If |parsedUpdate|["`owner`"] exists and doesn't match |ig|'s [=interest group/owner=],
      [=iteration/continue=].
    1. [=map/For each=] |key| → |value| of |parsedUpdate|:
      1. Switch on |key|:
        <dl class=switch>
        <dt>"`priority`"
        <dd>
        1. If |value| is a {{double}}, set |ig|'s [=interest group/priority=]
          to |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`enableBiddingSignalsPrioritization`"
        <dd>
        1. If |value| is a {{boolean}}, set |ig|'s
          [=interest group/enable bidding signals prioritization=] to |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`priorityVector`"
        <dd>
        1. If |value| is null or an [=ordered map=] whose [=map/keys=] are [=strings=] and
          whose [=map/values=] are {{double}}, set |ig|'s [=interest group/priority vector=] to
          |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`prioritySignalsOverrides`"
        <dd>
        1. If |value| is an [=ordered map=] whose [=map/keys=] are
          [=strings=] and whose [=map/values=] are {{double}} or null:
          1. [=map/For each=] |pvKey| → |pvValue| of |value|:
            1. If |pvValue| is null, [=map/remove=] |ig|'s [=interest group/priority signals overrides=][|pvKey|].
            1. Otherwise, [=map/set=] |ig|'s [=interest group/priority signals overrides=][|pvKey|] to |pvValue|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`executionMode`"
        <dd>
        1. If |value| is "`compatibility`" or "`group-by-origin`",
          set |ig|'s [=interest group/execution mode=] to |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`biddingLogicURL`"
        <dt>"`biddingWasmHelperURL`"
        <dt>"`updateURL`"
        <dt>"`trustedBiddingSignalsURL`"
        <dd>
        1. For each |groupMember| and |interestGroupField| in the following table
          <table class="data">
            <thead><tr><th>Group member</th><th>Interest group field</th></tr></thead>
            <tr>
              <td>"`biddingLogicURL`"</td>
              <td>[=interest group/bidding url=]</td>
            </tr>
            <tr>
              <td>"`biddingWasmHelperURL`"</td>
              <td>[=interest group/bidding wasm helper url=]</td>
            </tr>
            <tr>
              <td>"`updateURL`"</td>
              <td>[=interest group/update url=]</td>
            </tr>
            <tr>
              <td>"`trustedBiddingSignalsURL`"</td>
              <td>[=interest group/trusted bidding signals url=]</td>
            </tr>
          </table>
          1. Let |parsedURL| be the result of running the [=URL parser=] on |value|.
          1. If |key| is not |groupMember|, [=iteration/continue=].
          1. Jump to the step labeled <i><a href=#abort-update>Abort update</a></i>
            if any of the following conditions hold:
            * |parsedURL| is failure;
            * |parsedURL|'s [=url/origin=] is not [=same origin=] with |ig|'s
              [=interest group/owner=];
            * |parsedURL| [=includes credentials=];
            * |parsedURL| [=url/fragment=] is not null.
          1. Set |ig|'s |interestGroupField| to |parsedURL|.
          
        <dt>"`trustedBiddingSignalsKeys`"
        <dd>
        1. If |value| is a [=list=] of [=strings=],
          set |ig|'s [=interest group/trusted bidding signals keys=] to |value|.
        1. Otherwise, jump to the step labeled <i><a href=#abort-update>Abort update</a></i>.

        <dt>"`ads`"
        <dt>"`adComponents`"
        <dd>
        1. For each |groupMember| and |interestGroupField| in the following table
          <table class="data">
            <thead><tr><th>Group member</th><th>Interest group field</th></tr></thead>
            <tr>
              <td>"`ads`"</td>
              <td>[=interest group/ads=]</td>
            </tr>
            <tr>
              <td>"`adComponents`"</td>
              <td>[=interest group/ad components=]</td>
            </tr>
          </table>
          1. If |key| is not |groupMember|, [=iteration/continue=].
          1. If |value| is not a [=list=] of {{AuctionAd}}, jump to the step
            labeled <i><a href=#abort-update>Abort update</a></i>.
          1. [=list/For each=] |ad| of |value|:
            1. Let |igAd| be a new [=interest group ad=].
            1. Let |renderURL| be the result of running the [=URL parser=] on
              |ad|["{{AuctionAd/renderURL}}"].
            1. Jump to the step labeled <i><a href=#abort-update>Abort update</a></i>
              if any of the following conditions hold:
              * |renderURL| is failure;
              * |renderURL| [=url/scheme=] is not "`https`";
              * |renderURL| [=includes credentials=].
            1. Set |igAd|'s [=interest group ad/render url=] to |renderURL|.
            1. If |ad|["{{AuctionAd/metadata}}"] [=map/exists=], then let
              |igAd|'s [=interest group ad/metadata=] be the result of
              [=serializing a JavaScript value to a JSON string=], given |ad|["{{AuctionAd/metadata}}"].
              If this [=exception/throws=], jump to the step
              labeled <i><a href=#abort-update>Abort update</a></i>.
            1. [=list/Append=] |igAd| to |ig|'s |interestGroupField|.
              
        </dl>

    1. Set |ig|'s [=interest group/next update after=] to the [=current wall time=] plus 24 hours.
    1. [=list/Replace=] the [=interest group=] that has |ig|'s [=interest group/owner=] and
      [=interest group/name=] in the browser’s [=interest group set=] with |ig|.
    1. <i id=abort-update>Abort update</i>: We jump here if some part of the
      [=interest group=] update failed.  [=iteration/Continue=] to the next [=interest group=] update.

</div>


# Permissions Policy integration # {#permissions-policy-integration}

This specification defines two [=policy-controlled features=] identified by the strings
"<code><dfn noexport>join-ad-interest-group</dfn></code>", and
"<code><dfn noexport>run-ad-auction</dfn></code>". Their
[=policy-controlled feature/default allowlists=] are "`*`".

Issue(WICG/turtledove#522): Move from "`*`" to "`self`".


# Structures # {#structures}

<xmp class="idl">

dictionary PreviousWin {
  required long long timeDelta;
  required DOMString adJSON;
};

dictionary BiddingBrowserSignals {
  required DOMString topWindowHostname;
  required USVString seller;
  required long joinCount;
  required long bidCount;

  USVString topLevelSeller;
  sequence<PreviousWin> prevWinsMs;
  object wasmHelper;
  unsigned long dataVersion;
};
</xmp>

<h3 dfn-type=dfn>Interest group</h3>

An interest group is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="interest group">
: <dfn>expiry</dfn>
:: A [=moment=] at which the browser will forget about this interest group.
: <dfn>owner</dfn>
:: An [=origin=]. Frames that join interest groups owned by [=interest group/owner=] must either be
  served from [=interest group/owner=], or another origin delegated by [=interest group/owner=] (See
  [=checking interest group permissions=] for details). The [=origin/scheme=] must be "`https`".
: <dfn>name</dfn>
:: A [=string=]. The ([=interest group/owner=], [=interest group/name=]) tuple is a key that
  uniquely defines each interest group.
: <dfn>priority</dfn>
:: A {{double}}, initially 0.0. Used to select which interest groups participate in an auction
  when the number of interest groups are limited by {{AuctionAdConfig/perBuyerGroupLimits}}.
  See [=applying interest groups limits to prioritized list=].
: <dfn>enable bidding signals prioritization</dfn>
:: A [=boolean=], initially false. Being true if the interest group's priority should be
  calculated using vectors from bidding signals fetch.
: <dfn>priority vector</dfn>
:: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
  {{double}}. Its dot product with the {{AuctionAdConfig/perBuyerPrioritySignals}} will be used
  in place of [=interest group/priority=], if set.
: <dfn>priority signals overrides</dfn>
:: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
  {{double}}. Overrides the {{AuctionAdConfig}}'s corresponding priority signals.
: <dfn>execution mode</dfn>
:: A [=string=], initially "<code>compatibility</code>". Acceptable values are
  "<code>compatibility</code>" and "<code>group-by-origin</code>".
  TODO: Define spec for these execution modes, link to it from here and explain these modes.
: <dfn>bidding url</dfn>
:: Null or a [=URL=]. The URL to fetch the buyer's JavaScript from.
  <p class="note">
    When non-null, the [=interest group/bidding url=]'s [=origin=] will always be [=same origin=]
    with [=interest group/owner=].
  </p>
: <dfn>bidding wasm helper url</dfn>
:: Null or a [=URL=]. Lets the bidder provide computationally-expensive subroutines in WebAssembly,
  in addition to JavaScript, to be driven from the JavaScript function provided by
  [=interest group/bidding url=].
  <p class="note">
    When non-null, the [=interest group/bidding wasm helper url=]'s [=origin=] will always be
    [=same origin=] with [=interest group/owner=].
  </p>
: <dfn>update url</dfn>
:: Null or a [=URL=]. Provides a mechanism for the group's owner to periodically update the
  attributes of the interest group. See [interest group updates](#interest-group-updates).
  <p class="note">
    When non-null, the [=interest group/update url=]'s [=origin=] will always be [=same origin=]
    with [=interest group/owner=].
  </p>
: <dfn>trusted bidding signals url</dfn>
:: Null or a [=URL=]. Provide a mechanism for making real-time data available for use at bidding
  time. See [=building trusted bidding signals url=].
  <p class="note">
    When non-null, the [=interest group/trusted bidding signals url=]'s [=origin=] will always be
    [=same origin=] with [=interest group/owner=].
  </p>
: <dfn>trusted bidding signals keys</dfn>
:: Null or a [=list=] of [=string=]. See [=building trusted bidding signals url=].
: <dfn>user bidding signals</dfn>
:: Null or a [=string=]. Additional metadata that the owner can use during on-device bidding.
: <dfn>ads</dfn>
:: Null or a [=list=] of [=interest group ad=]. Contains various ads that the interest group might
  show.
: <dfn>ad components</dfn>
:: Null or a [=list=] of [=interest group ad=]. Contains various ad components (or "products") that
  can be used to construct ads composed of multiple pieces — a top-level ad template "container"
  which includes some slots that can be filled in with specific "products".
: <dfn>joining origin</dfn>
:: An [=origin=]. The top level page origin from where the interest group was joined.
: <dfn>join counts</dfn>
:: A [=list=] containing [=tuples=] of the day and per day join count. The day
  is calculated based on UTC time. The join count is a count of the number of
  times {{Navigator/joinAdInterestGroup()}} was called for this interest group on the
  corresponding day.
: <dfn>bid counts</dfn>
:: A [=list=] containing [=tuples=] of the day and per day bid count. The day
  is calculated based on UTC time. The bid count is a count of the number of
  times the bid calculated during {{Navigator/runAdAuction()}} was greater than 0.
: <dfn>previous wins</dfn>
:: A [=list=] of [=previous wins=].
: <dfn>next update after</dfn>
:: A [=moment=] at which the browser will permit updating this interest group. See
  [interest group updates](#interest-group-updates).

</dl>

<h3 dfn-type=dfn>Interest group ad</h3>

An interest group ad is a [=struct=] with the following [=struct/items=]:

<dl dfn-for="interest group ad">
: <dfn>render url</dfn>
:: A [=URL=]. If this ad wins the auction, this URL (or a [=urn uuid=] that maps to this URL) will
  be returned by {{Navigator/runAdAuction()}}. This URL is intended to be loaded into an ad
  <{iframe}> (or a <{fencedframe}>).
: <dfn>metadata</dfn>
:: Null or a [=string=]. Extra arbitary information about this ad, passed to `generateBid()`.

</dl>

<h3 dfn-type=dfn>Currency tag</h3>
A currency tag is a [=string=] containing exactly 3 upper-case ASCII letters, or null. The null value is used to denote that the currency is unspecified.

<div algorithm>
  To <dfn>serialize a currency tag</dfn> given a [=currency tag=] |currency|:
  1. If |currency| is null, return "???".
  1. Return |currency|.
</div>

<div algorithm>
  To <dfn>check whether a string is a valid currency tag</dfn> given [=string=] |currencyString|:
  1. If [=string/length=] of |currencyString| is not 3, return false.
  1. If |currencyString|[0] is not a [=ASCII upper alpha=] code point, return false.
  1. If |currencyString|[1] is not a [=ASCII upper alpha=] code point, return false.
  1. If |currencyString|[2] is not a [=ASCII upper alpha=] code point, return false.
  1. Return true.
</div>

<div algorithm>
  To <dfn>check a currency tag</dfn> given the [=currency tags=] |expected| and |actual|:

  1. If |expected| is null, return true.
  1. If |actual| is null, return true.
  1. If |actual| is equal to |expected|, return true.
  1. Return false.
</div>

<h3 dfn-type=dfn>Auction config</h3>

An auction config is a [=struct=] with the following items:

<dl dfn-for="auction config">
: <dfn>seller</dfn>
:: An [=origin=].
  The origin of the seller running the ad auction. The [=origin/scheme=] must be "<code>https</code>".
: <dfn>decision logic url</dfn>
:: A [=URL=].
  The URL to fetch the seller's JavaScript from.
  <p class="note">
    The [=auction config/decision logic url=]'s [=origin=] will always be [=same origin=] with
    [=auction config/seller=].
  </p>
: <dfn>trusted scoring signals url</dfn>
:: Null or a [=URL=].
  Provide a mechanism for making real-time data (information about a specific creative) available
  for use at scoring time, e.g. the results of some ad scanning system.
  <p class="note">
    When non-null, the [=auction config/trusted scoring signals url=]'s [=origin=] will always be
    [=same origin=] with [=auction config/seller=].
  </p>
: <dfn>interest group buyers</dfn>
:: Null or a [=list=] of [=origins=].
  Owners of interest groups allowed to participate in the auction. Each [=origin's=] [=origin/scheme=]
  must be "<code>https</code>".
: <dfn>auction signals</dfn>
:: Null or a [=string=] or a {{Promise}} or failure.
  Opaque JSON data passed to both sellers' and buyers' [=script runners=].
: <dfn>seller signals</dfn>
:: Null or a [=string=] or a {{Promise}} or failure.
  Opaque JSON data passed to the seller's [=script runner=].
: <dfn>seller timeout</dfn>
:: A [=duration=] in milliseconds, initially 50 milliseconds.
  Restricts the runtime of the seller's `scoreAd()` script. If scoring does not complete before
  the timeout, the bid being scored is not considered further.
: <dfn>per buyer signals</dfn>
:: Null or a {{Promise}} or failure or an [=ordered map=] whose [=map/keys=] are [=origins=] and
  whose [=map/values=] are [=strings=].
  [=map/Keys=] are buyers and must be valid HTTPS origins. [=map/Values=] are opaque JSON data
  passed to corresponding buyer's [=script runner=].
: <dfn>per buyer timeouts</dfn>
:: Null or a {{Promise}} or failure or an [=ordered map=] whose [=map/keys=] are [=origins=] and
  whose [=map/values=] are [=durations=] in milliseconds.
  [=map/Keys=] are buyers and must be valid HTTPS origins. [=map/Values=] restrict the runtime of
  corresponding buyer's `generateBid()` script. If the timeout expires, only the bid submitted
  via `setBid()` is considered.
: <dfn>all buyers timeout</dfn>
:: A [=duration=] in milliseconds, initially 50 milliseconds.
  Restricts the `generateBid()` script's runtime for all buyers without a timeout specified in
  [=auction config/per buyer timeouts=]. If the timeout expires, only the bid submitted via
  `setBid()` is considered.
: <dfn>per buyer group limits</dfn>
:: Null or an [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are
  {{unsigned short}}s.
  [=map/Keys=] are buyers and must be valid HTTPS origins. [=map/Values=] restrict the number of
  bidding interest groups for a particular buyer that can participate in an auction.
: <dfn>all buyers group limit</dfn>
:: An {{unsigned short}}, initially 65535.
  Limit on the number of bidding interest groups for all buyers without a limit specified in
  [=auction config/per buyer group limits=].
: <dfn>per buyer priority signals</dfn>
:: Null or an [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are
  [=ordered maps=], whose [=map/keys=] are [=strings=] and whose [=map/values=] are {{double}}.
  Per-buyer sparse vector whose dot product with [=interest group/priority vector=] is used to
  calculate interest group priorities. No signal's key starts with "browserSignals.", which is
  reserved for values coming from the browser.
: <dfn>all buyers priority signals</dfn>
:: Null or an [=ordered map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
  {{double}}.
  Merged with [=auction config/per buyer priority signals=] before calculating per-interest group
  priorities. In the case both have entries with the same key, the entry in
  `per_buyer_priority_signals` takes precedence. No signals key start with "browserSignals.", which
  is reserved for values coming from the browser.
: <dfn>component auctions</dfn>
:: A [=list=] of [=auction config=]s.
  Nested auctions whose results will also participate in a top level auction. Only the top level
  [=auction config=] can have component auctions.
: <dfn>seller experiment group id</dfn>
:: Null or an {{unsigned short}}, initially null.
  Optional identifier for an experiment group to support coordinated experiments with the seller's
  trusted server.
: <dfn>per buyer experiment group ids</dfn>
:: An [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are
  {{unsigned short}}s.
  [=map/Keys=] are buyers and must be valid HTTPS origins. [=map/Values=] are identifiers for
  experiment groups, to support coordinated experiments with buyers' trusted servers.
: <dfn>all buyer experiment group id</dfn>
:: Null or an {{unsigned short}}, initially null.
  Optional identifier for an experiment group to support coordinated experiments with buyers'
  trusted servers for buyers without a specified experiment group.
: <dfn>pending promise count</dfn>
:: An integer, initially 0. The number of [=auction config/auction signals=],
  [=auction config/per buyer signals=], [=auction config/per buyer timeouts=], or
  [=auction config/seller signals=] whose {{Promise}}s are not yet resolved.
: <dfn>config idl</dfn>
:: {{AuctionAdConfig}}.
: <dfn>resolve to config</dfn>
:: A [=boolean=] or a {{Promise}}, initially false.
  Whether the ad should be returned as a {{FencedFrameConfig}}, or otherwise as a [=urn uuid=].
: <dfn>seller currency</dfn>
:: A [=currency tag=]. Specifies the currency bids returned by `scoreAd()` are expected to use, and which reporting for this auction will agree on.

: <dfn>per buyer currencies</dfn>
:: An [=ordered map=] whose [=map/keys=] are [=origins=] and whose [=map/values=] are [=currency tags=]. Specifies the currency bids returned by `generateBid()` or `scoreAd()` in component auctions are expected to use.

: <dfn>all buyers currency</dfn>
:: A [=currency tag=]. Specifies the currency bids returned by `generateBid()` or `scoreAd()` in component auctions are expected to use if [=auction config/per buyer priority signals=] does not specify a particular value.


</dl>

<div algorithm>
  To <dfn>look up per-buyer currency</dfn> given an [=auction config=] |auctionConfig|, and an [=origin=] |buyer|:

  1. Let |perBuyerCurrency| be |auctionConfig|'s [=auction config/all buyers currency=]
  1. If |auctionConfig|'s [=auction config/per buyer currencies=][|buyer|] [=map/exists=]:
      1. Set |perBuyerCurrency| to |auctionConfig|'s [=auction config/per buyer currencies=][|buyer|].
  1. Return |perBuyerCurrency|
</div>

<h3 dfn-type=dfn>Per buyer bid generator</h3>

A per buyer bid generator is an [=ordered map=] whose [=map/keys=] are [=URLs=] representing
[=interest group/trusted bidding signals urls=], and whose [=map/values=] are
[=per signals url bid generators=].

<h3 dfn-type=dfn>Per signals url bid generator</h3>

A per signals url bid generator is an [=ordered map=] whose [=map/keys=] are [=origins=]
representing [=interest group/joining origins=], and whose [=map/values=] are [=lists=] of
[=interest groups=].


<h3 dfn-type=dfn>Previous win</h3>

The [=interest group=]'s auction win history, to allow on-device frequency capping.


<dl dfn-for="previous win">
: <dfn>time</dfn>
:: A [=moment=]. Approximate time the [=interest group=] won an auction.
: <dfn>ad json</dfn>
:: A [=string=]. A JSON serialized object corresponding to the ad that won the auction.

</dl>

<h3 dfn-type=dfn>Bid with currency</h3>
Numeric value of a bid and the currency it is in.

<dl dfn-for="bid with currency">
: <dfn>value</dfn>
:: A {{double}}. The value of the bid.
: <dfn>currency</dfn>
:: A [=currency tag=]. The currency the bid is in.

</dl>

<h3 dfn-type=dfn>Generated bid</h3>

The output of running a Protected Audience `generateBid()` script, which needs to be scored by
the seller.

<dl dfn-for="generated bid">
: <dfn>bid</dfn>
:: A [=bid with currency=]. If the [=bid with currency/value=] is zero or negative, then this interest group will not participate in
  the auction.
: <dfn>bid in seller currency</dfn>
:: A {{double}} or null. An equivalent of the original bid in seller's currency. This is either the original bid if the currency already matched, or a conversion provided by `scoreAd()`.
: <dfn>ad</dfn>
:: A [=string=]. JSON string to be passed to the scoring function.
: <dfn>ad descriptor</dfn>
:: An [=ad descriptor=]. Render URL and size of the bid's ad.
: <dfn>ad component descriptors</dfn>
:: Null or a [=list=] of [=ad descriptors=]. Ad components associated with bid, if any. May have at
  most 20 URLs. Must be null if the interest group making this bid has a null
  [=interest group/ad components=] field.
: <dfn>ad cost</dfn>
:: Null or a {{double}}. Advertiser click or conversion cost passed from `generateBid()` to
  `reportWin()`. Invalid values, such as negative, infinite, and NaN values, will be ignored and not
  passed. Only the lowest 12 bits will be passed.
: <dfn>modeling signals</dfn>
:: Null or an {{unsigned short}}. A 0-4095 integer (12-bits) passed to `reportWin()`, with noising.
: <dfn>interest group</dfn>
:: An [=interest group=], whose `generateBid()` invocation generated this bid.
: <dfn>modified bid</dfn>
:: Null or a [=bid with currency=]. Being null for top level auction.
  The bid value a component auction's `scoreAd()` script returns.
: <dfn>bid duration</dfn>
:: A [=duration=] in milliseconds. How long it took to run `generateBid()`.

</dl>

<h3 dfn-type=dfn>Ad descriptor</h3>

The render URL and size of an ad.

<dl dfn-for="ad descriptor">
: <dfn>url</dfn>
:: A [=URL=], which will be rendered to display the creative if this bid wins the auction.
: <dfn>size</dfn>
:: Null or an [=ad size=], initially null.

</dl>

<h3 dfn-type=dfn>Ad size</h3>

Width and height of an ad.

<dl dfn-for="ad size">
: <dfn>width</dfn>
:: A {{double}}.
: <dfn>width units</dfn>
:: A [=string=]. Can only be one of "px" (pixel), "sh" (screen height), and "sw" (screen width).
: <dfn>height</dfn>
:: A {{double}}.
: <dfn>height units</dfn>
:: A [=string=]. Can only be one of "px" (pixel), "sh" (screen height), and "sw" (screen width).

</dl>

<h3 dfn-type=dfn>Score ad output</h3>

The output of running a Protected Audience `scoreAd()` script, is represented using the following type:
<pre class="idl">
dictionary ScoreAdOutput {
  required double desirability;
  double bid;
  DOMString bidCurrency;
  double incomingBidInSellerCurrency;
  boolean allowComponentAuction = false;
};
</pre>
Either a dictionary of this type, or a {{double}}, are handled as the return values.

The meanings of the fields are as follows:
<dl class=domintro>
  <dt>{{ScoreAdOutput/desirability}}
  <dd>Numeric score of the bid. Must be positive or the ad will be rejected. The winner of the auction
  is the bid which was given the highest score.
  <dt>{{ScoreAdOutput/bid}}
  <dd>Only relevant if this is a component auction.  If present, this will be passed to the top-level seller's `scoreAd()` and `reportResult()` methods instead of the original bid, if the ad wins the component auction and top-level auction, respectively.
  <dt>{{ScoreAdOutput/bidCurrency}}
  <dd>Only relevant if this is a component auction and {{ScoreAdOutput/bid}} is set. Specifies which currency the {{ScoreAdOutput/bid}} field is in.
  <dt>{{ScoreAdOutput/incomingBidInSellerCurrency}}
  <dd>Provides a conversion of the incoming bid to auction's seller currency. This is different from {{ScoreAdOutput/bid}} which is the bid the component auction itself produces.
  <dt>{{ScoreAdOutput/allowComponentAuction}}
  <dd>If the bid being scored is from a component auction and this value is not true, the bid is ignored. This field must be present and true both when the component seller scores a bid, and when that bid is being scored by the top-level auction.
</dl>

TODO: This also has an ad field, which should behave similar to the way {{ScoreAdOutput/bid}} affects [=generated bid/modified bid=], and then affecting the adMetadata parameter to scoreAd.

<div algorithm>

To <dfn>process scoreAd output</dfn> given an [=ECMAScript/Completion Record=] |result|:
  1. If |result| is an an [=ECMAScript/abrupt completion=], return failure.
  1. If |result|.\[[Value]] is a [=Number=]:
    1. Let |checkedScore| be the result of [=converted to an IDL value|converting=] |result|.\[[Value]] to a {{double}}.
    1. If an exception was [=exception/thrown=] in the previous step, return failure.
    1. Let |resultIDL| be a new {{ScoreAdOutput}}.
    1. Set |resultIDL|'s {{ScoreAdOutput/desirability}} to |checkedScore|.
    1. Return |resultIDL|.
  1. Let |resultIDL| be the result of [=converted to an IDL value|converting=]
          |result|.\[[Value]] to a {{ScoreAdOutput}}.
  1. If an exception was [=exception/thrown=] in the previous step, return failure.
  1. If |resultIDL|["{{ScoreAdOutput/bidCurrency}}"] [=map/exists=] and result of
     [=checking whether a string is a valid currency tag=] applied to |resultIDL|["{{ScoreAdOutput/bidCurrency}}"] is false:
      1. Return failure.
  1. Return |resultIDL|.
</div>

<h3 dfn-type=dfn>Leading bid info</h3>

Information of the auction's leading bid so far when ranking scored bids.

<dl dfn-for="leading bid info">
: <dfn>top score</dfn>
:: A {{double}}, initially 0.0. The highest score so far.
: <dfn>top bids count</dfn>
:: An integer, initially 0. The number of bids with the same `top score`.
: <dfn>at most one top bid owner</dfn>
:: A [=boolean=], initially true. Whether all bids of `top score` are from the same interest
  group owner.
: <dfn>leading bid</dfn>
:: Null or a [=generated bid=]. The leading bid of the auction so far.
: <dfn>auction config</dfn>
:: An [=auction config=]. The auction config of the auction which generated this
  [=leading bid info/leading bid=].
: <dfn>second highest score</dfn>
:: A {{double}}, initially 0.0. The second highest score so far. If more than one bids tie with
  `top score`, this will be set to `top score`.
: <dfn>highest scoring other bids count</dfn>
:: An integer, initially 0. The number of bids with the same `second highest score`.
: <dfn>highest scoring other bid</dfn>
:: Null or a [=generated bid=]. The second highest scoring other bid.
: <dfn>highest scoring other bid owner</dfn>
:: Null or an [=origin=], initially null. The interest group owner that made bids with the
  `second highest score`. Set to null if there are more than one owners made bids with the
  `second highest score`. 
: <dfn>top level seller</dfn>
:: Null or a [=string=]. The seller in the top level auction.  Only set for component auctions, null
  otherwise.
: <dfn>top level seller signals</dfn>
:: Null or a [=string=]. Signals from the seller in the top level auction, produced as the output
  of the top-level seller's `reportResult()` method.  Only set for component auctions,
  null otherwise.
: <dfn>component seller</dfn>
:: Null or a [=string=]. Seller in component auction which generated this
  [=leading bid info/leading bid=]. Only set the top level auction when component auctions are
  present, null otherwise.
: <dfn>bidding data version</dfn>
:: Null or an {{unsigned long}}.
  Data-Version value from the trusted bidding signals server's response(s). Will only be not null if
  the Data-Version header was provided and had a consistent value for all of the trusted bidding
  signals server responses used to construct the trustedBiddingSignals.
: <dfn>scoring data version</dfn>
:: Null or an {{unsigned long}}.
  Data-Version value from the trusted scoring signals server's response. Will only be not null if
  the Data-Version header was provided in the response headers from the trusted scoring signals
  server.

</dl>

# Privacy Considerations # {#privacy-considerations}

Protected Audience aims to advance the privacy of remarketing and custom audience
advertising on the web, so naturally privacy considerations are paramount to Protected Audience’s
design.  Partitioning data by site is the central mechanism to prevent joining a user’s identity
across sites:
- Interest group definitions come from just one site, the site that called
  {{Navigator/joinAdInterestGroup()}}.
- Bidding (`generateBid()`) and scoring (`scoreAd()`) scripts are exposed to interest group data
  from the joining site, and data from the site that will display the ad, but these scripts are run
  in strict isolation to prevent leaking this cross-site information.
- The browser can enforce that trusted bidding and scoring signals are fetched from servers
  complying with certain privacy requirements, e.g. not performing event-level logging.
- Ads are rendered in <{fencedframe}>s that isolate them from the surrounding page to prevent
  cross-site leakage.
- Reporting is strictly controlled by the browser to prevent cross-site leaks:  Inputs to
  event-level reporting functions, `reportWin()` and `reportResult()`, only contain limited
  cross-site information, e.g. the k-anonymous ad URL.  Event-level reporting is meant to be a
  temporary stepping stone to more private mechanisms like [Private Aggregation
  API](https://github.com/patcg-individual-drafts/private-aggregation-api).


# Security Considerations # {#security-considerations}

Protected Audience involves the browser running untrusted JavaScript downloaded from multiple
parties, so security concerns are top of mind. Fortunately Protected Audience is a highly
constrained API not attempting to be a general purpose execution environment. Execution of this
JavaScript is controlled and limited as follows:
- Protected Audience requires the origin of the scripts’ URLs to match that of the origin of the
  interest group owner, which is in turn required to match the origin of the context calling the
  {{Navigator/joinAdInterestGroup()}}.
- URL schemes are required to be HTTPS.
- Redirects are disallowed.
- Responses are required to contain the `X-Allow-Protected-Audience: true` header.
- Fetches are uncredentialed.

Protected Audience has the browser pass in several “browserSignals” to the bidding script that give the script
unforgeable information about the context that the script is being executed in. This way bidders
and sellers have the choice to only participate in auctions where they are comfortable working with
the involved parties.

The [execution environment](#script-runners) available to these scripts is the absolute minimum necessary to calculate

a bid. It supports only ECMAScript. It does not support network, storage, timer, date, DOM,
Workers, postMessage, Navigator or Window APIs.

Protected Audience adds Permission-Policies to control access to the Protected Audience APIs to
give sites and embedders the ability to clamp down on use of the APIs as they see fit.
